diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
index 1291562fe112a5566f08d65defc241ddf77e69ab..f0bda4e545092aa545432d293cdf8d6abb2c55cc 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_asymmetric.c
@@ -20,6 +20,83 @@
  */
 
 /*!@{*/
+psa_status_t tfm_crypto_sign_message(psa_invec in_vec[],
+                                     size_t in_len,
+                                     psa_outvec out_vec[],
+                                     size_t out_len)
+{
+#ifdef TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 0, 1);
+
+    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    uint8_t *signature = out_vec[0].base;
+    size_t signature_size = out_vec[0].len;
+    mbedtls_svc_key_id_t encoded_key;
+
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_sign_message(encoded_key, alg, input, input_length,
+                            signature, signature_size, &(out_vec[0].len));
+#endif /* TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED */
+}
+
+psa_status_t tfm_crypto_verify_message(psa_invec in_vec[],
+                                       size_t in_len,
+                                       psa_outvec out_vec[],
+                                       size_t out_len)
+{
+#ifdef TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
+
+    if ((in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec))) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    const uint8_t *signature = in_vec[2].base;
+    size_t signature_length = in_vec[2].len;
+    mbedtls_svc_key_id_t encoded_key;
+    psa_status_t status = tfm_crypto_check_handle_owner(key_id);
+
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_verify_message(encoded_key, alg, input, input_length,
+                              signature, signature_length);
+#endif /* TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED */
+}
+
 psa_status_t tfm_crypto_sign_hash(psa_invec in_vec[],
                                   size_t in_len,
                                   psa_outvec out_vec[],
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_symmetric_key.c b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_symmetric_key.c
index 4fa24a4512d4a1d2e317696d3fb44a1e7567999f..759fc336c7e273646bfc3750f9af397bc5133811 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_symmetric_key.c
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_symmetric_key.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  * Copyright (c) 2018-2019, Laurence Lundblade.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -27,7 +27,7 @@
 static psa_key_handle_t symmetric_iak_handle = 0;
 
 /* Instance ID for symmetric IAK */
-static uint8_t instance_id_buf[PSA_HASH_SIZE(INSTANCE_ID_HASH_ALG) + 1];
+static uint8_t instance_id_buf[PSA_HASH_LENGTH(INSTANCE_ID_HASH_ALG) + 1];
 static size_t instance_id_len = 0;
 
 #ifdef INCLUDE_COSE_KEY_ID
@@ -177,7 +177,7 @@ enum psa_attest_err_t attest_register_initial_attestation_key(void)
     }
 
     /* Setup the key attributes */
-    psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN);
+    psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH);
     psa_set_key_algorithm(&key_attributes, key_alg);
     psa_set_key_type(&key_attributes, PSA_KEY_TYPE_HMAC);
 
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
index 4e5a2f4abdc619ab2793c8a78abb6726b21b93cf..41a725bb4ccf46f4ec30b59212496e8a7323b70b 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_encrypted_object.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -28,7 +28,9 @@
 /* FIXME: add the tag length to the crypto buffer size to account for the tag
  * being appended to the ciphertext by the crypto layer.
  */
-#define PS_CRYPTO_BUF_LEN (PS_MAX_ENCRYPTED_OBJ_SIZE + PS_TAG_LEN_BYTES)
+#define PS_TAG_IV_LEN_MAX   ((PS_TAG_LEN_BYTES > PS_IV_LEN_BYTES) ? \
+                             PS_TAG_LEN_BYTES : PS_IV_LEN_BYTES)
+#define PS_CRYPTO_BUF_LEN (PS_MAX_ENCRYPTED_OBJ_SIZE + PS_TAG_IV_LEN_MAX)
 
 static uint8_t ps_crypto_buf[PS_CRYPTO_BUF_LEN];
 
@@ -53,7 +55,8 @@ static psa_status_t ps_object_auth_decrypt(uint32_t fid,
     uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
     size_t out_len;
 
-    err = ps_crypto_setkey();
+    err = ps_crypto_setkey(obj->header.crypto.ref.key_label,
+                           sizeof(obj->header.crypto.ref.key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
@@ -100,7 +103,8 @@ static psa_status_t ps_object_auth_encrypt(uint32_t fid,
     uint8_t *p_obj_data = (uint8_t *)&obj->header.info;
     size_t out_len;
 
-    err = ps_crypto_setkey();
+    err = ps_crypto_setkey(obj->header.crypto.ref.key_label,
+                           sizeof(obj->header.crypto.ref.key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
@@ -141,14 +145,22 @@ psa_status_t ps_encrypted_object_read(uint32_t fid, struct ps_object_t *obj)
     /* Read the encrypted object from the the persistent area */
     err = psa_its_get(fid, PS_OBJECT_START_POSITION,
                       PS_MAX_OBJECT_SIZE,
-                      (void *)obj->header.crypto.ref.iv,
+                      (void *)ps_crypto_buf,
                       &data_length);
     if (err != PSA_SUCCESS) {
         return err;
     }
 
-    /* Get the decrypt size */
+    /* Get the decrypt size. IV is also stored by ITS service. It is at the end
+     * of the read out data. Toolchains may add padding byte after iv array in
+     * crypto.ref structure. Separate the copies of header.info and iv array to
+     * skip the padding byte.
+     */
     decrypt_size = data_length - sizeof(obj->header.crypto.ref.iv);
+    tfm_memcpy(&obj->header.info, ps_crypto_buf, decrypt_size);
+    tfm_memcpy(obj->header.crypto.ref.iv,
+               ps_crypto_buf + decrypt_size,
+               sizeof(obj->header.crypto.ref.iv));
 
     /* Decrypt the object data */
     err = ps_object_auth_decrypt(fid, decrypt_size, obj);
@@ -172,11 +184,19 @@ psa_status_t ps_encrypted_object_write(uint32_t fid, struct ps_object_t *obj)
         return err;
     }
 
+    /* The IV will also be stored. The encrypted data is stored in ps_crypto_buf
+     * now. Append the value of the 'iv' to the end of the encrypted data.
+     * Toolchains may add padding byte after iv array in crypto.ref structure.
+     * The padding byte shall not be written into the storage area.
+     */
+    (void)tfm_memcpy(ps_crypto_buf + wrt_size,
+                     obj->header.crypto.ref.iv,
+                     sizeof(obj->header.crypto.ref.iv));
     wrt_size += sizeof(obj->header.crypto.ref.iv);
 
     /* Write the encrypted object to the persistent area. The tag values is not
      * copied as it is stored in the object table.
      */
-    return psa_its_set(fid, wrt_size, (const void *)obj->header.crypto.ref.iv,
+    return psa_its_set(fid, wrt_size, (const void *)ps_crypto_buf,
                        PSA_STORAGE_FLAG_NONE);
 }
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/rsa_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/rsa_alt.c
index b48c57a5767e5a06570c9f15e1188fda6869c792..507e3e66dc8535f6d32baa43efd5660f525fc704 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/rsa_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/rsa_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2020, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -14,7 +14,6 @@
 #if defined(MBEDTLS_RSA_C)
 
 #include "mbedtls/rsa.h"
-#include "mbedtls/rsa_internal.h"
 #include "mbedtls/oid.h"
 #include "mbedtls_common.h"
 #include "mbedtls/bignum.h"
@@ -135,19 +134,19 @@ static int32_t mbedtls_rsa_uint32_buf_to_mpi(mbedtls_mpi *X, const uint32_t *buf
 {
      int32_t err = 0;
 
-     if(X == NULL || X->p != NULL || X->n != 0 || sizeInWords == 0) {
+     if(X == NULL || X->MBEDTLS_PRIVATE(p) != NULL || X->MBEDTLS_PRIVATE(n) != 0 || sizeInWords == 0) {
         err = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
         goto End;
      }
 
-    if( ( X->p = (uint32_t*)mbedtls_calloc( sizeInWords, sizeof(uint32_t) ) ) == NULL ) {
+    if( ( X->MBEDTLS_PRIVATE(p) = (uint32_t*)mbedtls_calloc( sizeInWords, sizeof(uint32_t) ) ) == NULL ) {
         err = MBEDTLS_ERR_MPI_ALLOC_FAILED;
         goto End;
     }
 
-    CC_PalMemCopy(X->p, buf, sizeInWords*CC_32BIT_WORD_SIZE);
-    X->s = 1;
-    X->n = sizeInWords;
+    CC_PalMemCopy(X->MBEDTLS_PRIVATE(p), buf, sizeInWords*CC_32BIT_WORD_SIZE);
+    X->MBEDTLS_PRIVATE(s) = 1;
+    X->MBEDTLS_PRIVATE(n) = sizeInWords;
 
     End:
     return err;
@@ -299,30 +298,23 @@ static int error_mapping_cc_to_mbedtls_rsa (CCError_t cc_error, CC_RSA_OP op)
     return ret;
 }
 
-void mbedtls_rsa_init( mbedtls_rsa_context *ctx,
-        int padding,
-        int hash_id )
+void mbedtls_rsa_init( mbedtls_rsa_context *ctx)
 {
     /* check input parameters and functions */
     if (ctx == NULL){
             CC_PalAbort("Ctx is NULL\n");
     }
-    if ((hash_id != MBEDTLS_MD_NONE) && ((hash_id < MBEDTLS_MD_SHA1) || (hash_id > MBEDTLS_MD_SHA512))){
-            CC_PalAbort("Not valid hash id\n");
-    }
     CC_PalMemSetZero(ctx, sizeof( mbedtls_rsa_context));
 
-    mbedtls_rsa_set_padding( ctx, padding, hash_id );
-
 #if defined(MBEDTLS_THREADING_C)
-    mbedtls_mutex_init( &ctx->mutex );
+    mbedtls_mutex_init( &ctx->MBEDTLS_PRIVATE(mutex) );
 #endif
 }
 
 /*
  * Set padding for an existing RSA context
  */
-void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, int hash_id )
+int mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, mbedtls_md_type_t hash_id )
 {
     /* check input parameters and functions */
     if (ctx == NULL){
@@ -331,8 +323,10 @@ void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, int hash_id
     if ((hash_id != MBEDTLS_MD_NONE) && ((hash_id < MBEDTLS_MD_SHA1) || (hash_id > MBEDTLS_MD_SHA512))){
             CC_PalAbort("Not valid hash id\n");
     }
-    ctx->padding = padding;
-    ctx->hash_id = hash_id;
+    ctx->MBEDTLS_PRIVATE(padding) = padding;
+    ctx->MBEDTLS_PRIVATE(hash_id) = hash_id;
+
+    return (0);
 }
 
 #if defined(MBEDTLS_GENPRIME)
@@ -470,17 +464,17 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *pCtx,    /*!< pointer to context s
 
 
     /* allocate mbedtls context internal buffers and copy data to them  */
-    pCtx->len = keySizeBytes; /* full size of modulus in bytes, including leading zeros*/
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->N, pCcPubKey->n, keySizeWords ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->E, pCcPubKey->e, PUB_EXP_SIZE_IN_WORDS ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->D, pCcPrivKey->PriveKeyDb.NonCrt.d, keySizeWords ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->NP, ((RsaPubKeyDb_t*)(pCcPubKey->ccRSAIntBuff))->NP,
+    pCtx->MBEDTLS_PRIVATE(len) = keySizeBytes; /* full size of modulus in bytes, including leading zeros*/
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(N), pCcPubKey->n, keySizeWords ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(E), pCcPubKey->e, PUB_EXP_SIZE_IN_WORDS ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(D), pCcPrivKey->PriveKeyDb.NonCrt.d, keySizeWords ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(NP), ((RsaPubKeyDb_t*)(pCcPubKey->ccRSAIntBuff))->NP,
                            CC_PKA_BARRETT_MOD_TAG_SIZE_IN_WORDS ) );
 
     /*  P,Q saved in the context as it is done in mbedtls independent on
      * CRT compilation flag  */
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->P, pKeyGenData->KGData.p, keySizeWords/2 ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->Q, pKeyGenData->KGData.q, keySizeWords/2 ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(P), pKeyGenData->KGData.p, keySizeWords/2 ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(Q), pKeyGenData->KGData.q, keySizeWords/2 ) );
 
     /* calculate Barrett tags for P,Q and set into context */
     err = PkiCalcNp(((RsaPrivKeyDb_t *)(pCcPrivKey->ccRSAPrivKeyIntBuff))->Crt.PP,/*out*/
@@ -493,8 +487,8 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *pCtx,    /*!< pointer to context s
     if (err != CC_OK) {
         goto End;
     }
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->BPP, ((RsaPrivKeyDb_t*)(pCcPrivKey->ccRSAPrivKeyIntBuff))->Crt.PP, CC_PKA_BARRETT_MOD_TAG_SIZE_IN_WORDS ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->BQP, ((RsaPrivKeyDb_t*)(pCcPrivKey->ccRSAPrivKeyIntBuff))->Crt.QP, CC_PKA_BARRETT_MOD_TAG_SIZE_IN_WORDS ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(BPP), ((RsaPrivKeyDb_t*)(pCcPrivKey->ccRSAPrivKeyIntBuff))->Crt.PP, CC_PKA_BARRETT_MOD_TAG_SIZE_IN_WORDS ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(BQP), ((RsaPrivKeyDb_t*)(pCcPrivKey->ccRSAPrivKeyIntBuff))->Crt.QP, CC_PKA_BARRETT_MOD_TAG_SIZE_IN_WORDS ) );
 
     /* calculate CRT parameters */
 #if !defined(MBEDTLS_RSA_NO_CRT)
@@ -512,9 +506,9 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *pCtx,    /*!< pointer to context s
     }
 
     /* allocate mbedtls context internal buffers and copy data to them  */
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->DP, pCcPrivKey->PriveKeyDb.Crt.dP, keySizeWords/2 ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->DQ, pCcPrivKey->PriveKeyDb.Crt.dQ, keySizeWords/2 ) );
-    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->QP, pCcPrivKey->PriveKeyDb.Crt.qInv, keySizeWords/2 ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(DP), pCcPrivKey->PriveKeyDb.Crt.dP, keySizeWords/2 ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(DQ), pCcPrivKey->PriveKeyDb.Crt.dQ, keySizeWords/2 ) );
+    MBEDTLS_RSA_CHK( mbedtls_rsa_uint32_buf_to_mpi( &pCtx->MBEDTLS_PRIVATE(QP), pCcPrivKey->PriveKeyDb.Crt.qInv, keySizeWords/2 ) );
 #endif /* MBEDTLS_RSA_NO_CRT */
 
 #ifdef FIPS_CERTIFICATION
@@ -554,8 +548,8 @@ static int rsa_check_context_alt( mbedtls_rsa_context const *ctx, int is_priv,
      * P,Q need to be present or not. In this function this variable is not used */
     ((void) blinding_needed);
 
-    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
-        ctx->len > MBEDTLS_MPI_MAX_SIZE )
+    if( ctx->MBEDTLS_PRIVATE(len) != mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) ) ||
+        ctx->MBEDTLS_PRIVATE(len) > MBEDTLS_MPI_MAX_SIZE )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -566,8 +560,8 @@ static int rsa_check_context_alt( mbedtls_rsa_context const *ctx, int is_priv,
 
     /* Modular exponentiation wrt. N is always used for
      * RSA public key operations. */
-    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
-        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
+    if( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) <= 0 ||
+        mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(N), 0 ) == 0  )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -577,10 +571,10 @@ static int rsa_check_context_alt( mbedtls_rsa_context const *ctx, int is_priv,
      * used for private key operations and if CRT
      * is used. */
     if( is_priv &&
-        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
-          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
-          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
-          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
+        ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) <= 0 ||
+          mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(P), 0 ) == 0 ||
+          mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) <= 0 ||
+          mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(Q), 0 ) == 0  ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -591,18 +585,18 @@ static int rsa_check_context_alt( mbedtls_rsa_context const *ctx, int is_priv,
      */
 
     /* Always need E for public key operations */
-    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
+    if( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) <= 0 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
 #if defined(MBEDTLS_RSA_NO_CRT)
     /* For private key operations, use D or DP & DQ
      * as (unblinded) exponents. */
-    if( is_priv && mbedtls_mpi_cmp_int( &ctx->D, 0 ) <= 0 )
+    if( is_priv && mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) <= 0 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 #else
     if( is_priv &&
-        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
-          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
+        ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DP), 0 ) <= 0 ||
+          mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DQ), 0 ) <= 0  ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -612,7 +606,7 @@ static int rsa_check_context_alt( mbedtls_rsa_context const *ctx, int is_priv,
      * but check for QP >= 1 nonetheless. */
 #if !defined(MBEDTLS_RSA_NO_CRT)
     if( is_priv &&
-        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(QP), 0 ) <= 0 )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -694,7 +688,7 @@ int mbedtls_rsa_validate_params_alt( const mbedtls_mpi *N, const mbedtls_mpi *P,
         }
 
         if( P != NULL ) {
-            ret = RsaPrimeTestCall( &ccRndCtx, &P->p[0], mbedtls_mpi_size_in_words(P),
+            ret = RsaPrimeTestCall( &ccRndCtx, &P->MBEDTLS_PRIVATE(p)[0], mbedtls_mpi_size_in_words(P),
                                     rabinTestsCount,
                                     &isPrime, pTempBuff/*3*modSizeWords*/,
                                     CC_RSA_PRIME_TEST_MODE );
@@ -704,7 +698,7 @@ int mbedtls_rsa_validate_params_alt( const mbedtls_mpi *N, const mbedtls_mpi *P,
             }
         }
         if( Q != NULL ) {
-            ret = RsaPrimeTestCall( &ccRndCtx, &Q->p[0], mbedtls_mpi_size_in_words(Q),
+            ret = RsaPrimeTestCall( &ccRndCtx, &Q->MBEDTLS_PRIVATE(p)[0], mbedtls_mpi_size_in_words(Q),
                                     rabinTestsCount,
                                     &isPrime, pTempBuff/*3*modSizeWords*/,
                                     CC_RSA_PRIME_TEST_MODE );
@@ -900,21 +894,21 @@ cleanup:
  */
 int mbedtls_rsa_check_pubkey( const mbedtls_rsa_context *ctx )
 {
-    if( ctx == NULL || !ctx->N.p || ( ctx->N.s != 1 ) || !ctx->E.p || ( ctx->E.s != 1 ) )
+    if( ctx == NULL || !ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p) || ( ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(s) != 1 ) || !ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p) || ( ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(s) != 1 ) )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 
     /* check oddness */
-    if( ( ctx->N.p[0] & 1 ) == 0 ||
-        ( ctx->E.p[0] & 1 ) == 0 )
+    if( ( ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p)[0] & 1 ) == 0 ||
+        ( ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p)[0] & 1 ) == 0 )
           return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED);
 
-    if( mbedtls_mpi_bitlen( &ctx->N ) < MBEDTLS_RSA_MIN_VALID_KEY_SIZE_VALUE_IN_BITS ||
-        mbedtls_mpi_bitlen( &ctx->N ) > MBEDTLS_RSA_MAX_VALID_KEY_SIZE_VALUE_IN_BITS )
+    if( mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) < MBEDTLS_RSA_MIN_VALID_KEY_SIZE_VALUE_IN_BITS ||
+        mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) > MBEDTLS_RSA_MAX_VALID_KEY_SIZE_VALUE_IN_BITS )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 
 
-    if( mbedtls_mpi_bitlen( &ctx->E ) < 2 ||
-        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
+    if( mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(E) ) < 2 ||
+        mbedtls_mpi_cmp_mpi( &ctx->MBEDTLS_PRIVATE(E), &ctx->MBEDTLS_PRIVATE(N) ) >= 0 )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 
     return( 0 );
@@ -939,15 +933,15 @@ int mbedtls_rsa_check_privkey( const mbedtls_rsa_context *ctx )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
-    if( mbedtls_rsa_validate_params_alt( &ctx->N, &ctx->P, &ctx->Q,
-                                         &ctx->D, &ctx->E, NULL, NULL ) != 0 )
+    if( mbedtls_rsa_validate_params_alt( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q),
+                                         &ctx->MBEDTLS_PRIVATE(D), &ctx->MBEDTLS_PRIVATE(E), NULL, NULL ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
-    if( mbedtls_rsa_validate_crt_alt( &ctx->P, &ctx->Q, &ctx->D,
-                                      &ctx->DP, &ctx->DQ, &ctx->QP ) != 0 )
+    if( mbedtls_rsa_validate_crt_alt( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(D),
+                                      &ctx->MBEDTLS_PRIVATE(DP), &ctx->MBEDTLS_PRIVATE(DQ), &ctx->MBEDTLS_PRIVATE(QP) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
@@ -967,8 +961,8 @@ int mbedtls_rsa_check_pub_priv( const mbedtls_rsa_context *pub, const mbedtls_rs
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
-    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
-        mbedtls_mpi_cmp_mpi( &pub->E, &prv->E ) != 0 )
+    if( mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(N), &prv->MBEDTLS_PRIVATE(N) ) != 0 ||
+        mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(E), &prv->MBEDTLS_PRIVATE(E) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
@@ -1027,35 +1021,35 @@ static CCError_t validate_mbedtls_rsa_context_private_key(mbedtls_rsa_context *
         GOTO_END( CC_RSA_INVALID_PRIV_KEY_STRUCT_POINTER_ERROR );
     }
 
-    if (ctx->N.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p) == NULL)
     {
         GOTO_END( CC_RSA_INVALID_MODULUS_POINTER_ERROR );
     }
 
-    if (ctx->len == 0)
+    if (ctx->MBEDTLS_PRIVATE(len) == 0)
     {
         GOTO_END( CC_RSA_INVALID_MODULUS_SIZE );
     }
 
 #if defined(MBEDTLS_RSA_NO_CRT)
-    if (ctx->D.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(D).MBEDTLS_PRIVATE(p) == NULL)
     {
         GOTO_END( CC_RSA_INVALID_EXPONENT_POINTER_ERROR );
     }
 #else
-    if (ctx->P.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(P).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_CRT_FIRST_FACTOR_POINTER_ERROR );
 
-    if (ctx->Q.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_CRT_SECOND_FACTOR_POINTER_ERROR );
 
-    if (ctx->DP.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(DP).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_CRT_FIRST_FACTOR_EXP_PTR_ERROR );
 
-    if (ctx->DQ.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(DQ).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_CRT_SECOND_FACTOR_EXP_PTR_ERROR );
 
-    if (ctx->QP.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(QP).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_CRT_COEFFICIENT_PTR_ERROR );
 
 #endif
@@ -1074,14 +1068,14 @@ static CCError_t validate_mbedtls_rsa_context_public_key(mbedtls_rsa_context * c
     }
 
     /* ...... checking the validity of the exponent pointer ............... */
-    if (ctx->E.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_EXPONENT_POINTER_ERROR );
 
     /* ...... checking the validity of the modulus pointer .............. */
-    if (ctx->N.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p) == NULL)
         GOTO_END( CC_RSA_INVALID_MODULUS_POINTER_ERROR );
 
-    if (ctx->len == 0)
+    if (ctx->MBEDTLS_PRIVATE(len) == 0)
     {
         GOTO_END( CC_RSA_INVALID_MODULUS_SIZE );
     }
@@ -1124,9 +1118,9 @@ static CCError_t build_cc_priv_non_crt_key(
     /* ................. checking the validity of the pointer arguments ....... */
     /* ------------------------------------------------------------------------ */
     CHECK_AND_RETURN_ERR_UPON_FIPS_ERROR();
-    ModulusSize = mbedtls_mpi_size(&ctx->N);
-    PubExponentSize = mbedtls_mpi_size(&ctx->E);
-    PrivExponentSize = mbedtls_mpi_size(&ctx->D);
+    ModulusSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(N));
+    PubExponentSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(E));
+    PrivExponentSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(D));
 
     /* ...... checking the validity of the modulus size, private exponent can not be more than 256 bytes .............. */
     if (ModulusSize > CC_RSA_MAX_VALID_KEY_SIZE_VALUE_IN_BYTES)
@@ -1148,8 +1142,8 @@ static CCError_t build_cc_priv_non_crt_key(
     /* clear the private key db */
     CC_PalMemSetZero(PrivKey_ptr, sizeof(CCRsaPrivKey_t));
 
-    CC_PalMemCopy(PrivKey_ptr->n, ctx->N.p, ModulusSize);
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.NonCrt.d, ctx->D.p, PrivExponentSize);
+    CC_PalMemCopy(PrivKey_ptr->n, ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p), ModulusSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.NonCrt.d, ctx->MBEDTLS_PRIVATE(D).MBEDTLS_PRIVATE(p), PrivExponentSize);
 
     /* .................. initializing local variables ................... */
     /* ------------------------------------------------------------------- */
@@ -1193,8 +1187,8 @@ static CCError_t build_cc_priv_non_crt_key(
     }
 
     /*  checking that the public exponent is an integer between 3 and modulus - 1 */
-    if ( ctx->E.p != NULL ) {
-        CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.NonCrt.e, ctx->E.p, PubExponentSize);
+    if ( ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p) != NULL ) {
+        CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.NonCrt.e, ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p), PubExponentSize);
         PubExponentEffectiveSizeInBits =
             CC_CommonGetWordsCounterEffectiveSizeInBits(PrivKey_ptr->PriveKeyDb.NonCrt.e, (PubExponentSize+3)/4);
 
@@ -1296,12 +1290,12 @@ static CCError_t build_cc_priv_crt_key(
     /* ................. checking the validity of the pointer arguments ....... */
     /* ------------------------------------------------------------------------ */
     CHECK_AND_RETURN_ERR_UPON_FIPS_ERROR();
-    PSize    = mbedtls_mpi_size(&ctx->P);
-    QSize    = mbedtls_mpi_size(&ctx->Q);
-    dPSize   = mbedtls_mpi_size(&ctx->DP);
-    dQSize   = mbedtls_mpi_size(&ctx->DQ);
-    qInvSize = mbedtls_mpi_size(&ctx->QP);
-    ModulusSize = mbedtls_mpi_size(&ctx->N);
+    PSize    = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(P));
+    QSize    = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(Q));
+    dPSize   = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(DP));
+    dQSize   = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(DQ));
+    qInvSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(QP));
+    ModulusSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(N));
 
 
     /* checking the input sizes */
@@ -1318,7 +1312,7 @@ static CCError_t build_cc_priv_crt_key(
 
     /* verifying the first factor exponent is less then the first factor */
     CounterCmpResult =
-        CC_CommonCmpLsWordsUnsignedCounters(ctx->DP.p, mbedtls_mpi_size_in_words(&ctx->DP), ctx->P.p, mbedtls_mpi_size_in_words(&ctx->P));
+        CC_CommonCmpLsWordsUnsignedCounters(ctx->MBEDTLS_PRIVATE(DP).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(DP)), ctx->MBEDTLS_PRIVATE(P).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(P)));
 
     if (CounterCmpResult != CC_COMMON_CmpCounter2GreaterThenCounter1) {
         GOTO_END(CC_RSA_INVALID_CRT_FIRST_FACTOR_EXPONENT_VAL);
@@ -1326,7 +1320,7 @@ static CCError_t build_cc_priv_crt_key(
 
     /* verifying the second factor exponent is less then the second factor */
     CounterCmpResult =
-        CC_CommonCmpLsWordsUnsignedCounters(ctx->DQ.p, mbedtls_mpi_size_in_words(&ctx->DQ), ctx->Q.p, mbedtls_mpi_size_in_words(&ctx->Q));
+        CC_CommonCmpLsWordsUnsignedCounters(ctx->MBEDTLS_PRIVATE(DQ).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(DQ)), ctx->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(Q)));
 
     if (CounterCmpResult != CC_COMMON_CmpCounter2GreaterThenCounter1) {
         GOTO_END(CC_RSA_INVALID_CRT_SECOND_FACTOR_EXPONENT_VAL);
@@ -1334,7 +1328,7 @@ static CCError_t build_cc_priv_crt_key(
 
     /* verifying the CRT coefficient is less then the first factor */
     CounterCmpResult =
-        CC_CommonCmpLsWordsUnsignedCounters(ctx->QP.p, mbedtls_mpi_size_in_words(&ctx->QP), ctx->P.p, mbedtls_mpi_size_in_words(&ctx->P));
+        CC_CommonCmpLsWordsUnsignedCounters(ctx->MBEDTLS_PRIVATE(QP).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(QP)), ctx->MBEDTLS_PRIVATE(P).MBEDTLS_PRIVATE(p), mbedtls_mpi_size_in_words(&ctx->MBEDTLS_PRIVATE(P)));
 
     if (CounterCmpResult != CC_COMMON_CmpCounter2GreaterThenCounter1) {
         GOTO_END(CC_RSA_INVALID_CRT_COEFF_VAL);
@@ -1350,11 +1344,11 @@ static CCError_t build_cc_priv_crt_key(
     /* clear the private key db */
     CC_PalMemSetZero(PrivKey_ptr, sizeof(CCRsaPrivKey_t));
 
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.P, ctx->P.p, PSize);
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.Q, ctx->Q.p, QSize);
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.dP, ctx->DP.p, dPSize);
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.dQ, ctx->DQ.p, dQSize);
-    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.qInv, ctx->QP.p, qInvSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.P, ctx->MBEDTLS_PRIVATE(P).MBEDTLS_PRIVATE(p), PSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.Q, ctx->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(p), QSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.dP, ctx->MBEDTLS_PRIVATE(DP).MBEDTLS_PRIVATE(p), dPSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.dQ, ctx->MBEDTLS_PRIVATE(DQ).MBEDTLS_PRIVATE(p), dQSize);
+    CC_PalMemCopy(PrivKey_ptr->PriveKeyDb.Crt.qInv, ctx->MBEDTLS_PRIVATE(QP).MBEDTLS_PRIVATE(p), qInvSize);
 
     /* .................. initializing local variables ................... */
     /* ------------------------------------------------------------------- */
@@ -1407,7 +1401,7 @@ static CCError_t build_cc_priv_crt_key(
         GOTO_CLEANUP(CC_RSA_INTERNAL_ERROR);
     }
 #else
-    CC_PalMemCopy(PrivKey_ptr->n, ctx->N.p, ModulusSize);
+    CC_PalMemCopy(PrivKey_ptr->n, ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p), ModulusSize);
 #endif
 
     ModulusEffectiveSizeInBits =
@@ -1507,15 +1501,15 @@ static CCError_t build_cc_pubkey(
     /* ------------------------------------------------------------------------ */
 
     CHECK_AND_RETURN_ERR_UPON_FIPS_ERROR();
-    ModulusSize = mbedtls_mpi_size(&ctx->N);
-    ExponentSize = mbedtls_mpi_size(&ctx->E);
+    ModulusSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(N));
+    ExponentSize = mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(E));
 
     if ((ExponentSize > CC_RSA_MAX_VALID_KEY_SIZE_VALUE_IN_BYTES) ||
-            (ctx->E.n == 0))
+            (ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(n) == 0))
         return CC_RSA_INVALID_EXPONENT_SIZE;
 
     if ((ModulusSize  > CC_RSA_MAX_VALID_KEY_SIZE_VALUE_IN_BYTES) ||
-            (ctx->N.n == 0))
+            (ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(n) == 0))
     {
         return CC_RSA_INVALID_MODULUS_SIZE;
     }
@@ -1527,8 +1521,8 @@ static CCError_t build_cc_pubkey(
 
     /* clear the public key db */
     CC_PalMemSetZero( PubKey_ptr, sizeof(CCRsaPubKey_t) );
-    CC_PalMemCopy(PubKey_ptr->n, ctx->N.p, mbedtls_mpi_size(&ctx->N));
-    CC_PalMemCopy(PubKey_ptr->e, ctx->E.p, mbedtls_mpi_size(&ctx->E));
+    CC_PalMemCopy(PubKey_ptr->n, ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p), mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(N)));
+    CC_PalMemCopy(PubKey_ptr->e, ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p), mbedtls_mpi_size(&ctx->MBEDTLS_PRIVATE(E)));
 
     /* .................. initializing local variables ................... */
     /* ------------------------------------------------------------------- */
@@ -1626,16 +1620,16 @@ int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
     }
 
 #if defined(MBEDTLS_THREADING_C)
-    if ( (ret = mbedtls_mutex_lock(&ctx->mutex) ) != 0)
+    if ( (ret = mbedtls_mutex_lock(&ctx->MBEDTLS_PRIVATE(mutex)) ) != 0)
         return( ret );
 #endif
 
     /* ...... checking the validity of the exponent pointer ............... */
-    if (ctx->E.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(E).MBEDTLS_PRIVATE(p) == NULL)
         return CC_RSA_INVALID_EXPONENT_POINTER_ERROR;
 
     /* ...... checking the validity of the modulus pointer .............. */
-    if (ctx->N.p == NULL)
+    if (ctx->MBEDTLS_PRIVATE(N).MBEDTLS_PRIVATE(p) == NULL)
         return CC_RSA_INVALID_MODULUS_POINTER_ERROR;
 
     UserPubKey_ptr = (CCRsaUserPubKey_t *)mbedtls_calloc(1, sizeof(CCRsaUserPubKey_t));
@@ -1655,7 +1649,7 @@ int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
         goto End;
     }
 
-    Error = CC_RsaPrimEncrypt(UserPubKey_ptr, PrimeData_ptr, (unsigned char *)input, ctx->len, output);
+    Error = CC_RsaPrimEncrypt(UserPubKey_ptr, PrimeData_ptr, (unsigned char *)input, ctx->MBEDTLS_PRIVATE(len), output);
     if ( Error != CC_OK ) {
         goto End;
     }
@@ -1667,7 +1661,7 @@ End:
     mbedtls_free(UserPubKey_ptr);
 
 #if defined(MBEDTLS_THREADING_C)
-    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
+    if( mbedtls_mutex_unlock( &ctx->MBEDTLS_PRIVATE(mutex) ) != 0 )
         return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
 #endif
 
@@ -1712,7 +1706,7 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
     }
 
 #if defined(MBEDTLS_THREADING_C)
-    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
+    if( ( ret = mbedtls_mutex_lock( &ctx->MBEDTLS_PRIVATE(mutex) ) ) != 0 )
         return( ret );
 #endif
 
@@ -1736,13 +1730,13 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
         GOTO_CLEANUP(Error);
     }
 
-    Error = CC_RsaPrimDecrypt(UserPrivKey_ptr, PrimeData_ptr, (unsigned char *)input, ctx->len, output);
+    Error = CC_RsaPrimDecrypt(UserPrivKey_ptr, PrimeData_ptr, (unsigned char *)input, ctx->MBEDTLS_PRIVATE(len), output);
     if ( Error != CC_OK ) {
         GOTO_CLEANUP(Error);
     }
 Cleanup:
     if ( Error != CC_OK ) {
-        mbedtls_zeroize_internal(output, ctx->len);
+        mbedtls_zeroize_internal(output, ctx->MBEDTLS_PRIVATE(len));
     }
     mbedtls_zeroize_internal(UserPrivKey_ptr, sizeof(CCRsaUserPrivKey_t));
     mbedtls_zeroize_internal(PrimeData_ptr, sizeof(CCRsaPrimeData_t));
@@ -1750,7 +1744,7 @@ Cleanup:
     mbedtls_free(UserPrivKey_ptr);
 End:
 #if defined(MBEDTLS_THREADING_C)
-    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
+    if( mbedtls_mutex_unlock( &ctx->MBEDTLS_PRIVATE(mutex) ) != 0 )
         return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
 #endif
 
@@ -1765,7 +1759,6 @@ End:
 int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         const unsigned char *label, size_t label_len,
         size_t ilen,
         const unsigned char *input,
@@ -1788,11 +1781,6 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
     }
 
-    if( mode != MBEDTLS_RSA_PUBLIC )
-    {
-        GOTO_END( CC_RSA_ILLEGAL_PARAMS_ACCORDING_TO_PRIV_ERROR );
-    }
-
     if( input == NULL || output == NULL )
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -1814,13 +1802,13 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
         GOTO_END( Error );
     }
 
-    if (ctx->padding != MBEDTLS_RSA_PKCS_V21)
+    if (ctx->MBEDTLS_PRIVATE(padding) != MBEDTLS_RSA_PKCS_V21)
     {
         GOTO_END( CC_RSA_DATA_POINTER_INVALID_ERROR );
     }
 
 
-    if ( (Error = convert_mbedtls_md_type_to_cc_rsa_hash_opmode((mbedtls_md_type_t)ctx->hash_id,
+    if ( (Error = convert_mbedtls_md_type_to_cc_rsa_hash_opmode((mbedtls_md_type_t)ctx->MBEDTLS_PRIVATE(hash_id),
                                                0,     // HashMode - before
                                                &hashOpMode,
                                                &hashOutputSizeBytes)) != CC_OK )
@@ -1828,13 +1816,13 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
         GOTO_CLEANUP( Error );
     }
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
+    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id) );
     if( md_info == NULL )
     {
         GOTO_END( CC_RSA_HASH_ILLEGAL_OPERATION_MODE_ERROR );
     }
 
-    olen = ctx->len;
+    olen = ctx->MBEDTLS_PRIVATE(len);
     hlen = mbedtls_md_get_size( md_info );
 
     /* first comparison checks for overflow */
@@ -1879,7 +1867,7 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
 Cleanup:
     if ( Error != CC_OK )
     {
-        mbedtls_zeroize_internal(output, ctx->len);
+        mbedtls_zeroize_internal(output, ctx->MBEDTLS_PRIVATE(len));
     }
     mbedtls_zeroize_internal(UserPubKey_ptr, sizeof(CCRsaUserPubKey_t));
     mbedtls_zeroize_internal(PrimeData_ptr, sizeof(CCRsaPrimeData_t));
@@ -1897,7 +1885,6 @@ End:
 int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         size_t ilen,
         const unsigned char *input,
         unsigned char *output )
@@ -1914,11 +1901,6 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
     }
 
-    if( mode != MBEDTLS_RSA_PUBLIC )
-    {
-        GOTO_END( CC_RSA_ILLEGAL_PARAMS_ACCORDING_TO_PRIV_ERROR );
-    }
-
     if( input == NULL || output == NULL )
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -1938,13 +1920,13 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
         GOTO_END( Error );
     }
 
-    if ( ctx->padding != MBEDTLS_RSA_PKCS_V15 )
+    if ( ctx->MBEDTLS_PRIVATE(padding) != MBEDTLS_RSA_PKCS_V15 )
     {
         GOTO_END( CC_RSA_DATA_POINTER_INVALID_ERROR );
     }
 
     /* first comparison checks for overflow */
-    if( ilen + 11 < ilen || ctx->len < ilen + 11 )
+    if( ilen + 11 < ilen || ctx->MBEDTLS_PRIVATE(len) < ilen + 11 )
     {
         GOTO_END( CC_RSA_INVALID_MESSAGE_DATA_SIZE );
     }
@@ -1982,7 +1964,7 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
 Cleanup:
     if ( Error != CC_OK )
     {
-        mbedtls_zeroize_internal(output, ctx->len);
+        mbedtls_zeroize_internal(output, ctx->MBEDTLS_PRIVATE(len));
     }
     mbedtls_zeroize_internal(UserPubKey_ptr, sizeof(CCRsaUserPubKey_t));
     mbedtls_zeroize_internal(PrimeData_ptr, sizeof(CCRsaPrimeData_t));
@@ -2001,7 +1983,7 @@ End:
 int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode, size_t ilen,
+        size_t ilen,
         const unsigned char *input,
         unsigned char *output )
 {
@@ -2010,17 +1992,17 @@ int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
+            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, ilen,
                     input, output );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
+            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, NULL, 0,
                     ilen, input, output );
 #endif
 
@@ -2036,7 +2018,6 @@ int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
 int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         const unsigned char *label, size_t label_len,
         size_t *olen,
         const unsigned char *input,
@@ -2054,12 +2035,6 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     CC_UNUSED_PARAM(f_rng);
     CC_UNUSED_PARAM(p_rng);
 
-    // mbedtls supports decryption with public key, CC does not
-    if ( mode != MBEDTLS_RSA_PRIVATE )
-    {
-        GOTO_END( CC_RSA_INVALID_DECRYPRION_MODE_ERROR );
-    }
-
     if( input == NULL || output == NULL )
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2071,16 +2046,16 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
         GOTO_END( Error );
     }
 
-    if ( ctx->padding != MBEDTLS_RSA_PKCS_V21 )
+    if ( ctx->MBEDTLS_PRIVATE(padding) != MBEDTLS_RSA_PKCS_V21 )
         GOTO_END( CC_RSA_DATA_POINTER_INVALID_ERROR );
 
     // Sanity check on input length, not sure it's needed
-    if( ctx->len < 16 || ctx->len > MBEDTLS_MPI_MAX_SIZE )
+    if( ctx->MBEDTLS_PRIVATE(len) < 16 || ctx->MBEDTLS_PRIVATE(len) > MBEDTLS_MPI_MAX_SIZE )
     {
         GOTO_END( CC_RSA_INVALID_MESSAGE_DATA_SIZE );
     }
 
-    if ( ( Error = convert_mbedtls_md_type_to_cc_rsa_hash_opmode((mbedtls_md_type_t)ctx->hash_id,
+    if ( ( Error = convert_mbedtls_md_type_to_cc_rsa_hash_opmode((mbedtls_md_type_t)ctx->MBEDTLS_PRIVATE(hash_id),
                                                0,    // HashMode - before
                                                &hashOpMode,
                                                &hashOutputSizeBytes) ) != CC_OK )
@@ -2089,7 +2064,7 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     }
 
     // checking for integer underflow
-    if( 2 * hashOutputSizeBytes + 2 > ctx->len )
+    if( 2 * hashOutputSizeBytes + 2 > ctx->MBEDTLS_PRIVATE(len) )
     {
         GOTO_END( CC_RSA_INVALID_MESSAGE_DATA_SIZE );
     }
@@ -2126,7 +2101,7 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
                               label_len,
                               CC_PKCS1_MGF1,
                               (unsigned char *)input, // Need to remove the const-ness
-                              ctx->len,
+                              ctx->MBEDTLS_PRIVATE(len),
                               output,
                               olen);
     if ( Error != CC_OK)
@@ -2142,7 +2117,7 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
 Cleanup:
     if ( Error != CC_OK )
     {
-        mbedtls_zeroize_internal(output, ctx->len);
+        mbedtls_zeroize_internal(output, ctx->MBEDTLS_PRIVATE(len));
     }
     mbedtls_zeroize_internal(UserPrivKey_ptr, sizeof(CCRsaUserPrivKey_t));
     mbedtls_zeroize_internal(PrimeData_ptr, sizeof(CCRsaPrimeData_t));
@@ -2160,7 +2135,6 @@ End:
 int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         size_t *olen,
         const unsigned char *input,
         unsigned char *output,
@@ -2180,12 +2154,6 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
     CC_UNUSED_PARAM(f_rng);
     CC_UNUSED_PARAM(p_rng);
 
-    // mbedtls supports decryption with public key, CC does not
-    if (mode != MBEDTLS_RSA_PRIVATE)
-    {
-        GOTO_END( CC_RSA_INVALID_DECRYPRION_MODE_ERROR );
-    }
-
     if( input == NULL || output == NULL )
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2198,13 +2166,13 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
         GOTO_END( Error );
     }
 
-    if( ctx->padding != MBEDTLS_RSA_PKCS_V15 )
+    if( ctx->MBEDTLS_PRIVATE(padding) != MBEDTLS_RSA_PKCS_V15 )
     {
         GOTO_END( CC_RSA_DATA_POINTER_INVALID_ERROR );
     }
 
     // Sanity check on input length, not sure it's needed
-    if( ctx->len < 16 || ctx->len > MBEDTLS_MPI_MAX_SIZE )
+    if( ctx->MBEDTLS_PRIVATE(len) < 16 || ctx->MBEDTLS_PRIVATE(len) > MBEDTLS_MPI_MAX_SIZE )
     {
         GOTO_END( CC_RSA_INVALID_MESSAGE_DATA_SIZE );
     }
@@ -2237,7 +2205,7 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
     Error = CC_RsaPkcs1V15Decrypt(UserPrivKey_ptr,
                                   PrimeData_ptr,
                                   (unsigned char *)input, // Need to remove the const-ness
-                                  ctx->len,
+                                  ctx->MBEDTLS_PRIVATE(len),
                                   output,
                                   olen);
 
@@ -2254,7 +2222,7 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
 Cleanup:
     if ( Error != CC_OK )
     {
-        mbedtls_zeroize_internal(output, ctx->len);
+        mbedtls_zeroize_internal(output, ctx->MBEDTLS_PRIVATE(len));
     }
     mbedtls_zeroize_internal(UserPrivKey_ptr, sizeof(CCRsaUserPrivKey_t));
     mbedtls_zeroize_internal(PrimeData_ptr, sizeof(CCRsaPrimeData_t));
@@ -2272,7 +2240,7 @@ End:
 int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode, size_t *olen,
+        size_t *olen,
         const unsigned char *input,
         unsigned char *output,
         size_t output_max_len)
@@ -2282,17 +2250,17 @@ int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
+            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, olen,
                     input, output, output_max_len );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
+            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, NULL, 0,
                     olen, input, output,
                     output_max_len );
 #endif
@@ -2309,7 +2277,6 @@ int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
 int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2329,10 +2296,6 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
     if (ctx == NULL){
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
     }
-    if (mode != MBEDTLS_RSA_PRIVATE) /* In cryptocell only private key operations are allowed with sign */
-    {
-        GOTO_END( CC_RSA_WRONG_PRIVATE_KEY_TYPE );
-    }
     if ( NULL == sig || NULL == hash )
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2346,7 +2309,7 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         encoding. md_alg in the function call is the type of hash
         that is encoded. According to RFC 3447 it is advised to keep
         both hashes the same. */
-    if ( md_alg != ( mbedtls_md_type_t ) ctx->hash_id )
+    if ( md_alg != ( mbedtls_md_type_t ) ctx->MBEDTLS_PRIVATE(hash_id) )
     {
         GOTO_END( CC_RSA_HASH_ILLEGAL_OPERATION_MODE_ERROR );
     }
@@ -2389,7 +2352,7 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         GOTO_CLEANUP( Error );
     }
 
-    sig_size = mbedtls_mpi_size( ( const mbedtls_mpi *)&( ctx->N ) );
+    sig_size = mbedtls_mpi_size( ( const mbedtls_mpi *)&( ctx->MBEDTLS_PRIVATE(N) ) );
 
     Error = CC_RsaPssSign( &rndContext,
         UserContext_ptr,
@@ -2421,7 +2384,6 @@ End:
 int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2441,10 +2403,6 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
     if (ctx == NULL){
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
     }
-    if (mode != MBEDTLS_RSA_PRIVATE) /* In cryptocell only private key operations are allowed with sign */
-    {
-        GOTO_END( CC_RSA_WRONG_PRIVATE_KEY_TYPE );
-    }
     if (NULL == sig || NULL == hash)
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2493,7 +2451,7 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
         GOTO_CLEANUP(Error);
     }
 
-    sig_size = mbedtls_mpi_size( (const mbedtls_mpi *)&(ctx->N) );
+    sig_size = mbedtls_mpi_size( (const mbedtls_mpi *)&(ctx->MBEDTLS_PRIVATE(N)) );
     Error = CC_RsaPkcs1V15Sign(&rndContext,
         UserContext_ptr,
         UserPrivKey_ptr,
@@ -2518,7 +2476,6 @@ End:
 int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
         int (*f_rng)(void *, unsigned char *, size_t),
         void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2529,17 +2486,17 @@ int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, md_alg,
                     hashlen, hash, sig );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, md_alg,
                     hashlen, hash, sig );
 #endif
 
@@ -2553,9 +2510,6 @@ int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
  * Implementation of the PKCS#1 v2.1 RSASSA-PSS-VERIFY function
  */
 int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
-                               int (*f_rng)(void *, unsigned char *, size_t),
-                               void *p_rng,
-                               int mode,
                                mbedtls_md_type_t md_alg,
                                unsigned int hashlen,
                                const unsigned char *hash,
@@ -2570,18 +2524,11 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     CCError_t Error = CC_OK;
     mbedtls_md_type_t mdType;
 
-    CC_UNUSED_PARAM(f_rng);
-    CC_UNUSED_PARAM(p_rng);
-
     /* Check input parameters */
     if (ctx == NULL){
         GOTO_END( CC_RSA_WRONG_PRIVATE_KEY_TYPE );
     }
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 ) /* In cryptocell only public key operations are allowed with verify */
-    {
-        GOTO_END( CC_RSA_WRONG_PRIVATE_KEY_TYPE );
-    }
     if (NULL == sig || NULL == hash)
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2639,9 +2586,6 @@ End:
  * Simplified PKCS#1 v2.1 RSASSA-PSS-VERIFY function
  */
 int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
-        int (*f_rng)(void *, unsigned char *, size_t),
-        void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2652,10 +2596,10 @@ int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    if (( ctx->hash_id != MBEDTLS_MD_NONE ) && ((mbedtls_md_type_t) ctx->hash_id != md_alg)){
+    if (( ctx->MBEDTLS_PRIVATE(hash_id) != MBEDTLS_MD_NONE ) && ((mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id) != md_alg)){
             return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
     }
-    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, f_rng, p_rng, mode,
+    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx,
                 md_alg, hashlen, hash,
                 md_alg, MBEDTLS_RSA_SALT_LEN_ANY,
                 sig ) );
@@ -2665,9 +2609,6 @@ int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
 
 #if defined(MBEDTLS_PKCS1_V15)
 int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
-        int (*f_rng)(void *, unsigned char *, size_t),
-        void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2679,8 +2620,6 @@ int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
     size_t                       hashOutputSizeBytes = 0;
     CCError_t                    Error = CC_OK;
 
-    CC_UNUSED_PARAM(f_rng);
-    CC_UNUSED_PARAM(p_rng);
     /* Check input parameters */
     if (ctx == NULL){
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2702,10 +2641,6 @@ int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
     {
         hashlen = hashOutputSizeBytes;
     }
-    if (mode != MBEDTLS_RSA_PUBLIC) /* In cryptocell only public key operations are allowed with verify */
-    {
-        GOTO_END( CC_RSA_WRONG_PRIVATE_KEY_TYPE );
-    }
     if (NULL == sig || NULL == hash)
     {
         GOTO_END( CC_RSA_INVALID_PTR_ERROR );
@@ -2748,9 +2683,6 @@ End:
  * Do an RSA operation and check the message digest
  */
 int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx,
-        int (*f_rng)(void *, unsigned char *, size_t),
-        void *p_rng,
-        int mode,
         mbedtls_md_type_t md_alg,
         unsigned int hashlen,
         const unsigned char *hash,
@@ -2761,17 +2693,17 @@ int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, md_alg,
                     hashlen, hash, sig );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pss_verify( ctx, md_alg,
                     hashlen, hash, sig );
 #endif
 
@@ -2791,32 +2723,32 @@ int mbedtls_rsa_copy( mbedtls_rsa_context *dst, const mbedtls_rsa_context *src )
         return MBEDTLS_ERR_RSA_BAD_INPUT_DATA;
     }
 
-    dst->ver = src->ver;
-    dst->len = src->len;
+    dst->MBEDTLS_PRIVATE(ver) = src->MBEDTLS_PRIVATE(ver);
+    dst->MBEDTLS_PRIVATE(len) = src->MBEDTLS_PRIVATE(len);
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->N, &src->N ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->E, &src->E ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(N), &src->MBEDTLS_PRIVATE(N) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(E), &src->MBEDTLS_PRIVATE(E) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->D, &src->D ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->P, &src->P ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Q, &src->Q ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DP, &src->DP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DQ, &src->DQ ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->QP, &src->QP ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(D), &src->MBEDTLS_PRIVATE(D) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(P), &src->MBEDTLS_PRIVATE(P) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Q), &src->MBEDTLS_PRIVATE(Q) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(DP), &src->MBEDTLS_PRIVATE(DP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(DQ), &src->MBEDTLS_PRIVATE(DQ) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(QP), &src->MBEDTLS_PRIVATE(QP) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RN, &src->RN ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RP, &src->RP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RQ, &src->RQ ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RN), &src->MBEDTLS_PRIVATE(RN) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RP), &src->MBEDTLS_PRIVATE(RP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RQ), &src->MBEDTLS_PRIVATE(RQ) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->NP, &src->NP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->BPP, &src->BPP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->BQP, &src->BQP ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(NP), &src->MBEDTLS_PRIVATE(NP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(BPP), &src->MBEDTLS_PRIVATE(BPP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(BQP), &src->MBEDTLS_PRIVATE(BQP) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vi, &src->Vi ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vf, &src->Vf ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Vi), &src->MBEDTLS_PRIVATE(Vi) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Vf), &src->MBEDTLS_PRIVATE(Vf) ) );
 
-    dst->padding = src->padding;
-    dst->hash_id = src->hash_id;
+    dst->MBEDTLS_PRIVATE(padding) = src->MBEDTLS_PRIVATE(padding);
+    dst->MBEDTLS_PRIVATE(hash_id) = src->MBEDTLS_PRIVATE(hash_id);
 
 cleanup:
     if( ret != 0 )
@@ -2831,15 +2763,15 @@ cleanup:
 void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
 {
     if (ctx != NULL) {
-        mbedtls_mpi_free( &ctx->BQP ); mbedtls_mpi_free( &ctx->BPP ); mbedtls_mpi_free( &ctx->NP );
-        mbedtls_mpi_free( &ctx->Vi ); mbedtls_mpi_free( &ctx->Vf );
-        mbedtls_mpi_free( &ctx->RQ ); mbedtls_mpi_free( &ctx->RP ); mbedtls_mpi_free( &ctx->RN );
-        mbedtls_mpi_free( &ctx->QP ); mbedtls_mpi_free( &ctx->DQ ); mbedtls_mpi_free( &ctx->DP );
-        mbedtls_mpi_free( &ctx->Q  ); mbedtls_mpi_free( &ctx->P  ); mbedtls_mpi_free( &ctx->D );
-        mbedtls_mpi_free( &ctx->E  ); mbedtls_mpi_free( &ctx->N  );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(BQP) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(BPP) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(NP) );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Vi) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Vf) );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RQ) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RP) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RN) );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(QP) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(DQ) ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(DP) );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Q)  ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(P)  ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(D) );
+        mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(E)  ); mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(N)  );
 
 #if defined(MBEDTLS_THREADING_C)
-        mbedtls_mutex_free( &ctx->mutex );
+        mbedtls_mutex_free( &ctx->MBEDTLS_PRIVATE(mutex) );
 #endif
     }
 }
@@ -2856,17 +2788,17 @@ int mbedtls_rsa_import( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
 
-    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
-        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
-        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
-        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
-        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
+    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(N), N ) ) != 0 ) ||
+        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(P), P ) ) != 0 ) ||
+        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(Q), Q ) ) != 0 ) ||
+        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(D), D ) ) != 0 ) ||
+        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(E), E ) ) != 0 ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
 
     if( N != NULL )
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
 
     return( 0 );
 }
@@ -2886,21 +2818,21 @@ int mbedtls_rsa_import_raw( mbedtls_rsa_context *ctx,
 
     if( N != NULL )
     {
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->N, N, N_len ) );
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(N), N, N_len ) );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
     }
 
     if( P != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->P, P, P_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(P), P, P_len ) );
 
     if( Q != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->Q, Q, Q_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(Q), Q, Q_len ) );
 
     if( D != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->D, D, D_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(D), D, D_len ) );
 
     if( E != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->E, E, E_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(E), E, E_len ) );
 
 cleanup:
 
@@ -2939,8 +2871,8 @@ static int mbedtls_alt_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *
             return MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
     }
 
-    tempBufSize = P->n;
-    sizeBitsP = P->n*sizeof(uint32_t)*8;
+    tempBufSize = P->MBEDTLS_PRIVATE(n);
+    sizeBitsP = P->MBEDTLS_PRIVATE(n)*sizeof(uint32_t)*8;
 
     ret = PkaInitAndMutexLock(2*sizeBitsP, &regCount);
     if (ret != 0)
@@ -2954,9 +2886,9 @@ static int mbedtls_alt_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *
     }
 
     PKA_SET_REG_SIZE(sizeBitsP, PLEN_ID);
-    PkaCopyDataIntoPkaReg(rP, REG_LEN_ID, P->p, P->n);
-    PkaCopyDataIntoPkaReg(rQ, REG_LEN_ID, Q->p, Q->n);
-    PkaCopyDataIntoPkaReg(rD, REG_LEN_ID, D->p, D->n);
+    PkaCopyDataIntoPkaReg(rP, REG_LEN_ID, P->MBEDTLS_PRIVATE(p), P->MBEDTLS_PRIVATE(n));
+    PkaCopyDataIntoPkaReg(rQ, REG_LEN_ID, Q->MBEDTLS_PRIVATE(p), Q->MBEDTLS_PRIVATE(n));
+    PkaCopyDataIntoPkaReg(rD, REG_LEN_ID, D->MBEDTLS_PRIVATE(p), D->MBEDTLS_PRIVATE(n));
 
     ret = PkaCalcNpIntoPkaReg(PLEN_ID, sizeBitsP, rP/*regN*/, regNp,  rT1, rT2 );
     if (ret != 0)
@@ -2979,14 +2911,14 @@ static int mbedtls_alt_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *
     PKA_ADD_IM(MOD_LEN_ID, rP, rP, 1);
     PKA_ADD_IM(MOD_LEN_ID, rQ, rQ, 1);
     PKA_MOD_INV(PLEN_ID, rT3/*res*/, rQ);  // rT3 = Q^-1 mod P
-    PkaCopyDataFromPkaReg(pTempBuf, P->n, rT1);
-    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( DP, pTempBuf, P->n ));
+    PkaCopyDataFromPkaReg(pTempBuf, P->MBEDTLS_PRIVATE(n), rT1);
+    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( DP, pTempBuf, P->MBEDTLS_PRIVATE(n) ));
 
-    PkaCopyDataFromPkaReg(pTempBuf, P->n, rT2);
-    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( DQ, pTempBuf, P->n ));
+    PkaCopyDataFromPkaReg(pTempBuf, P->MBEDTLS_PRIVATE(n), rT2);
+    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( DQ, pTempBuf, P->MBEDTLS_PRIVATE(n) ));
 
-    PkaCopyDataFromPkaReg (pTempBuf, P->n, rT3);
-    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( QP, pTempBuf, P->n ));
+    PkaCopyDataFromPkaReg (pTempBuf, P->MBEDTLS_PRIVATE(n), rT3);
+    MBEDTLS_MPI_CHK(mbedtls_rsa_uint32_buf_to_mpi( QP, pTempBuf, P->MBEDTLS_PRIVATE(n) ));
 
 cleanup:
     PkaFinishAndMutexUnlock(regCount);
@@ -3027,14 +2959,14 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
     }
 
 
-    have_N = mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0;
-    have_P = mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0;
-    have_Q = mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0;
-    have_D = mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0;
-    have_E = mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
-    have_DP = mbedtls_mpi_cmp_int( &ctx->DP, 0 ) != 0;
-    have_DQ = mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) != 0;
-    have_QP = mbedtls_mpi_cmp_int( &ctx->QP, 0 ) != 0;
+    have_N = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0;
+    have_P = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0;
+    have_Q = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0;
+    have_D = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0;
+    have_E = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
+    have_DP = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DP), 0 ) != 0;
+    have_DQ = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DQ), 0 ) != 0;
+    have_QP = mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(QP), 0 ) != 0;
 
     /*
     * 1. The user may insert N, D, E and the complete function will not derive the P and Q from it.
@@ -3069,13 +3001,13 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
     //if N is requested to be calculated from P and Q, it will be done by sw
     if( !have_N && have_P && have_Q )
     {
-        if( ( ret = mbedtls_mpi_mul_mpi( &ctx->N, &ctx->P,
-                                         &ctx->Q ) ) != 0 )
+        if( ( ret = mbedtls_mpi_mul_mpi( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(P),
+                                         &ctx->MBEDTLS_PRIVATE(Q) ) ) != 0 )
         {
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
         }
 
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
     }
 
     /*
@@ -3087,8 +3019,8 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 
     if (( is_priv ) && (crt_missing))
     {
-        ret = mbedtls_alt_rsa_deduce_crt( &ctx->P,  &ctx->Q,  &ctx->D,
-                                      &ctx->DP, &ctx->DQ, &ctx->QP );
+        ret = mbedtls_alt_rsa_deduce_crt( &ctx->MBEDTLS_PRIVATE(P),  &ctx->MBEDTLS_PRIVATE(Q),  &ctx->MBEDTLS_PRIVATE(D),
+                                      &ctx->MBEDTLS_PRIVATE(DP), &ctx->MBEDTLS_PRIVATE(DQ), &ctx->MBEDTLS_PRIVATE(QP) );
         if( ret != 0 )
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
@@ -3118,11 +3050,11 @@ int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
     if( !is_priv )
     {
@@ -3134,19 +3066,19 @@ int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
     }
 
     if( N != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->N, N, N_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(N), N, N_len ) );
 
     if( P != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->P, P, P_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(P), P, P_len ) );
 
     if( Q != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->Q, Q, Q_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(Q), Q, Q_len ) );
 
     if( D != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->D, D, D_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(D), D, D_len ) );
 
     if( E != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->E, E, E_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(E), E, E_len ) );
 
 cleanup:
 
@@ -3167,11 +3099,11 @@ int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
    if( !is_priv )
     {
@@ -3183,11 +3115,11 @@ int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,
     }
 
     /* Export all requested core parameters. */
-    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->N ) ) != 0 ) ||
-        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->P ) ) != 0 ) ||
-        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->Q ) ) != 0 ) ||
-        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->D ) ) != 0 ) ||
-        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->E ) ) != 0 ) )
+    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->MBEDTLS_PRIVATE(N) ) ) != 0 ) ||
+        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->MBEDTLS_PRIVATE(P) ) ) != 0 ) ||
+        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->MBEDTLS_PRIVATE(Q) ) ) != 0 ) ||
+        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->MBEDTLS_PRIVATE(D) ) ) != 0 ) ||
+        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->MBEDTLS_PRIVATE(E) ) ) != 0 ) )
     {
         return( ret );
     }
@@ -3208,25 +3140,25 @@ int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
     if( !is_priv )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
     /* Export all requested blinding parameters. */
-    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->DP ) ) != 0 ) ||
-        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->DQ ) ) != 0 ) ||
-        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->QP ) ) != 0 ) )
+    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->MBEDTLS_PRIVATE(DP) ) ) != 0 ) ||
+        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->MBEDTLS_PRIVATE(DQ) ) ) != 0 ) ||
+        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->MBEDTLS_PRIVATE(QP) ) ) != 0 ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
 #else
-    if( ( ret = mbedtls_alt_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
+    if( ( ret = mbedtls_alt_rsa_deduce_crt( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(D),
                                         DP, DQ, QP ) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
@@ -3246,7 +3178,7 @@ size_t mbedtls_rsa_get_len( const mbedtls_rsa_context *ctx )
         return 0;
     }
 
-    return( ctx->len );
+    return( ctx->MBEDTLS_PRIVATE(len) );
 }
 
 /**************************************************************************************/
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_alt.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_alt.c
index 19c43c3534e8b9dfb78ba9d3a77aa9e6b58999a1..92e5270a0df7129a7ffd5bf0c3329a9402443c22 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_alt.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_alt.c
@@ -1,7 +1,7 @@
 /*
  *  Elliptic curves over GF(p): generic functions
  *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  Copyright (C) 2006-2021, ARM Limited, All Rights Reserved
  *  Copyright (C) 2019, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -78,6 +78,8 @@
 #if defined(MBEDTLS_ECP_INTERNAL_ALT)
 #endif
 
+#include "mbedtls/error.h"
+
 #if defined(MBEDTLS_ECP_C)
 
 #include "mbedtls/ecp.h"
@@ -104,7 +106,7 @@
 #define mbedtls_free       free
 #endif
 
-#include "mbedtls/ecp_internal.h"
+#include "ecp_internal_alt.h"
 #include "stm32l5xx_hal.h"
 
 #define ST_ECP_TIMEOUT     (5000U)
@@ -444,10 +446,10 @@ const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list( void )
         const mbedtls_ecp_curve_info *curve_info;
 
         for( curve_info = mbedtls_ecp_curve_list();
-             curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
+             curve_info->MBEDTLS_PRIVATE(grp_id) != MBEDTLS_ECP_DP_NONE;
              curve_info++ )
         {
-            ecp_supported_grp_id[i++] = curve_info->grp_id;
+            ecp_supported_grp_id[i++] = curve_info->MBEDTLS_PRIVATE(grp_id);
         }
         ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;
 
@@ -465,10 +467,10 @@ const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id( mbedtls_ecp_gr
     const mbedtls_ecp_curve_info *curve_info;
 
     for( curve_info = mbedtls_ecp_curve_list();
-         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
+         curve_info->MBEDTLS_PRIVATE(grp_id) != MBEDTLS_ECP_DP_NONE;
          curve_info++ )
     {
-        if( curve_info->grp_id == grp_id )
+        if( curve_info->MBEDTLS_PRIVATE(grp_id) == grp_id )
             return( curve_info );
     }
 
@@ -483,10 +485,10 @@ const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id( uint16_t tls_i
     const mbedtls_ecp_curve_info *curve_info;
 
     for( curve_info = mbedtls_ecp_curve_list();
-         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
+         curve_info->MBEDTLS_PRIVATE(grp_id) != MBEDTLS_ECP_DP_NONE;
          curve_info++ )
     {
-        if( curve_info->tls_id == tls_id )
+        if( curve_info->MBEDTLS_PRIVATE(tls_id) == tls_id )
             return( curve_info );
     }
 
@@ -504,10 +506,10 @@ const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name
         return( NULL );
 
     for( curve_info = mbedtls_ecp_curve_list();
-         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
+         curve_info->MBEDTLS_PRIVATE(grp_id) != MBEDTLS_ECP_DP_NONE;
          curve_info++ )
     {
-        if( strcmp( curve_info->name, name ) == 0 )
+        if( strcmp( curve_info->MBEDTLS_PRIVATE(name), name ) == 0 )
             return( curve_info );
     }
 
@@ -519,10 +521,10 @@ const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name
  */
 mbedtls_ecp_curve_type mbedtls_ecp_get_type( const mbedtls_ecp_group *grp )
 {
-    if( grp->G.X.p == NULL )
+    if( grp->G.MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p) == NULL )
         return( MBEDTLS_ECP_TYPE_NONE );
 
-    if( grp->G.Y.p == NULL )
+    if( grp->G.MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p) == NULL )
         return( MBEDTLS_ECP_TYPE_MONTGOMERY );
     else
         return( MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS );
@@ -535,9 +537,9 @@ void mbedtls_ecp_point_init( mbedtls_ecp_point *pt )
 {
     ECP_VALIDATE( pt != NULL );
 
-    mbedtls_mpi_init( &pt->X );
-    mbedtls_mpi_init( &pt->Y );
-    mbedtls_mpi_init( &pt->Z );
+    mbedtls_mpi_init( &pt->MBEDTLS_PRIVATE(X) );
+    mbedtls_mpi_init( &pt->MBEDTLS_PRIVATE(Y) );
+    mbedtls_mpi_init( &pt->MBEDTLS_PRIVATE(Z) );
 }
 
 /*
@@ -584,9 +586,9 @@ void mbedtls_ecp_keypair_init( mbedtls_ecp_keypair *key )
 {
     ECP_VALIDATE( key != NULL );
 
-    mbedtls_ecp_group_init( &key->grp );
-    mbedtls_mpi_init( &key->d );
-    mbedtls_ecp_point_init( &key->Q );
+    mbedtls_ecp_group_init( &key->MBEDTLS_PRIVATE(grp) );
+    mbedtls_mpi_init( &key->MBEDTLS_PRIVATE(d) );
+    mbedtls_ecp_point_init( &key->MBEDTLS_PRIVATE(Q) );
 }
 
 /*
@@ -597,9 +599,9 @@ void mbedtls_ecp_point_free( mbedtls_ecp_point *pt )
     if( pt == NULL )
         return;
 
-    mbedtls_mpi_free( &( pt->X ) );
-    mbedtls_mpi_free( &( pt->Y ) );
-    mbedtls_mpi_free( &( pt->Z ) );
+    mbedtls_mpi_free( &( pt->MBEDTLS_PRIVATE(X) ) );
+    mbedtls_mpi_free( &( pt->MBEDTLS_PRIVATE(Y) ) );
+    mbedtls_mpi_free( &( pt->MBEDTLS_PRIVATE(Z) ) );
 }
 
 /*
@@ -673,9 +675,9 @@ void mbedtls_ecp_keypair_free( mbedtls_ecp_keypair *key )
     if( key == NULL )
         return;
 
-    mbedtls_ecp_group_free( &key->grp );
-    mbedtls_mpi_free( &key->d );
-    mbedtls_ecp_point_free( &key->Q );
+    mbedtls_ecp_group_free( &key->MBEDTLS_PRIVATE(grp) );
+    mbedtls_mpi_free( &key->MBEDTLS_PRIVATE(d) );
+    mbedtls_ecp_point_free( &key->MBEDTLS_PRIVATE(Q) );
 }
 
 /*
@@ -687,9 +689,12 @@ int mbedtls_ecp_copy( mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )
     ECP_VALIDATE_RET( P != NULL );
     ECP_VALIDATE_RET( Q != NULL );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->X, &Q->X ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Y, &Q->Y ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->MBEDTLS_PRIVATE(X),
+                                       &Q->MBEDTLS_PRIVATE(X) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->MBEDTLS_PRIVATE(Y),
+                                       &Q->MBEDTLS_PRIVATE(Y) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->MBEDTLS_PRIVATE(Z),
+                                       &Q->MBEDTLS_PRIVATE(Z) ) );
 
 cleanup:
     return( ret );
@@ -714,9 +719,9 @@ int mbedtls_ecp_set_zero( mbedtls_ecp_point *pt )
     int ret;
     ECP_VALIDATE_RET( pt != NULL );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Y , 1 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(X) , 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(Y) , 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(Z) , 0 ) );
 
 cleanup:
     return( ret );
@@ -729,7 +734,7 @@ int mbedtls_ecp_is_zero( mbedtls_ecp_point *pt )
 {
     ECP_VALIDATE_RET( pt != NULL );
 
-    return( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 );
+    return( mbedtls_mpi_cmp_int( &pt->MBEDTLS_PRIVATE(Z), 0 ) == 0 );
 }
 
 /*
@@ -741,9 +746,9 @@ int mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,
     ECP_VALIDATE_RET( P != NULL );
     ECP_VALIDATE_RET( Q != NULL );
 
-    if( mbedtls_mpi_cmp_mpi( &P->X, &Q->X ) == 0 &&
-        mbedtls_mpi_cmp_mpi( &P->Y, &Q->Y ) == 0 &&
-        mbedtls_mpi_cmp_mpi( &P->Z, &Q->Z ) == 0 )
+    if( mbedtls_mpi_cmp_mpi( &P->MBEDTLS_PRIVATE(X), &Q->MBEDTLS_PRIVATE(X) ) == 0 &&
+        mbedtls_mpi_cmp_mpi( &P->MBEDTLS_PRIVATE(Y), &Q->MBEDTLS_PRIVATE(Y) ) == 0 &&
+        mbedtls_mpi_cmp_mpi( &P->MBEDTLS_PRIVATE(Z), &Q->MBEDTLS_PRIVATE(Z) ) == 0 )
     {
         return( 0 );
     }
@@ -762,9 +767,9 @@ int mbedtls_ecp_point_read_string( mbedtls_ecp_point *P, int radix,
     ECP_VALIDATE_RET( x != NULL );
     ECP_VALIDATE_RET( y != NULL );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->X, radix, x ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->Y, radix, y ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->MBEDTLS_PRIVATE(X), radix, x ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->MBEDTLS_PRIVATE(Y), radix, y ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->MBEDTLS_PRIVATE(Z), 1 ) );
 
 cleanup:
     return( ret );
@@ -796,7 +801,8 @@ int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,
         if( buflen < *olen )
             return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
 
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &P->X, buf, plen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &P->MBEDTLS_PRIVATE(X),
+                                                      buf, plen ) );
     }
 #endif
 #if defined(ECP_SHORTWEIERSTRASS)
@@ -805,7 +811,7 @@ int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,
         /*
          * Common case: P == 0
          */
-        if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
+        if( mbedtls_mpi_cmp_int( &P->MBEDTLS_PRIVATE(Z), 0 ) == 0 )
         {
             if( buflen < 1 )
                 return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
@@ -824,8 +830,8 @@ int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,
                 return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
 
             buf[0] = 0x04;
-            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->Y, buf + 1 + plen, plen ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->MBEDTLS_PRIVATE(X), buf + 1, plen ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->MBEDTLS_PRIVATE(Y), buf + 1 + plen, plen ) );
         }
         else if( format == MBEDTLS_ECP_PF_COMPRESSED )
         {
@@ -834,8 +840,9 @@ int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,
             if( buflen < *olen )
                 return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
 
-            buf[0] = 0x02 + mbedtls_mpi_get_bit( &P->Y, 0 );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
+            buf[0] = 0x02 + mbedtls_mpi_get_bit( &P->MBEDTLS_PRIVATE(Y), 0 );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->MBEDTLS_PRIVATE(X),
+                                                       buf + 1, plen ) );
         }
     }
 #endif
@@ -868,14 +875,16 @@ int mbedtls_ecp_point_read_binary( const mbedtls_ecp_group *grp,
         if( plen != ilen )
             return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &pt->X, buf, plen ) );
-        mbedtls_mpi_free( &pt->Y );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &pt->MBEDTLS_PRIVATE(X),
+                                                     buf, plen ) );
+        mbedtls_mpi_free( &pt->MBEDTLS_PRIVATE(Y) );
 
         if( grp->id == MBEDTLS_ECP_DP_CURVE25519 )
             /* Set most significant bit to 0 as prescribed in RFC7748 5 */
-            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &pt->X, plen * 8 - 1, 0 ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &pt->MBEDTLS_PRIVATE(X),
+                                                  plen * 8 - 1, 0 ) );
 
-        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(Z), 1 ) );
     }
 #endif
 #if defined(ECP_SHORTWEIERSTRASS)
@@ -895,10 +904,11 @@ int mbedtls_ecp_point_read_binary( const mbedtls_ecp_group *grp,
         if( ilen != 2 * plen + 1 )
             return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->X, buf + 1, plen ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->Y,
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->MBEDTLS_PRIVATE(X),
+                                                  buf + 1, plen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->MBEDTLS_PRIVATE(Y),
                                                   buf + 1 + plen, plen ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(Z), 1 ) );
     }
 #endif
 
@@ -1032,7 +1042,7 @@ int mbedtls_ecp_tls_read_group_id( mbedtls_ecp_group_id *grp,
     if( ( curve_info = mbedtls_ecp_curve_info_from_tls_id( tls_id ) ) == NULL )
         return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
 
-    *grp = curve_info->grp_id;
+    *grp = curve_info->MBEDTLS_PRIVATE(grp_id);
 
     return( 0 );
 }
@@ -1066,8 +1076,8 @@ int mbedtls_ecp_tls_write_group( const mbedtls_ecp_group *grp, size_t *olen,
     /*
      * Next two bytes are the namedcurve value
      */
-    buf[0] = curve_info->tls_id >> 8;
-    buf[1] = curve_info->tls_id & 0xFF;
+    buf[0] = curve_info->MBEDTLS_PRIVATE(tls_id) >> 8;
+    buf[1] = curve_info->MBEDTLS_PRIVATE(tls_id) & 0xFF;
 
     return( 0 );
 }
@@ -1086,7 +1096,7 @@ static int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )
         return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
 
     /* N->s < 0 is a much faster test, which fails only if N is 0 */
-    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
+    if( ( N->MBEDTLS_PRIVATE(s) < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
         mbedtls_mpi_bitlen( N ) > 2 * grp->pbits )
     {
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
@@ -1095,7 +1105,7 @@ static int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )
     MBEDTLS_MPI_CHK( grp->modp( N ) );
 
     /* N->s < 0 is a much faster test, which fails only if N is 0 */
-    while( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 )
+    while( N->MBEDTLS_PRIVATE(s) < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 )
         MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &grp->P ) );
 
     while( mbedtls_mpi_cmp_mpi( N, &grp->P ) >= 0 )
@@ -1137,7 +1147,7 @@ cleanup:
  * N->s < 0 is a very fast test, which fails only if N is 0
  */
 #define MOD_SUB( N )                                                    \
-    while( (N).s < 0 && mbedtls_mpi_cmp_int( &(N), 0 ) != 0 )           \
+    while( (N).MBEDTLS_PRIVATE(s) < 0 && mbedtls_mpi_cmp_int( &(N), 0 ) != 0 )           \
         MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &(N), &(N), &grp->P ) )
 
 /*
@@ -1167,7 +1177,7 @@ static int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *p
     int ret;
     mbedtls_mpi Zi, ZZi;
 
-    if( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 )
+    if( mbedtls_mpi_cmp_int( &pt->MBEDTLS_PRIVATE(Z), 0 ) == 0 )
         return( 0 );
 
 #if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
@@ -1180,20 +1190,32 @@ static int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *p
     /*
      * X = X / Z^2  mod p
      */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &Zi,      &pt->Z,     &grp->P ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,        &Zi     ) ); MOD_MUL( ZZi );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &Zi,
+                                          &pt->MBEDTLS_PRIVATE(Z),
+                                          &grp->P ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,
+                                          &Zi,
+                                          &Zi ) );
+    MOD_MUL( ZZi );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->MBEDTLS_PRIVATE(X),
+                                          &pt->MBEDTLS_PRIVATE(X),
+                                          &ZZi    ) );
+    MOD_MUL( pt->MBEDTLS_PRIVATE(X) );
 
     /*
      * Y = Y / Z^3  mod p
      */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->MBEDTLS_PRIVATE(Y),
+                                          &pt->MBEDTLS_PRIVATE(Y), &ZZi ) );
+    MOD_MUL( pt->MBEDTLS_PRIVATE(Y) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->MBEDTLS_PRIVATE(Y),
+                                          &pt->MBEDTLS_PRIVATE(Y), &Zi ) );
+    MOD_MUL( pt->MBEDTLS_PRIVATE(Y) );
 
     /*
      * Z = 1
      */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->MBEDTLS_PRIVATE(Z), 1 ) );
 
 cleanup:
 
@@ -1234,37 +1256,41 @@ static int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
     mbedtls_mpi_init( &M ); mbedtls_mpi_init( &S ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &U );
 
     /* Special case for A = -3 */
-    if( grp->A.p == NULL )
+    if( grp->A.MBEDTLS_PRIVATE(p) == NULL )
     {
         /* M = 3(X + Z^2)(X - Z^2) */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U,  &P->X,  &S      ) ); MOD_SUB( U );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &U      ) ); MOD_MUL( S );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S, &P->MBEDTLS_PRIVATE(Z),
+                                              &P->MBEDTLS_PRIVATE(Z)         ) ); MOD_MUL( S );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T, &P->MBEDTLS_PRIVATE(X), &S ) ); MOD_ADD( T );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U, &P->MBEDTLS_PRIVATE(X), &S ) ); MOD_SUB( U );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S, &T,                     &U ) ); MOD_MUL( S );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M, &S,                     3  ) ); MOD_ADD( M );
     }
     else
     {
         /* M = 3.X^2 */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &P->X   ) ); MOD_MUL( S );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->MBEDTLS_PRIVATE(X),
+                                              &P->MBEDTLS_PRIVATE(X) ) ); MOD_MUL( S );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3         ) ); MOD_ADD( M );
 
         /* Optimize away for "koblitz" curves with A = 0 */
         if( mbedtls_mpi_cmp_int( &grp->A, 0 ) != 0 )
         {
             /* M += A.Z^4 */
-            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->MBEDTLS_PRIVATE(Z),
+                                                  &P->MBEDTLS_PRIVATE(Z)   ) ); MOD_MUL( S );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S          ) ); MOD_MUL( T );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A     ) ); MOD_MUL( S );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S          ) ); MOD_ADD( M );
         }
     }
 
     /* S = 4.X.Y^2 */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->Y,  &P->Y   ) ); MOD_MUL( T );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &T      ) ); MOD_MUL( S );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->MBEDTLS_PRIVATE(Y),
+                                          &P->MBEDTLS_PRIVATE(Y)           ) ); MOD_MUL( T );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1                           ) ); MOD_ADD( T );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->MBEDTLS_PRIVATE(X),  &T ) ); MOD_MUL( S );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1                           ) ); MOD_ADD( S );
 
     /* U = 8.Y^4 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &T,     &T      ) ); MOD_MUL( U );
@@ -1281,12 +1307,13 @@ static int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
 
     /* U = 2.Y.Z */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->Y,  &P->Z   ) ); MOD_MUL( U );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->MBEDTLS_PRIVATE(Y),
+                                          &P->MBEDTLS_PRIVATE(Z)   ) ); MOD_MUL( U );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1                   ) ); MOD_ADD( U );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &T ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &S ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &U ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(X), &T ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(Y), &S ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(Z), &U ) );
 
 cleanup:
     mbedtls_mpi_free( &M ); mbedtls_mpi_free( &S ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &U );
@@ -1330,27 +1357,30 @@ static int ecp_add_mixed( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
     /*
      * Trivial cases: P == 0 or Q == 0 (case 1)
      */
-    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
+    if( mbedtls_mpi_cmp_int( &P->MBEDTLS_PRIVATE(Z), 0 ) == 0 )
         return( mbedtls_ecp_copy( R, Q ) );
 
-    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 0 ) == 0 )
+    if( Q->MBEDTLS_PRIVATE(Z).MBEDTLS_PRIVATE(p) != NULL
+     && mbedtls_mpi_cmp_int( &Q->MBEDTLS_PRIVATE(Z), 0 ) == 0 )
         return( mbedtls_ecp_copy( R, P ) );
 
     /*
      * Make sure Q coordinates are normalized
      */
-    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 1 ) != 0 )
+    if( Q->MBEDTLS_PRIVATE(Z).MBEDTLS_PRIVATE(p) != NULL
+     && mbedtls_mpi_cmp_int( &Q->MBEDTLS_PRIVATE(Z), 1 ) != 0 )
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
     mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 ); mbedtls_mpi_init( &T3 ); mbedtls_mpi_init( &T4 );
     mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->Z,  &P->Z ) );  MOD_MUL( T1 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T2,  &T2,    &P->Y ) );  MOD_SUB( T2 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->MBEDTLS_PRIVATE(Z),
+                                          &P->MBEDTLS_PRIVATE(Z)           ) ); MOD_MUL( T1 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2, &T1, &P->MBEDTLS_PRIVATE(Z) ) ); MOD_MUL( T2 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1, &T1, &Q->MBEDTLS_PRIVATE(X) ) ); MOD_MUL( T1 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2, &T2, &Q->MBEDTLS_PRIVATE(Y) ) ); MOD_MUL( T2 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1, &T1, &P->MBEDTLS_PRIVATE(X) ) ); MOD_SUB( T1 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T2, &T2, &P->MBEDTLS_PRIVATE(Y) ) ); MOD_SUB( T2 );
 
     /* Special cases (2) and (3) */
     if( mbedtls_mpi_cmp_int( &T1, 0 ) == 0 )
@@ -1367,22 +1397,22 @@ static int ecp_add_mixed( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
         }
     }
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->Z,  &T1   ) );  MOD_MUL( Z  );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->MBEDTLS_PRIVATE(Z),  &T1   ) );  MOD_MUL( Z  );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->MBEDTLS_PRIVATE(X) ) );  MOD_MUL( T3 );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X,   &T2,    &T2   ) );  MOD_MUL( X  );
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T4   ) );  MOD_SUB( X  );
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T3,  &T3,    &X    ) );  MOD_SUB( T3 );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &T2   ) );  MOD_MUL( T3 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->MBEDTLS_PRIVATE(Y) ) );  MOD_MUL( T4 );
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &X ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &Y ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &Z ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(X), &X ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(Y), &Y ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->MBEDTLS_PRIVATE(Z), &Z ) );
 
 cleanup:
 
@@ -1536,9 +1566,9 @@ static int ecp_normalize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P
         return( mbedtls_internal_ecp_normalize_mxz( grp, P ) );
 #endif /* MBEDTLS_ECP_NORMALIZE_MXZ_ALT */
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &P->Z, &P->Z, &grp->P ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &P->Z ) ); MOD_MUL( P->X );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &P->MBEDTLS_PRIVATE(Z), &P->MBEDTLS_PRIVATE(Z), &grp->P ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->MBEDTLS_PRIVATE(X), &P->MBEDTLS_PRIVATE(X), &P->MBEDTLS_PRIVATE(Z) ) ); MOD_MUL( P->MBEDTLS_PRIVATE(X) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->MBEDTLS_PRIVATE(Z), 1 ) );
 
 cleanup:
     return( ret );
@@ -1581,8 +1611,8 @@ static int ecp_randomize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P
     }
     while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &l ) ); MOD_MUL( P->X );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->Z, &P->Z, &l ) ); MOD_MUL( P->Z );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->MBEDTLS_PRIVATE(X), &P->MBEDTLS_PRIVATE(X), &l ) ); MOD_MUL( P->MBEDTLS_PRIVATE(X) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->MBEDTLS_PRIVATE(Z), &P->MBEDTLS_PRIVATE(Z), &l ) ); MOD_MUL( P->MBEDTLS_PRIVATE(Z) );
 
 cleanup:
     mbedtls_mpi_free( &l );
@@ -1622,24 +1652,24 @@ static int ecp_double_add_mxz( const mbedtls_ecp_group *grp,
     mbedtls_mpi_init( &BB ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &C );
     mbedtls_mpi_init( &D ); mbedtls_mpi_init( &DA ); mbedtls_mpi_init( &CB );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &A,    &P->X,   &P->Z ) ); MOD_ADD( A    );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &A,    &P->MBEDTLS_PRIVATE(X),   &P->MBEDTLS_PRIVATE(Z) ) ); MOD_ADD( A    );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &AA,   &A,      &A    ) ); MOD_MUL( AA   );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &B,    &P->X,   &P->Z ) ); MOD_SUB( B    );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &B,    &P->MBEDTLS_PRIVATE(X),   &P->MBEDTLS_PRIVATE(Z) ) ); MOD_SUB( B    );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &BB,   &B,      &B    ) ); MOD_MUL( BB   );
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &E,    &AA,     &BB   ) ); MOD_SUB( E    );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &C,    &Q->X,   &Q->Z ) ); MOD_ADD( C    );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &D,    &Q->X,   &Q->Z ) ); MOD_SUB( D    );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &C,    &Q->MBEDTLS_PRIVATE(X),   &Q->MBEDTLS_PRIVATE(Z) ) ); MOD_ADD( C    );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &D,    &Q->MBEDTLS_PRIVATE(X),   &Q->MBEDTLS_PRIVATE(Z) ) ); MOD_SUB( D    );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DA,   &D,      &A    ) ); MOD_MUL( DA   );
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, &S->Z,   &S->Z ) ); MOD_MUL( S->Z );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &E,      &R->Z ) ); MOD_MUL( R->Z );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->MBEDTLS_PRIVATE(X), &DA,     &CB   ) ); MOD_MUL( S->MBEDTLS_PRIVATE(X) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->MBEDTLS_PRIVATE(X), &S->MBEDTLS_PRIVATE(X),   &S->MBEDTLS_PRIVATE(X) ) ); MOD_MUL( S->MBEDTLS_PRIVATE(X) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->MBEDTLS_PRIVATE(Z), &DA,     &CB   ) ); MOD_SUB( S->MBEDTLS_PRIVATE(Z) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->MBEDTLS_PRIVATE(Z), &S->MBEDTLS_PRIVATE(Z),   &S->MBEDTLS_PRIVATE(Z) ) ); MOD_MUL( S->MBEDTLS_PRIVATE(Z) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->MBEDTLS_PRIVATE(Z), d,       &S->MBEDTLS_PRIVATE(Z) ) ); MOD_MUL( S->MBEDTLS_PRIVATE(Z) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->MBEDTLS_PRIVATE(X), &AA,     &BB   ) ); MOD_MUL( R->MBEDTLS_PRIVATE(X) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->MBEDTLS_PRIVATE(Z), &grp->A, &E    ) ); MOD_MUL( R->MBEDTLS_PRIVATE(Z) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->MBEDTLS_PRIVATE(Z), &BB,     &R->MBEDTLS_PRIVATE(Z) ) ); MOD_ADD( R->MBEDTLS_PRIVATE(Z) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->MBEDTLS_PRIVATE(Z), &E,      &R->MBEDTLS_PRIVATE(Z) ) ); MOD_MUL( R->MBEDTLS_PRIVATE(Z) );
 
 cleanup:
     mbedtls_mpi_free( &A ); mbedtls_mpi_free( &AA ); mbedtls_mpi_free( &B );
@@ -1667,16 +1697,16 @@ static int ecp_mul_mxz( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
     mbedtls_ecp_point_init( &RP ); mbedtls_mpi_init( &PX );
 
     /* Save PX and read from P before writing to R, in case P == R */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &PX, &P->X ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &PX, &P->MBEDTLS_PRIVATE(X) ) );
     MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &RP, P ) );
 
     /* Set R to zero in modified x/z coordinates */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->X, 1 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 0 ) );
-    mbedtls_mpi_free( &R->Y );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->MBEDTLS_PRIVATE(X), 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->MBEDTLS_PRIVATE(Z), 0 ) );
+    mbedtls_mpi_free( &R->MBEDTLS_PRIVATE(Y) );
 
     /* RP.X might be slightly larger than P, so reduce it */
-    MOD_ADD( RP.X );
+    MOD_ADD( RP.MBEDTLS_PRIVATE(X) );
 
     /* Randomize coordinates of the starting point */
     if( f_rng != NULL )
@@ -1694,11 +1724,11 @@ static int ecp_mul_mxz( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
          *  else   double_add( R, RP, R, RP )
          * but using safe conditional swaps to avoid leaks
          */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->MBEDTLS_PRIVATE(X), &RP.MBEDTLS_PRIVATE(X), b ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->MBEDTLS_PRIVATE(Z), &RP.MBEDTLS_PRIVATE(Z), b ) );
         MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, &RP, R, &RP, &PX ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->MBEDTLS_PRIVATE(X), &RP.MBEDTLS_PRIVATE(X), b ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->MBEDTLS_PRIVATE(Z), &RP.MBEDTLS_PRIVATE(Z), b ) );
     }
 
     MBEDTLS_MPI_CHK( ecp_normalize_mxz( grp, R ) );
@@ -1808,10 +1838,10 @@ static int ecp_check_pubkey_sw( const mbedtls_ecp_group *grp, const mbedtls_ecp_
     PKA_PointCheckInTypeDef ECC_PointCheck = {0};
 
     /* pt coordinates must be normalized for our checks */
-    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
-        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
-        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
-        mbedtls_mpi_cmp_mpi( &pt->Y, &grp->P ) >= 0 )
+    if( mbedtls_mpi_cmp_int( &pt->MBEDTLS_PRIVATE(X), 0 ) < 0 ||
+        mbedtls_mpi_cmp_int( &pt->MBEDTLS_PRIVATE(Y), 0 ) < 0 ||
+        mbedtls_mpi_cmp_mpi( &pt->MBEDTLS_PRIVATE(X), &grp->P ) >= 0 ||
+        mbedtls_mpi_cmp_mpi( &pt->MBEDTLS_PRIVATE(Y), &grp->P ) >= 0 )
         return( MBEDTLS_ERR_ECP_INVALID_KEY );
 
     /* Set HW peripheral Input parameter: curve coefs */
@@ -1885,8 +1915,8 @@ static int mbedtls_ecp_mul_shortcuts( mbedtls_ecp_group *grp,
     else if( mbedtls_mpi_cmp_int( m, -1 ) == 0 )
     {
         MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
-        if( mbedtls_mpi_cmp_int( &R->Y, 0 ) != 0 )
-            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &R->Y, &grp->P, &R->Y ) );
+        if( mbedtls_mpi_cmp_int( &R->MBEDTLS_PRIVATE(Y), 0 ) != 0 )
+            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &R->MBEDTLS_PRIVATE(Y), &grp->P, &R->MBEDTLS_PRIVATE(Y) ) );
     }
     else
     {
@@ -2021,7 +2051,7 @@ static int ecp_check_pubkey_mx( const mbedtls_ecp_group *grp, const mbedtls_ecp_
     /* [Curve25519 p. 5] Just check X is the correct number of bytes */
     /* Allow any public value, if it's too big then we'll just reduce it mod p
      * (RFC 7748 sec. 5 para. 3). */
-    if( mbedtls_mpi_size( &pt->X ) > ( grp->nbits + 7 ) / 8 )
+    if( mbedtls_mpi_size( &pt->MBEDTLS_PRIVATE(X) ) > ( grp->nbits + 7 ) / 8 )
         return( MBEDTLS_ERR_ECP_INVALID_KEY );
 
     return( 0 );
@@ -2038,7 +2068,7 @@ int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp,
     ECP_VALIDATE_RET( pt  != NULL );
 
     /* Must use affine coordinates */
-    if( mbedtls_mpi_cmp_int( &pt->Z, 1 ) != 0 )
+    if( mbedtls_mpi_cmp_int( &pt->MBEDTLS_PRIVATE(Z), 1 ) != 0 )
         return( MBEDTLS_ERR_ECP_INVALID_KEY );
 
 #if defined(ECP_MONTGOMERY)
@@ -2225,10 +2255,10 @@ int mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
     ECP_VALIDATE_RET( key   != NULL );
     ECP_VALIDATE_RET( f_rng != NULL );
 
-    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
+    if( ( ret = mbedtls_ecp_group_load( &key->MBEDTLS_PRIVATE(grp), grp_id ) ) != 0 )
         return( ret );
 
-    return( mbedtls_ecp_gen_keypair( &key->grp, &key->d, &key->Q, f_rng, p_rng ) );
+    return( mbedtls_ecp_gen_keypair( &key->MBEDTLS_PRIVATE(grp), &key->MBEDTLS_PRIVATE(d), &key->MBEDTLS_PRIVATE(Q), f_rng, p_rng ) );
 }
 
 #define ECP_CURVE25519_KEY_SIZE 32
@@ -2243,13 +2273,13 @@ int mbedtls_ecp_read_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
     ECP_VALIDATE_RET( key  != NULL );
     ECP_VALIDATE_RET( buf  != NULL );
 
-    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
+    if( ( ret = mbedtls_ecp_group_load( &key->MBEDTLS_PRIVATE(grp), grp_id ) ) != 0 )
         return( ret );
 
     ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
 
 #if defined(ECP_MONTGOMERY)
-    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
+    if( mbedtls_ecp_get_type( &key->MBEDTLS_PRIVATE(grp) ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
     {
         /*
          * If it is Curve25519 curve then mask the key as mandated by RFC7748
@@ -2259,22 +2289,22 @@ int mbedtls_ecp_read_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
             if( buflen != ECP_CURVE25519_KEY_SIZE )
                 return MBEDTLS_ERR_ECP_INVALID_KEY;
 
-            MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &key->d, buf, buflen ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary_le( &key->MBEDTLS_PRIVATE(d), buf, buflen ) );
 
             /* Set the three least significant bits to 0 */
-            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 0, 0 ) );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 1, 0 ) );
-            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->d, 2, 0 ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->MBEDTLS_PRIVATE(d), 0, 0 ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->MBEDTLS_PRIVATE(d), 1, 0 ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &key->MBEDTLS_PRIVATE(d), 2, 0 ) );
 
             /* Set the most significant bit to 0 */
             MBEDTLS_MPI_CHK(
-                    mbedtls_mpi_set_bit( &key->d,
+                    mbedtls_mpi_set_bit( &key->MBEDTLS_PRIVATE(d),
                                          ECP_CURVE25519_KEY_SIZE * 8 - 1, 0 )
                     );
 
             /* Set the second most significant bit to 1 */
             MBEDTLS_MPI_CHK(
-                    mbedtls_mpi_set_bit( &key->d,
+                    mbedtls_mpi_set_bit( &key->MBEDTLS_PRIVATE(d),
                                          ECP_CURVE25519_KEY_SIZE * 8 - 2, 1 )
                     );
         }
@@ -2284,18 +2314,18 @@ int mbedtls_ecp_read_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
 
 #endif
 #if defined(ECP_SHORTWEIERSTRASS)
-    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
+    if( mbedtls_ecp_get_type( &key->MBEDTLS_PRIVATE(grp) ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
     {
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &key->d, buf, buflen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &key->MBEDTLS_PRIVATE(d), buf, buflen ) );
 
-        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( &key->grp, &key->d ) );
+        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( &key->MBEDTLS_PRIVATE(grp), &key->MBEDTLS_PRIVATE(d) ) );
     }
 
 #endif
 cleanup:
 
     if( ret != 0 )
-        mbedtls_mpi_free( &key->d );
+        mbedtls_mpi_free( &key->MBEDTLS_PRIVATE(d) );
 
     return( ret );
 }
@@ -2303,7 +2333,9 @@ cleanup:
 /*
  * Check a public-private key pair
  */
-int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )
+int mbedtls_ecp_check_pub_priv(
+        const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv,
+        int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
 {
     int ret;
     mbedtls_ecp_point Q;
@@ -2311,11 +2343,11 @@ int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ec
     ECP_VALIDATE_RET( pub != NULL );
     ECP_VALIDATE_RET( prv != NULL );
 
-    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
-        pub->grp.id != prv->grp.id ||
-        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
-        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
-        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
+    if( pub->MBEDTLS_PRIVATE(grp).id == MBEDTLS_ECP_DP_NONE ||
+        pub->MBEDTLS_PRIVATE(grp).id != prv->MBEDTLS_PRIVATE(grp).id ||
+        mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(X), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(X) ) ||
+        mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Y), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Y) ) ||
+        mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Z), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Z) ) )
     {
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
     }
@@ -2324,14 +2356,14 @@ int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ec
     mbedtls_ecp_group_init( &grp );
 
     /* mbedtls_ecp_mul() needs a non-const group... */
-    mbedtls_ecp_group_copy( &grp, &prv->grp );
+    mbedtls_ecp_group_copy( &grp, &prv->MBEDTLS_PRIVATE(grp) );
 
     /* Also checks d is valid */
-    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->d, &prv->grp.G, NULL, NULL ) );
+    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->MBEDTLS_PRIVATE(d), &prv->MBEDTLS_PRIVATE(grp).G, NULL, NULL ) );
 
-    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
-        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
-        mbedtls_mpi_cmp_mpi( &Q.Z, &prv->Q.Z ) )
+    if( mbedtls_mpi_cmp_mpi( &Q.MBEDTLS_PRIVATE(X), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(X) ) ||
+        mbedtls_mpi_cmp_mpi( &Q.MBEDTLS_PRIVATE(Y), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Y) ) ||
+        mbedtls_mpi_cmp_mpi( &Q.MBEDTLS_PRIVATE(Z), &prv->MBEDTLS_PRIVATE(Q).MBEDTLS_PRIVATE(Z) ) )
     {
         ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
         goto cleanup;
@@ -2356,14 +2388,14 @@ int mbedtls_ecp_write_key( mbedtls_ecp_keypair *key,
     ECP_VALIDATE_RET( buf != NULL );
 
 #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
-    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
+    if( mbedtls_ecp_get_type( &key->MBEDTLS_PRIVATE(grp) ) == MBEDTLS_ECP_TYPE_MONTGOMERY )
     {
-        if( key->grp.id == MBEDTLS_ECP_DP_CURVE25519 )
+        if( key->MBEDTLS_PRIVATE(grp).id == MBEDTLS_ECP_DP_CURVE25519 )
         {
             if( buflen < ECP_CURVE25519_KEY_SIZE )
                 return MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL;
 
-            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &key->d, buf, buflen ) );
+            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( &key->MBEDTLS_PRIVATE(d), buf, buflen ) );
         }
         else
             ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
@@ -2371,9 +2403,9 @@ int mbedtls_ecp_write_key( mbedtls_ecp_keypair *key,
 
 #endif
 #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
-    if( mbedtls_ecp_get_type( &key->grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
+    if( mbedtls_ecp_get_type( &key->MBEDTLS_PRIVATE(grp) ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )
     {
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &key->d, buf, buflen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &key->MBEDTLS_PRIVATE(d), buf, buflen ) );
     }
 
 #endif
diff --git a/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h b/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
index 5bc1aed06b7b73c69ee8896cdd3099c21fbfea52..bb8f8993b059196971deaac9a9e34fa323bdf41f 100644
--- a/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
+++ b/lib/tf-m/secure_fw/spm/include/load/spm_load_api.h
@@ -39,24 +39,37 @@
     ((uintptr_t)LOAD_INFO_ASSET(pldinf) +                              \
      (pldinf)->nassets * sizeof(struct asset_desc_t))
 
+
+/* Runtime partition struct list head node type */
+struct partition_head_t {
+    uint32_t reserved;                  /* Reserved             */
+    struct partition_t *next;           /* Next partition node  */
+};
+
+/* Runtime service struct list head node type */
+struct service_head_t {
+    uint32_t reserved;                  /* Reserved             */
+    struct service_t *next;             /* Next partition node  */
+};
+
 /*
- * Allocate a partition object and return if a load is successful.
+ * Load a partition object to linked list and return if a load is successful.
  * An 'assuredly' function, return NULL for no more partitions and
  * return a valid pointer if succeed. Other errors simply panic
  * the system and never return.
  */
-struct partition_t *load_a_partition_assuredly(void);
+struct partition_t *load_a_partition_assuredly(struct partition_head_t *head);
 
 /*
- * Allocated numbers of service objects based on given partition.
- * Link services with 'list_head' if it is provided. It also needs the
- * stateless service reference table and whole table size for loading.
+ * Load numbers of service objects to linked list based on given partition.
+ * It loads connection based services and stateless services that partition
+ * contains.
  * As an 'assuredly' function, errors simply panic the system and never
  * return.
  */
 void load_services_assuredly(struct partition_t *p_partition,
-                             struct service_t **connection_services_listhead,
-                             struct service_t **stateless_service_ref_tbl,
+                             struct service_head_t *services_listhead,
+                             struct service_t **stateless_services_ref_tbl,
                              size_t ref_tbl_size);
 
 /*
diff --git a/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c b/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c
index b171e5a86517a69a90a4547760d8c37b39c3f489..436ec257556cf5c9a67b55f8f3bb5fbb62e87837 100644
--- a/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c
+++ b/lib/tf-m/platform/ext/common/template/tfm_initial_attestation_key_material.c
@@ -60,7 +60,7 @@ const char *initial_attestation_kid = "kid@trustedfirmware.example";
 
 /* Type of the EC curve which the key belongs to, in PSA curve ID form */
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_INITIAL_ATTESTATION", "PSA-ROT")
-const psa_ecc_family_t initial_attestation_curve_type = PSA_ECC_CURVE_SECP256R1;
+const psa_ecc_family_t initial_attestation_curve_type = PSA_ECC_FAMILY_SECP_R1;
 
 /* Initial attestation private key in raw format, without any encoding.
  * It belongs to the ECDSA P-256 curve.
diff --git a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/spm_hal.c b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/spm_hal.c
index 5b9aa9c11e642426adc06904d5f895df5e21b1ba..801eb6986368d0f3d3ee4f12aea7db11378907a0 100644
--- a/lib/tf-m/platform/ext/target/nordic_nrf/common/core/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/nordic_nrf/common/core/spm_hal.c
@@ -110,11 +110,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((const uint32_t *)(memory_regions.non_secure_code_start + 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/bl2/ext/mcuboot/bl2_main.c b/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
index ab77052c3198ecb53a127f59a00274433497c5f4..987623927156b755a959a6b58304238d8179c127 100644
--- a/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
+++ b/lib/tf-m/bl2/ext/mcuboot/bl2_main.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2012-2014 Wind River Systems, Inc.
- * Copyright (c) 2017-2020 Arm Limited.
+ * Copyright (c) 2017-2021 Arm Limited.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -36,7 +36,7 @@ __asm("  .global __ARM_use_no_argv\n");
 #endif
 
 #ifdef MCUBOOT_ENCRYPT_RSA
-#define BL2_MBEDTLS_MEM_BUF_LEN 0x225C
+#define BL2_MBEDTLS_MEM_BUF_LEN 0x3000
 #else
 #define BL2_MBEDTLS_MEM_BUF_LEN 0x2000
 #endif
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
index 7d6e3420d75664cb2f8a5ac6af1360ef1086640d..43b836b883b510b106b99cb48e53415e5ee7bafa 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.h
@@ -93,11 +93,7 @@ struct partition_t {
     uint32_t signals_allowed;
     uint32_t signals_waiting;
     uint32_t signals_asserted;
-};
-
-struct spm_partition_db_t {
-    uint32_t partition_count;
-    struct partition_t *partitions;
+    struct partition_t *next;
 };
 
 /* RoT Service data */
@@ -105,7 +101,7 @@ struct service_t {
     const struct service_load_info_t *p_ldinf;     /* Service load info      */
     struct partition_t *partition;                 /* Owner of the service   */
     struct bi_list_node_t handle_list;             /* Service handle list    */
-    struct bi_list_node_t list;                    /* For list operation     */
+    struct service_t *next;                        /* For list operation     */
 };
 
 /* RoT connection handle list */
@@ -215,6 +211,18 @@ int32_t tfm_spm_free_conn_handle(struct service_t *service,
 struct tfm_msg_body_t *tfm_spm_get_msg_by_signal(struct partition_t *partition,
                                                  psa_signal_t signal);
 
+
+/**
+ * \brief                   Get partition by Partition ID.
+ *
+ * \param[in] partition_id  The Partition ID of the partition to get
+ *
+ * \retval NULL             Failed
+ * \retval "Not NULL"       Return the parttion context pointer
+ *                          \ref partition_t structures
+ */
+struct partition_t *tfm_spm_get_partition_by_id(int32_t partition_id);
+
 /**
  * \brief                   Get current running partition context.
  *
@@ -346,6 +354,13 @@ int32_t tfm_memory_check(const void *buffer, size_t len, bool ns_caller,
                          enum tfm_memory_access_e access,
                          uint32_t privileged);
 
+/**
+ * \brief               Set up the isolation boundary of the given partition.
+ *
+ * \param[in] partition The partition of which the boundary is set up.
+ */
+void tfm_set_up_isolation_boundary(const struct partition_t *partition);
+
 /*
  * PendSV specified function.
  *
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
index 58ac546039f81c669a7a3956da32939e5287ce48..d96f23c0fffc2177751003d979c584d598094d22 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/spm_hal.c
@@ -145,11 +145,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_alt.c
index da0c770cced39d8e1065dd85403a6af1cc905933..f500f765de1c5acb86d45876fbbfca780d3157a1 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -378,8 +378,8 @@ int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
 int mbedtls_ecdsa_genkey( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid,
                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
 {
-    return( mbedtls_ecp_group_load( &ctx->grp, gid ) ||
-            cc_ecp_gen_keypair( &ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng ) );
+    return( mbedtls_ecp_group_load( &ctx->MBEDTLS_PRIVATE(grp), gid ) ||
+            cc_ecp_gen_keypair( &ctx->MBEDTLS_PRIVATE(grp), &ctx->MBEDTLS_PRIVATE(d), &ctx->MBEDTLS_PRIVATE(Q), f_rng, p_rng ) );
 }
 #endif /* MBEDTLS_ECDSA_GENKEY_ALT */
 
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_arch.h b/lib/tf-m/secure_fw/spm/include/tfm_arch.h
index f9b7a3d7af4c9acdbdc9e7d0f67dfde9f0ccf253..8a96d9fb3ee7d7368c14abf664d37b632ddc94ca 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_arch.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_arch.h
@@ -36,7 +36,7 @@ struct tfm_state_context_t {
     uint32_t    lr;
     uint32_t    ra;
     uint32_t    xpsr;
-};
+} __attribute__ ((aligned(8)));
 
 #define TFM_STATE_RET_VAL(ctx) (((struct tfm_state_context_t *)((ctx)->sp))->r0)
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c b/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
index cdd0104a8f5ba075b59adaa7adb2df47c3bdb885..c178fe121a0131222275332990413bcf98e71b04 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/static_load.c
@@ -18,58 +18,62 @@
 #include "load/service_defs.h"
 #include "psa/client.h"
 
-#include "secure_fw/partitions/tfm_service_list.inc"
-#include "tfm_spm_db_ipc.inc"
-
 /* Partition load data region */
 REGION_DECLARE(Image$$, TFM_SP_LOAD_LIST, $$RO$$Base);
 REGION_DECLARE(Image$$, TFM_SP_LOAD_LIST, $$RO$$Limit);
 
+/* Partition and service runtime pool region */
+REGION_DECLARE(Image$$, ER_PART_RT_POOL, $$ZI$$Base);
+REGION_DECLARE(Image$$, ER_PART_RT_POOL, $$ZI$$Limit);
+REGION_DECLARE(Image$$, ER_SERV_RT_POOL, $$ZI$$Base);
+REGION_DECLARE(Image$$, ER_SERV_RT_POOL, $$ZI$$Limit);
+
 static uintptr_t ldinf_sa = PART_REGION_ADDR(TFM_SP_LOAD_LIST, $$RO$$Base);
 static uintptr_t ldinf_ea = PART_REGION_ADDR(TFM_SP_LOAD_LIST, $$RO$$Limit);
+static uintptr_t part_pool_sa = PART_REGION_ADDR(ER_PART_RT_POOL, $$ZI$$Base);
+static uintptr_t part_pool_ea = PART_REGION_ADDR(ER_PART_RT_POOL, $$ZI$$Limit);
+static uintptr_t serv_pool_sa = PART_REGION_ADDR(ER_SERV_RT_POOL, $$ZI$$Base);
+static uintptr_t serv_pool_ea = PART_REGION_ADDR(ER_SERV_RT_POOL, $$ZI$$Limit);
 
-/* Allocate runtime space for partition from the pool. Static allocation. */
+/* Allocate runtime space for partition. Panic if pool runs out. */
 static struct partition_t *tfm_allocate_partition_assuredly(void)
 {
-    static uint32_t partition_pool_pos = 0;
-    struct partition_t *p_partition_allocated = NULL;
+    struct partition_t *p_part_allocated = (struct partition_t *)part_pool_sa;
 
-    if (partition_pool_pos >= g_spm_partition_db.partition_count) {
+    part_pool_sa += sizeof(struct partition_t);
+    if (part_pool_sa > part_pool_ea) {
         tfm_core_panic();
     }
 
-    p_partition_allocated = &g_spm_partition_db.partitions[partition_pool_pos];
-    partition_pool_pos++;
-
-    return p_partition_allocated;
+    return p_part_allocated;
 }
 
-/* Allocate runtime space for service from the pool. Static allocation. */
+/* Allocate runtime space for services. Panic if pool runs out. */
 static struct service_t *tfm_allocate_service_assuredly(uint32_t service_count)
 {
-    static uint32_t service_pool_pos = 0;
-    struct service_t *p_service_allocated = NULL;
-    uint32_t num_of_services = sizeof(g_services) / sizeof(struct service_t);
+    struct service_t *p_serv_allocated = (struct service_t *)serv_pool_sa;
 
     if (service_count == 0) {
         return NULL;
-    } else if ((service_count > num_of_services) ||
-               (service_pool_pos >= num_of_services) ||
-               (service_pool_pos + service_count > num_of_services)) {
-        tfm_core_panic();
     }
 
-    p_service_allocated = &g_services[service_pool_pos];
-    service_pool_pos += service_count;
+    serv_pool_sa += service_count * sizeof(struct service_t);
+    if (serv_pool_sa > serv_pool_ea) {
+        tfm_core_panic();
+    }
 
-    return p_service_allocated;
+    return p_serv_allocated;
 }
 
-struct partition_t *load_a_partition_assuredly(void)
+struct partition_t *load_a_partition_assuredly(struct partition_head_t *head)
 {
     struct partition_load_info_t *p_ptldinf;
     struct partition_t           *partition;
 
+    if (!head) {
+        tfm_core_panic();
+    }
+
     if ((UINTPTR_MAX - ldinf_sa < sizeof(struct partition_load_info_t)) ||
         (ldinf_sa + sizeof(struct partition_load_info_t) >= ldinf_ea)) {
         return NULL;
@@ -102,12 +106,14 @@ struct partition_t *load_a_partition_assuredly(void)
 
     ldinf_sa += LOAD_INFSZ_BYTES(p_ptldinf);
 
+    UNI_LIST_INSERT_AFTER(head, partition);
+
     return partition;
 }
 
 void load_services_assuredly(struct partition_t *p_partition,
-                             struct service_t **connection_services_listhead,
-                             struct service_t **stateless_service_ref_tbl,
+                             struct service_head_t *services_listhead,
+                             struct service_t **stateless_services_ref_tbl,
                              size_t ref_tbl_size)
 {
     uint32_t i, serv_ldflags, hidx;
@@ -115,7 +121,7 @@ void load_services_assuredly(struct partition_t *p_partition,
     const struct partition_load_info_t *p_ptldinf;
     const struct service_load_info_t *p_servldinf;
 
-    if (!p_partition || !connection_services_listhead) {
+    if (!p_partition || !services_listhead) {
         tfm_core_panic();
     }
 
@@ -131,14 +137,14 @@ void load_services_assuredly(struct partition_t *p_partition,
         p_partition->signals_allowed |= p_servldinf[i].signal;
         services[i].p_ldinf = &p_servldinf[i];
         services[i].partition = p_partition;
+        services[i].next = NULL;
 
         BI_LIST_INIT_NODE(&services[i].handle_list);
-        BI_LIST_INIT_NODE(&services[i].list);
 
         /* Populate the stateless service reference table */
         serv_ldflags = p_servldinf[i].flags;
         if (SERVICE_IS_STATELESS(serv_ldflags)) {
-            if ((stateless_service_ref_tbl == NULL) ||
+            if ((stateless_services_ref_tbl == NULL) ||
                 (ref_tbl_size == 0) ||
                 (ref_tbl_size !=
                  STATIC_HANDLE_NUM_LIMIT * sizeof(struct service_t *))) {
@@ -148,21 +154,13 @@ void load_services_assuredly(struct partition_t *p_partition,
             hidx = SERVICE_GET_STATELESS_HINDEX(serv_ldflags);
 
             if ((hidx >= STATIC_HANDLE_NUM_LIMIT) ||
-                stateless_service_ref_tbl[hidx]) {
+                stateless_services_ref_tbl[hidx]) {
                 tfm_core_panic();
             }
-            stateless_service_ref_tbl[hidx] = &services[i];
-
-            /* Skip chaining stateless services as they won't be looked-up. */
-            continue;
+            stateless_services_ref_tbl[hidx] = &services[i];
         }
 
-        if (*connection_services_listhead) {
-            BI_LIST_INSERT_AFTER(&(*connection_services_listhead)->list,
-                                 &services[i].list);
-        } else {
-            *connection_services_listhead = &services[i];
-        }
+        UNI_LIST_INSERT_AFTER(services_listhead, &services[i]);
     }
 }
 
@@ -182,8 +180,7 @@ void load_irqs_assuredly(struct partition_t *p_partition)
     for (i = 0; i < p_ldinf->nirqs; i++) {
         p_partition->signals_allowed |= p_irq_info[i].signal;
 
-        if (tfm_spm_hal_set_secure_irq_priority(p_irq_info[i].source,
-                                                TFM_DEFAULT_SECURE_IRQ_PRIOTITY)
+        if (tfm_spm_hal_set_secure_irq_priority(p_irq_info[i].source)
                                                       != TFM_PLAT_ERR_SUCCESS) {
             tfm_core_panic();
         }
diff --git a/lib/tf-m/lib/ext/t_cose/test/t_cose_make_psa_test_key.c b/lib/tf-m/lib/ext/t_cose/test/t_cose_make_psa_test_key.c
index d1462c4fe21ca45afb3d571ac112511f9c35cd07..836d599377731baf64236b9efd3567928a964946 100644
--- a/lib/tf-m/lib/ext/t_cose/test/t_cose_make_psa_test_key.c
+++ b/lib/tf-m/lib/ext/t_cose/test/t_cose_make_psa_test_key.c
@@ -2,6 +2,7 @@
  *  t_cose_make_psa_test_key.c
  *
  * Copyright 2019-2020, Laurence Lundblade
+ * Copyright (c) 2021, Arm Limited. All rights reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -86,21 +87,21 @@ enum t_cose_err_t make_ecdsa_key_pair(int32_t            cose_algorithm_id,
     case COSE_ALGORITHM_ES256:
         private_key     = private_key_256;
         private_key_len = sizeof(private_key_256);
-        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_CURVE_SECP256R1);
+        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1);
         key_alg         = PSA_ALG_ECDSA(PSA_ALG_SHA_256);
         break;
 
     case COSE_ALGORITHM_ES384:
         private_key     = private_key_384;
         private_key_len = sizeof(private_key_384);
-        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_CURVE_SECP384R1);
+        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1);
         key_alg         = PSA_ALG_ECDSA(PSA_ALG_SHA_384);
         break;
 
     case COSE_ALGORITHM_ES512:
         private_key     = private_key_521;
         private_key_len = sizeof(private_key_521);
-        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_CURVE_SECP521R1);
+        key_type        = PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1);
         key_alg         = PSA_ALG_ECDSA(PSA_ALG_SHA_512);
         break;
 
@@ -143,8 +144,8 @@ enum t_cose_err_t make_ecdsa_key_pair(int32_t            cose_algorithm_id,
     /* Say what algorithm and operations the key can be used with / for */
     psa_key_policy_t policy = psa_key_policy_init();
     psa_key_policy_set_usage(&policy,
-                             PSA_KEY_USAGE_SIGN | PSA_KEY_USAGE_VERIFY,
-                             key_alg);
+                            PSA_KEY_USAGE_SIGN_HASH | PSA_KEY_USAGE_VERIFY_HASH,
+                            key_alg);
     crypto_result = psa_set_key_policy(key_handle, &policy);
     if (crypto_result != PSA_SUCCESS) {
         return T_COSE_ERR_FAIL;
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/ppu_config.h b/lib/tf-m/platform/ext/target/cypress/psoc64/ppu_config.h
index 4f3bb1cb07237ffd41c0a6920c4205717e356fbe..fbff0f16fdcbbde7dcf5cc0423314801725872d3 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/ppu_config.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/ppu_config.h
@@ -85,15 +85,6 @@
 #define PPU_CRYPTO_CRYPTO_MASTER_CONFIG NON_SECURE_READ_ONLY_CONFIG
 #define PPU_CRYPTO_CRYPTO_SLAVE_CONFIG SECURE_PRIV_ONLY_CONFIG
 
-#define PPU_CRYPTO_BOOT_MASTER_CONFIG NON_SECURE_READ_ONLY_CONFIG
-#define PPU_CRYPTO_BOOT_SLAVE_CONFIG SECURE_PRIV_ONLY_CONFIG
-
-#define PPU_CRYPTO_KEY0_MASTER_CONFIG NON_SECURE_READ_ONLY_CONFIG
-#define PPU_CRYPTO_KEY0_SLAVE_CONFIG SECURE_PRIV_ONLY_CONFIG
-
-#define PPU_CRYPTO_KEY1_MASTER_CONFIG NON_SECURE_READ_ONLY_CONFIG
-#define PPU_CRYPTO_KEY1_SLAVE_CONFIG SECURE_PRIV_ONLY_CONFIG
-
 #define PPU_CRYPTO_BUF_MASTER_CONFIG NON_SECURE_READ_ONLY_CONFIG
 #define PPU_CRYPTO_BUF_SLAVE_CONFIG SECURE_PRIV_ONLY_CONFIG
 
diff --git a/lib/tf-m/secure_fw/spm/ffm/spm_log.c b/lib/tf-m/secure_fw/spm/ffm/spm_log.c
index b15f87d764737cedfa348dd182d473ef4079fb82..5488d5470c384a0d7ac2bfe2eb82694460f89b86 100644
--- a/lib/tf-m/secure_fw/spm/ffm/spm_log.c
+++ b/lib/tf-m/secure_fw/spm/ffm/spm_log.c
@@ -6,6 +6,22 @@
  */
 
 #include "tfm_spm_log.h"
+#if (TFM_SYSTEM_FP >= 1)
+#include <stdbool.h>
+#include "tfm_core_utils.h"
+#endif
+
+#define MAX_DIGIT_BITS 12  /* 8 char for number, 2 for '0x' and 2 for '\r\n' */
+#if (TFM_SYSTEM_FP >= 1)
+/* 1 for '+/-', 1 for '.' and 2 for '\r\n', remainings are for number */
+#define MAX_DIGIT_BITS_F      (24)
+#define MAX_DECIMAL_BITS      (6) /* Upto 6 decimal points */
+#define MAX_DECIMAL_NUM       (1000000U)
+#define MAX_FLOAT_NUM         (1e9)
+
+#define ERROR_NAN             ("nan\r\n")
+#define ERROR_NOT_SUPPORTED   ("not support\r\n")
+#endif
 
 #define MAX_DIGIT_BITS 12  /* 8 char for number, 2 for '0x' and 2 for '\r\n' */
 const static char HEX_TABLE[] = {'0', '1', '2', '3', '4', '5', '6', '7',
@@ -54,3 +70,112 @@ int32_t spm_log_msgval(const char *msg, size_t len, uint32_t value)
     }
     return (result_msg + result_val);
 }
+
+#if (TFM_SYSTEM_FP >= 1)
+void ftoa(double num, char* num_buff)
+{
+    int count = 0, k = 0;
+    int i = 0, j = 0, temp = 0;
+    bool f_neg = false;
+
+    /* NAN detection */
+    if (num != num) {
+        spm_memcpy(num_buff, ERROR_NAN, 5);
+        return;
+    }
+
+    /* Maximum float number supported is 1e9, otherwise overflow 32 bits */
+    if ((num > MAX_FLOAT_NUM) || (num < -MAX_FLOAT_NUM)) {
+        spm_memcpy(num_buff, ERROR_NOT_SUPPORTED, 13);
+        return;
+    }
+
+    /* Check negative number */
+    if (num < 0) {
+        f_neg = true;
+        num = 0 - num;
+    }
+
+    /* Break down */
+    int ipart = (int)num;
+    float part = (num - ipart) * MAX_DECIMAL_NUM;
+    int fpart = (int)part;
+    float rpart = part - fpart;
+    /* Round check */
+    if (rpart > 0.5) {
+        fpart += 1;
+    }
+
+    num_buff[count++] = '\n';
+    num_buff[count++] = '\r';
+
+    k = MAX_DECIMAL_BITS;
+    /* Fraction part */
+    while (count < MAX_DIGIT_BITS_F) {
+        --k;
+        num_buff[count++] = '0' + (fpart % 10);
+        if (!(fpart /= 10U)) {
+            break;
+        }
+    }
+
+    /* Adding extra 0s for decimal part starting with zero, e.g.0.000XXX */
+    while ((count < MAX_DIGIT_BITS_F) && (k-- > 0)) {
+        num_buff[count++] = '0';
+    }
+
+    /* Radix point */
+    if (count < MAX_DIGIT_BITS_F) {
+        num_buff[count++] = '.';
+    }
+
+    /* Integer part */
+    while (count < MAX_DIGIT_BITS_F) {
+        num_buff[count++] = '0' + (ipart % 10);
+        if (!(ipart /= 10)) {
+            break;
+        }
+    }
+
+    /* Add sign for negative number */
+    if (count < MAX_DIGIT_BITS_F) {
+        if (f_neg) {
+            num_buff[count++] = '-';
+        }
+    }
+
+    /* Reverse */
+    j = count;
+    i = 0;
+    while (i < j) {
+        temp = num_buff[i];
+        num_buff[i] = num_buff[j];
+        num_buff[j] = temp;
+        i++;
+        j--;
+    }
+}
+
+int32_t spm_log_msgvalf(const char *msg, size_t len, double value)
+{
+    int32_t result_msg = 0, result_val;
+    char value_str[MAX_DIGIT_BITS_F];
+
+    if (msg && len) {
+        result_msg = tfm_hal_output_spm_log(msg, len);
+        if (result_msg < TFM_HAL_SUCCESS) {
+            return result_msg;
+        }
+    }
+
+    spm_memset(value_str, 0, MAX_DIGIT_BITS_F);
+    ftoa(value, value_str);
+    result_val = tfm_hal_output_spm_log(value_str,
+                                        MAX_DIGIT_BITS_F);
+    if (result_val < TFM_HAL_SUCCESS) {
+        return result_val;
+    }
+
+    return (result_msg + result_val);
+}
+#endif /* TFM_SYSTEM_FP >= 1 */
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/gcm_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/gcm_alt.c
index 59e340e207c6c267a92934284e0bf539f6a5a7e4..679787caf89a92baa3c5e62961d71aa524ccdc41 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/gcm_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/gcm_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -580,42 +580,59 @@ int mbedtls_gcm_auth_decrypt( mbedtls_gcm_context *ctx,
 int mbedtls_gcm_starts(mbedtls_gcm_context *ctx,
                        int mode,
                        const unsigned char *iv,
-               size_t iv_len,
-               const unsigned char *aad,
-               size_t aad_len)
+                       size_t iv_len)
 {
     CC_UNUSED_PARAM(ctx);
     CC_UNUSED_PARAM(mode);
     CC_UNUSED_PARAM(iv);
     CC_UNUSED_PARAM(iv_len);
-    CC_UNUSED_PARAM(aad);
-    CC_UNUSED_PARAM(aad_len);
 
     return (MBEDTLS_ERR_GCM_API_IS_NOT_SUPPORTED);
 }
 
 int mbedtls_gcm_update(mbedtls_gcm_context *ctx,
-               size_t length,
-               const unsigned char *input,
-               unsigned char *output)
+                       const unsigned char *input,
+                       size_t input_length,
+                       unsigned char *output,
+                       size_t output_size,
+                       size_t *output_length)
 {
     CC_UNUSED_PARAM(ctx);
-    CC_UNUSED_PARAM(length);
     CC_UNUSED_PARAM(input);
+    CC_UNUSED_PARAM(input_length);
     CC_UNUSED_PARAM(output);
+    CC_UNUSED_PARAM(output_size);
+    CC_UNUSED_PARAM(output_length);
 
     return (MBEDTLS_ERR_GCM_API_IS_NOT_SUPPORTED);
 }
 
 int mbedtls_gcm_finish(mbedtls_gcm_context *ctx,
-               unsigned char *tag,
-               size_t tag_len)
+                       unsigned char *output,
+                       size_t output_size,
+                       size_t *output_length,
+                       unsigned char *tag,
+                       size_t tag_len)
 {
     CC_UNUSED_PARAM(ctx);
+    CC_UNUSED_PARAM(output);
+    CC_UNUSED_PARAM(output_size);
+    CC_UNUSED_PARAM(output_length);
     CC_UNUSED_PARAM(tag);
     CC_UNUSED_PARAM(tag_len);
 
     return (MBEDTLS_ERR_GCM_API_IS_NOT_SUPPORTED);
 }
+
+int mbedtls_gcm_update_ad(mbedtls_gcm_context *ctx,
+                          const unsigned char *add,
+                          size_t add_len)
+{
+    CC_UNUSED_PARAM(ctx);
+    CC_UNUSED_PARAM(add);
+    CC_UNUSED_PARAM(add_len);
+
+    return (MBEDTLS_ERR_GCM_API_IS_NOT_SUPPORTED);
+}
 /**************************************************************************************************/
 #endif
diff --git a/lib/tf-m/platform/include/tfm_plat_test.h b/lib/tf-m/platform/include/tfm_plat_test.h
index db5b40808820326941fae17b1e6c9fe817b4dd0f..013081d2ccd23a42ea98e08517ee5df9ba76bb59 100644
--- a/lib/tf-m/platform/include/tfm_plat_test.h
+++ b/lib/tf-m/platform/include/tfm_plat_test.h
@@ -56,14 +56,29 @@ uint32_t tfm_plat_test_get_userled_mask(void);
  */
 #ifdef TFM_ENABLE_SLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
 void tfm_plat_test_secure_timer_start(void);
 
+
+/**
+ * \brief Clears Secure timer interrupt
+ */
+#ifdef TFM_ENABLE_SLIH_TEST
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif TFM_ENABLE_FLIH_TEST
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
+#endif
+void tfm_plat_test_secure_timer_clear_intr(void);
+
 /**
  * \brief Stops the Secure timer and clears the timer interrupt.
  */
 #ifdef TFM_ENABLE_SLIH_TEST
 TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
 void tfm_plat_test_secure_timer_stop(void);
 
diff --git a/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c
index 8eaf3e51ce6f23a8d4f9e4bb50d864a41e735e24..628773ebd91c0165a80e07ad893e2564d8053583 100644
--- a/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c
+++ b/lib/tf-m/secure_fw/spm/ffm/spm_psa_client_call.c
@@ -158,6 +158,10 @@ psa_status_t tfm_spm_client_psa_call(psa_handle_t handle, int32_t type,
         }
 
         service = GET_STATELESS_SERVICE(index);
+        if (!service) {
+            tfm_core_panic();
+        }
+
         sid = service->p_ldinf->sid;
 
         /*
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cmac_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cmac_alt.c
index 7e78950760c4acb0c9f5d906447cb351aa24ba36..31430d1efd3ff7921835935d751786bf32b7b7b2 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cmac_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cmac_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2020, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -152,7 +152,7 @@ int mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx, const unsigned ch
         return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
     }
 
-    ctx->cmac_ctx = cmac_ctx;
+    ctx->MBEDTLS_PRIVATE(cmac_ctx) = cmac_ctx;
     mbedtls_zeroize_internal( ((mbedtls_cmac_private_context_t*)cmac_ctx)->cmac_ctrl_ctx.state,
                             sizeof( ((mbedtls_cmac_private_context_t*)cmac_ctx)->cmac_ctrl_ctx.state ) );
 
@@ -189,14 +189,14 @@ int mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx, const unsigned ch
             return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
 
-    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
-        ctx->cmac_ctx == NULL )
+    if( ctx == NULL || ctx->MBEDTLS_PRIVATE(cipher_info) == NULL || input == NULL ||
+        ctx->MBEDTLS_PRIVATE(cmac_ctx) == NULL )
     {
         return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
 
-    cmac_ctx = ctx->cmac_ctx;
-    block_size = ctx->cipher_info->block_size;
+    cmac_ctx = ctx->MBEDTLS_PRIVATE(cmac_ctx);
+    block_size = ctx->MBEDTLS_PRIVATE(cipher_info)->MBEDTLS_PRIVATE(block_size);
 
     /* Is there data still to process from the last call, that's greater in
      * size than a block? */
@@ -287,13 +287,13 @@ int mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx, unsigned char *ou
     CCBuffInfo_t inBuffInfo;
     CCBuffInfo_t outBuffInfo;
 
-    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||
+    if( ctx == NULL || ctx->MBEDTLS_PRIVATE(cipher_info) == NULL || ctx->MBEDTLS_PRIVATE(cmac_ctx) == NULL ||
             output == NULL )
     {
             return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
 
-    cmac_ctx = ctx->cmac_ctx;
+    cmac_ctx = ctx->MBEDTLS_PRIVATE(cmac_ctx);
 
     ret = SetDataBuffersInfo((const uint8_t*)&((mbedtls_cmac_private_context_t*)cmac_ctx)->cmac_ctrl_ctx.unprocessed_block,
                              ((mbedtls_cmac_private_context_t*)cmac_ctx)->cmac_ctrl_ctx.unprocessed_len,
@@ -320,7 +320,7 @@ int mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx, unsigned char *ou
 
     CC_PalMemCopy(output, ((mbedtls_cmac_private_context_t*)cmac_ctx)->aes_ctx.ivBuf, AES_IV_SIZE);
 
-    mbedtls_zeroize_internal( ctx->cmac_ctx, sizeof( mbedtls_cmac_private_context_t ) );
+    mbedtls_zeroize_internal( ctx->MBEDTLS_PRIVATE(cmac_ctx), sizeof( mbedtls_cmac_private_context_t ) );
 
     return (0);
 }
@@ -329,12 +329,12 @@ int mbedtls_cipher_cmac_reset( mbedtls_cipher_context_t *ctx )
 {
     mbedtls_cmac_context_t* cmac_ctx = NULL;
 
-    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL )
+    if( ctx == NULL || ctx->MBEDTLS_PRIVATE(cipher_info) == NULL || ctx->MBEDTLS_PRIVATE(cmac_ctx) == NULL )
     {
         return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
 
-    cmac_ctx = ctx->cmac_ctx;
+    cmac_ctx = ctx->MBEDTLS_PRIVATE(cmac_ctx);
 
     /* Reset the internal state */
     ((mbedtls_cmac_private_context_t*)cmac_ctx)->cmac_ctrl_ctx.unprocessed_len = 0;
@@ -362,7 +362,7 @@ int mbedtls_cipher_cmac( const mbedtls_cipher_info_t *cipher_info,
     {
         return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
-    if( cipher_info->base == NULL )
+    if( cipher_info->MBEDTLS_PRIVATE(base) == NULL )
     {
         return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
     }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/main.c b/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
index 7d34578f5aef1f5696c1c181d5293ef5ff3d7c90..7ce7f1f2e3590f02474f94472bb32a7f87a6bb1d 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/main.c
@@ -102,6 +102,24 @@ static fih_int tfm_core_init(void)
 
     SPMLOG_DBGMSGVAL("TF-M isolation level is: ", TFM_LVL);
 
+#if (TFM_SYSTEM_FP == 0)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Software\033[0m\r\n");
+#elif (TFM_SYSTEM_FP == 1)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Hybird\033[0m\r\n");
+#elif (TFM_SYSTEM_FP == 2)
+    SPMLOG_INFMSG("\033[1;33mTF-M FPU mode: Hardware\033[0m\r\n");
+#endif
+
+#if (TFM_SYSTEM_FP >= 1)
+#ifdef TFM_LAZY_FP
+    SPMLOG_INFMSG("\033[1;33mLazy stacking(S) enabled\033[0m\r\n");
+#elif defined TFM_LAZY_FP_NS
+    SPMLOG_INFMSG("\033[1;33mLazy stacking(NS) enabled\033[0m\r\n");
+#else
+    SPMLOG_INFMSG("\033[1;33mLazy stacking disabled\033[0m\r\n");
+#endif
+#endif
+
     tfm_core_validate_boot_data();
 
     configure_ns_code();
@@ -150,6 +168,8 @@ int main(void)
      */
     tfm_arch_set_secure_exception_priorities();
 
+    tfm_arch_clear_fp_status();
+
     /* Move to handler mode for further SPM initialization. */
     tfm_core_handler_mode();
 }
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
index 2d9f06f297e9f7e00ab138a764db48f4f36e1a94..0b7c74afbedae3c6df52d9adf6ea7f9600256713 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/sse_200/partition/region_defs.h
@@ -83,7 +83,7 @@
 #define IMAGE_NS_CODE_SIZE \
             (FLASH_NS_PARTITION_SIZE - BL2_HEADER_SIZE - BL2_TRAILER_SIZE)
 
-#define CMSE_VENEER_REGION_SIZE     (0x360)
+#define CMSE_VENEER_REGION_SIZE     (0x380)
 
 /* Alias definitions for secure and non-secure areas*/
 #define S_ROM_ALIAS(x)  (S_ROM_ALIAS_BASE + (x))
diff --git a/lib/tf-m/platform/ext/target/nxp/common/crypto_hw.c b/lib/tf-m/platform/ext/target/nxp/common/crypto_hw.c
new file mode 100644
index 0000000000000000000000000000000000000000..bad2727458ea86d807758b5a2d41e22bafd4af42
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/nxp/common/crypto_hw.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ * Copyright 2020 NXP. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "crypto_hw.h"
+
+
+/*
+ * \brief Initialize a crypto accelerator
+ */
+int crypto_hw_accelerator_init(void)
+{
+    return 0;
+}
+
+/*
+ * \brief Deallocate a crypto accelerator
+ */
+int crypto_hw_accelerator_finish(void)
+{
+    return 0;
+}
+
+
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_irq_list.h b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_irq_list.h
index fbe01ad7e051231389d21fc5f50eb3be71bdea0b..bb93979a5e27e4e049834695dab6d23bc749ea29 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_irq_list.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_irq_list.h
@@ -11,13 +11,10 @@
 #include "tfm_hal_device_header.h"
 #include "psa/service.h"
 
-#define TFM_DEFAULT_SECURE_IRQ_PRIORITY 128
-
 struct tfm_core_irq_signal_data_t {
     int32_t partition_id;
     psa_signal_t signal_value;
     uint32_t irq_line;
-    uint32_t irq_priority;
 };
 
 extern const struct tfm_core_irq_signal_data_t tfm_core_irq_signals[];
diff --git a/lib/tf-m/bl2/ext/mcuboot/include/flash_map_backend/flash_map_backend.h b/lib/tf-m/bl2/ext/mcuboot/include/flash_map_backend/flash_map_backend.h
index cd68c746b2bf92e2b3828c9d4763dc5755aaf52c..cf2565476edea36b452ffcef1a86e425437316fc 100644
--- a/lib/tf-m/bl2/ext/mcuboot/include/flash_map_backend/flash_map_backend.h
+++ b/lib/tf-m/bl2/ext/mcuboot/include/flash_map_backend/flash_map_backend.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (c) 2018 Nordic Semiconductor ASA
  * Copyright (c) 2015 Runtime Inc
- * Copyright (c) 2020 Arm Limited.
+ * Copyright (c) 2020-2021 Arm Limited.
  *
  * SPDX-License-Identifier: Apache-2.0
  */
@@ -73,6 +73,37 @@ uint8_t flash_area_erased_val(const struct flash_area *fap);
 int flash_area_read_is_empty(const struct flash_area *fa, uint32_t off,
         void *dst, uint32_t len);
 
+static inline uint8_t flash_area_get_id(const struct flash_area *fa)
+{
+    return fa->fa_id;
+}
+
+static inline uint8_t flash_area_get_device_id(const struct flash_area *fa)
+{
+    return fa->fa_device_id;
+}
+
+static inline uint32_t flash_area_get_off(const struct flash_area *fa)
+{
+    return fa->fa_off;
+}
+
+static inline uint32_t flash_area_get_size(const struct flash_area *fa)
+{
+    return fa->fa_size;
+}
+
+static inline uint32_t flash_sector_get_off(const struct flash_sector *fs)
+{
+    return fs->fs_off;
+}
+
+static inline uint32_t flash_sector_get_size(const struct flash_sector *fs)
+{
+    return fs->fs_size;
+}
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/accelerator/mbedtls_accelerator_config.h b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/accelerator/mbedtls_accelerator_config.h
index 89473e4b4ad8ad64f4ee4a4bf687be087ce729a5..58d5c8acde62bd356c387a4cba49a53139c9a6bb 100644
--- a/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/accelerator/mbedtls_accelerator_config.h
+++ b/lib/tf-m/platform/ext/target/stm/stm32l562e_dk/accelerator/mbedtls_accelerator_config.h
@@ -15,7 +15,7 @@ extern "C" {
 
 
 /* RNG Config */
-#undef MBEDTLS_TEST_NULL_ENTROPY
+#undef MBEDTLS_ENTROPY_NV_SEED
 #undef MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 #undef MBEDTLS_ECP_NIST_OPTIM
 #define MBEDTLS_PLATFORM_ENTROPY
@@ -53,6 +53,9 @@ extern "C" {
 #define MBEDTLS_MD5_ALT
 #endif /* MBEDTLS_ECP_C && MBEDTLS_MD_C */
 
+#undef MBEDTLS_AES_SETKEY_DEC_ALT
+#undef MBEDTLS_AES_DECRYPT_ALT
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
index 06d3546f03efdd9ac3182ef298e4299bdfde8d14..fb32e14bd6ea30f952cc39d1bbba9ea39513fb9d 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_Flash.c
@@ -26,9 +26,9 @@
 #define ARG_UNUSED(arg)  ((void)arg)
 #endif
 
-#define FLASH0_BASE_S         SRAM_BASE_S
-#define FLASH0_BASE_NS        SRAM_BASE_NS
-#define FLASH0_SIZE           SRAM_SIZE
+#define FLASH0_BASE_S         QSPI_SRAM_BASE_S
+#define FLASH0_BASE_NS        QSPI_SRAM_BASE_NS
+#define FLASH0_SIZE           QSPI_SRAM_SIZE
 #define FLASH0_SECTOR_SIZE    0x00001000 /* 4 kB */
 #define FLASH0_PAGE_SIZE      0x00001000 /* 4 kB */
 #define FLASH0_PROGRAM_UNIT   0x1        /* Minimum write size */
diff --git a/lib/tf-m/bl2/ext/mcuboot/config/mcuboot-mbedtls-cfg.h b/lib/tf-m/bl2/ext/mcuboot/config/mcuboot-mbedtls-cfg.h
index 244a34b75c94afd7d50878c5a14804808c7f5a30..9c505e03300e25aa49d78ab9f324776f42aeb3a2 100644
--- a/lib/tf-m/bl2/ext/mcuboot/config/mcuboot-mbedtls-cfg.h
+++ b/lib/tf-m/bl2/ext/mcuboot/config/mcuboot-mbedtls-cfg.h
@@ -1,7 +1,7 @@
 /*
  *  Minimal configuration for using TLS in the bootloader
  *
- *  Copyright (C) 2006-2020, Arm Limited. All rights reserved.
+ *  Copyright (C) 2006-2021, Arm Limited. All rights reserved.
  *  Copyright (C) 2016, Linaro Ltd
  *
  *  SPDX-License-Identifier: Apache-2.0
@@ -56,6 +56,7 @@
 #define MBEDTLS_MD_C
 #define MBEDTLS_OID_C
 #define MBEDTLS_SHA256_C
+#define MBEDTLS_SHA224_C
 #define MBEDTLS_AES_C
 #define MBEDTLS_CIPHER_MODE_CTR
 
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.c
index 3153ba7c47be62fa0ff905783d3672b00efd1f01..46ba21c2b2967396adb82347d15fe2b28b848a07 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.c
@@ -1,7 +1,7 @@
 /*
  *  FIPS-180-2 compliant SHA-256 implementation
  *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  Copyright (C) 2006-2021, ARM Limited, All Rights Reserved
  *  Copyright (C) 2019, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -27,6 +27,7 @@
 
 /* Includes ------------------------------------------------------------------*/
 #include "mbedtls/sha256.h"
+#include "mbedtls/error.h"
 
 #if defined(MBEDTLS_SHA256_C)
 #if defined(MBEDTLS_SHA256_ALT)
@@ -86,7 +87,7 @@ void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
     *dst = *src;
 }
 
-int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
+int mbedtls_sha256_starts(mbedtls_sha256_context *ctx, int is224)
 {
     SHA256_VALIDATE_RET( ctx != NULL );
     SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );
@@ -102,7 +103,7 @@ int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
         return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
     }
 
-    ctx->is224 = is224;
+    ctx->MBEDTLS_PRIVATE(is224) = is224;
 
     /* first block on 17 words */
     ctx->first = ST_SHA256_EXTRA_BYTES;
@@ -127,7 +128,7 @@ int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx, const unsigned
     HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
 #endif /* ST_HW_CONTEXT_SAVING */
 
-    if (ctx->is224 == 0) {
+    if (ctx->MBEDTLS_PRIVATE(is224) == 0) {
         if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
             return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
         }
@@ -145,7 +146,7 @@ int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx, const unsigned
     return 0;
 }
 
-int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
+int mbedtls_sha256_update(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
 {
     size_t currentlen = ilen;
 
@@ -169,7 +170,7 @@ int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *
         memcpy(ctx->sbuf + ctx->sbuf_len, input, (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len));
         currentlen -= (ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len);
 
-        if (ctx->is224 == 0)
+        if (ctx->MBEDTLS_PRIVATE(is224) == 0)
         {
             if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE + ctx->first) != 0)
             {
@@ -188,7 +189,7 @@ int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *
         size_t iter = currentlen / ST_SHA256_BLOCK_SIZE;
         if (iter != 0)
         {
-            if (ctx->is224 == 0)
+            if (ctx->MBEDTLS_PRIVATE(is224) == 0)
             {
                 if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE + ctx->first - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
                 {
@@ -222,7 +223,7 @@ int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *
     return 0;
 }
 
-int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[32])
+int mbedtls_sha256_finish(mbedtls_sha256_context *ctx, unsigned char output[32])
 {
     SHA256_VALIDATE_RET( ctx != NULL );
     SHA256_VALIDATE_RET( (unsigned char *)output != NULL );
@@ -233,7 +234,7 @@ int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[
 #endif /* ST_HW_CONTEXT_SAVING */
 
     /* Last accumulation for pending bytes in sbuf_len, then trig processing and get digest */
-    if (ctx->is224 == 0)
+    if (ctx->MBEDTLS_PRIVATE(is224) == 0)
     {
         if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
         {
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
index 6318d0f808c8cc9142ebe01fe3b117c2f898a1b5..670aa48fb6bfd87ac0edc689f6a4ba46ac359700 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_cipher.c
@@ -355,8 +355,39 @@ psa_status_t tfm_crypto_cipher_encrypt(psa_invec in_vec[],
                                        psa_outvec out_vec[],
                                        size_t out_len)
 {
-    /* FixMe: To be implemented */
+#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
     return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status = PSA_SUCCESS;
+
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
+
+    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    uint8_t *output = out_vec[0].base;
+    size_t output_size = out_vec[0].len;
+    mbedtls_svc_key_id_t encoded_key;
+
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_cipher_encrypt(encoded_key, alg, input, input_length, output,
+                              output_size, &out_vec[0].len);
+#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
 }
 
 psa_status_t tfm_crypto_cipher_decrypt(psa_invec in_vec[],
@@ -364,7 +395,37 @@ psa_status_t tfm_crypto_cipher_decrypt(psa_invec in_vec[],
                                        psa_outvec out_vec[],
                                        size_t out_len)
 {
-    /* FixMe: To be implemented */
+#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
     return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status = PSA_SUCCESS;
+
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
+
+    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    uint8_t *output = out_vec[0].base;
+    size_t output_size = out_vec[0].len;
+    mbedtls_svc_key_id_t encoded_key;
+
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_cipher_decrypt(encoded_key, alg, input, input_length, output,
+                              output_size, &out_vec[0].len);
+#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
 }
 /*!@}*/
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/CMSIS_Driver/Config/RTE_Device.h b/lib/tf-m/platform/ext/target/cypress/psoc64/CMSIS_Driver/Config/RTE_Device.h
index 669a1706437f6a2d5053c760d1ef7a71b875e55d..c37a39f7dc052f1308690d07fb974748b61446fc 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/CMSIS_Driver/Config/RTE_Device.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/CMSIS_Driver/Config/RTE_Device.h
@@ -199,17 +199,17 @@
 
 // <e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_BOOT]
 // <i> Configuration settings for Driver_PPU_CRYPTO_BOOT in component ::Drivers:PPC
-#define   RTE_MS_PPU_CRYPTO_BOOT                    1
+#define   RTE_MS_PPU_CRYPTO_BOOT                    0
 // </e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_BOOT]
 
 // <e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_KEY0]
 // <i> Configuration settings for Driver_PPU_CRYPTO_KEY0 in component ::Drivers:PPC
-#define   RTE_MS_PPU_CRYPTO_KEY0                    1
+#define   RTE_MS_PPU_CRYPTO_KEY0                    0
 // </e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_KEY0]
 
 // <e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_KEY1]
 // <i> Configuration settings for Driver_PPU_CRYPTO_KEY1 in component ::Drivers:PPC
-#define   RTE_MS_PPU_CRYPTO_KEY1                    1
+#define   RTE_MS_PPU_CRYPTO_KEY1                    0
 // </e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_KEY1]
 
 // <e> PPC (Peripheral Protection Controller) [Driver_PPU_CRYPTO_BUF]
diff --git a/lib/tf-m/platform/ext/common/template/tfm_initial_attest_pub_key.c b/lib/tf-m/platform/ext/common/template/tfm_initial_attest_pub_key.c
index 6a664aeddf35e1495a61307d254be6ae14ff40d0..05cc4c426eb8ddb2490e18115419cb3a09a08d22 100644
--- a/lib/tf-m/platform/ext/common/template/tfm_initial_attest_pub_key.c
+++ b/lib/tf-m/platform/ext/common/template/tfm_initial_attest_pub_key.c
@@ -21,7 +21,7 @@
  */
 
 /* Type of the EC curve which the key belongs to, in PSA curve ID form */
-const psa_ecc_family_t initial_attest_curve_type = PSA_ECC_CURVE_SECP256R1;
+const psa_ecc_family_t initial_attest_curve_type = PSA_ECC_FAMILY_SECP_R1;
 
 /*
  * Initial attestation public key in raw format, without any encoding.
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
index e1ea32cdeb8b87e6ebcf3fbd3cc7071972a5763f..b0a498d52098b6908404a76b5df59a7330742678 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_core_svcalls_ipc.c
@@ -6,11 +6,13 @@
  */
 
 #include <string.h>
+#include "load/partition_defs.h"
 #include "region.h"
 #include "spm_ipc.h"
 #include "tfm_api.h"
 #include "tfm_arch.h"
 #include "tfm_core_trustzone.h"
+#include "tfm_core_utils.h"
 #include "tfm_svcalls.h"
 #include "utilities.h"
 #include "svc_num.h"
@@ -22,11 +24,21 @@
 REGION_DECLARE(Image$$, TFM_UNPRIV_CODE, $$RO$$Base);
 REGION_DECLARE(Image$$, TFM_UNPRIV_CODE, $$RO$$Limit);
 
+/* MSP bottom (higher address) */
+REGION_DECLARE(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit);
+
 #ifdef PLATFORM_SVC_HANDLERS
 extern int32_t platform_svc_handlers(uint8_t svc_num,
                                      uint32_t *ctx, uint32_t lr);
 #endif
 
+struct tfm_svc_flih_ctx_t {
+    uint32_t exc_ret;                      /* EXC_RETURN payload at SVC entry */
+    uint32_t psp;                          /* PSP value at SVC entry */
+    const struct partition_load_info_t *p_ldinf;/* Load info of IRQ Partition */
+    uint32_t signal;                       /* The IRQ signal */
+};
+
 static int32_t SVC_Handler_IPC(uint8_t svc_num, uint32_t *ctx,
                                uint32_t lr)
 {
@@ -111,6 +123,9 @@ static int32_t SVC_Handler_IPC(uint8_t svc_num, uint32_t *ctx,
         break;
     case TFM_SVC_PSA_IRQ_DISABLE:
         return tfm_spm_irq_disable(ctx);
+    case TFM_SVC_PSA_RESET_SIGNAL:
+        tfm_spm_psa_reset_signal(ctx);
+        break;
     default:
 #ifdef PLATFORM_SVC_HANDLERS
         return (platform_svc_handlers(svc_num, ctx, lr));
@@ -122,16 +137,115 @@ static int32_t SVC_Handler_IPC(uint8_t svc_num, uint32_t *ctx,
     return PSA_SUCCESS;
 }
 
+extern void tfm_flih_func_return(psa_flih_result_t result);
 
-uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
+/*
+ * Prepare execution context for deprivileged FLIH functions
+ * svc_args: IRQ owner Partition load info, flih_func, signal
+ */
+uint32_t tfm_flih_prepare_depriv_flih(uintptr_t ctx, uint32_t *svc_args)
 {
-    uint8_t svc_number = TFM_SVC_PSA_FRAMEWORK_VERSION;
-    uint32_t *svc_args = msp;
+    struct tfm_core_thread_t *irq_sp_thread;
+    struct partition_t *irq_sp, *curr_sp;
+    struct tfm_state_context_t *p_stat_ctx;
+    struct tfm_svc_flih_ctx_t *flih_ctx;
 
-    if (!(exc_return & EXC_RETURN_MODE)) {
-        /* Calling SVC from Handler Mode is not supported */
+    irq_sp = tfm_spm_get_partition_by_id(
+                            ((struct partition_load_info_t *)svc_args[0])->pid);
+
+    if (!irq_sp) {
         tfm_core_panic();
     }
+    irq_sp_thread = &irq_sp->sp_thread;
+
+    curr_sp = TO_CONTAINER(tfm_core_thrd_get_curr(),
+                           struct partition_t,
+                           sp_thread);
+
+    flih_ctx = (struct tfm_svc_flih_ctx_t *)ctx;
+    flih_ctx->signal = svc_args[2];
+    flih_ctx->p_ldinf = curr_sp->p_ldinf;
+
+    if (curr_sp == irq_sp) {
+        /*
+         * Either the Partition Thread or FLIH Function within the same
+         * Partition was preempted.
+         */
+        p_stat_ctx = (struct tfm_state_context_t *)flih_ctx->psp;
+    } else {
+        p_stat_ctx = (struct tfm_state_context_t *)irq_sp_thread->arch_ctx.sp;
+        tfm_core_thrd_set_curr(irq_sp_thread);
+        tfm_set_up_isolation_boundary(irq_sp);
+        tfm_arch_set_psplim(irq_sp_thread->stk_btm);
+    }
+
+    p_stat_ctx--;
+    if ((uintptr_t)p_stat_ctx < irq_sp_thread->stk_btm) {
+        tfm_core_panic();
+    }
+    spm_memset(p_stat_ctx, 0, sizeof(struct tfm_state_context_t));
+
+    p_stat_ctx->ra = (uint32_t)svc_args[1];
+    p_stat_ctx->lr = (uint32_t)tfm_flih_func_return;
+    p_stat_ctx->xpsr = XPSR_T32;
+
+    __set_PSP((uint32_t)p_stat_ctx);
+
+    return EXC_RETURN_THREAD_S_PSP;
+}
+
+/* Go back to ISR from FLIH functions */
+uint32_t tfm_flih_return_to_isr(uintptr_t ctx, psa_flih_result_t result)
+{
+    struct partition_t *curr_sp, *prev_sp;
+    struct tfm_svc_flih_ctx_t *flih_ctx;
+    uint32_t msp_top =
+                (uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit);
+
+    /* Skip one tfm_svc_flih_ctx_t + 8 words (R4- R11) + seals (2 words) */
+    flih_ctx = (struct tfm_svc_flih_ctx_t *)
+              (ctx + sizeof(struct tfm_svc_flih_ctx_t) + 10 * sizeof(uint32_t));
+    if ((uint32_t)flih_ctx > msp_top - TFM_STACK_SEALED_SIZE) {
+        tfm_core_panic();
+    }
+
+    curr_sp = TO_CONTAINER(tfm_core_thrd_get_curr(),
+                           struct partition_t,
+                           sp_thread);
+
+    prev_sp = tfm_spm_get_partition_by_id(flih_ctx->p_ldinf->pid);
+    if (!prev_sp) {
+        tfm_core_panic();
+    }
+
+    if (curr_sp != prev_sp) {
+        tfm_set_up_isolation_boundary(prev_sp);
+        tfm_core_thrd_set_curr(&(prev_sp->sp_thread));
+        tfm_arch_set_psplim(prev_sp->sp_thread.stk_btm);
+    }
+
+    __set_PSP(flih_ctx->psp);
+
+    if (result == PSA_FLIH_SIGNAL) {
+        notify_with_signal(curr_sp->p_ldinf->pid, flih_ctx->signal);
+    } else if (result != PSA_FLIH_NO_SIGNAL) {
+        /*
+         * Nothing needed to do for PSA_FLIH_NO_SIGNAL
+         * But if the flih_result is invalid, should panic.
+         */
+        tfm_core_panic();
+    }
+
+    return flih_ctx->exc_ret;
+}
+
+uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
+                              uint32_t *psp)
+{
+    uint8_t svc_number = TFM_SVC_PSA_FRAMEWORK_VERSION;
+    uint32_t *svc_args = msp;
+    uintptr_t flih_ctx =
+                 (uintptr_t)((uint32_t)msp - sizeof(struct tfm_svc_flih_ctx_t));
 
     if ((exc_return & EXC_RETURN_MODE) && (exc_return & EXC_RETURN_SPSEL)) {
         /* Use PSP when both EXC_RETURN.MODE and EXC_RETURN.SPSEL are set */
@@ -157,15 +271,31 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
          */
         tfm_core_panic();
     }
+
+    if (!(exc_return & EXC_RETURN_MODE)
+                                  != (svc_number > TFM_SVC_THREAD_NUMBER_END)) {
+        tfm_core_panic();
+    }
+
     switch (svc_number) {
     case TFM_SVC_SPM_INIT:
-        tfm_arch_clear_fp_status();
         exc_return = tfm_spm_init();
         break;
     case TFM_SVC_GET_BOOT_DATA:
         tfm_core_get_boot_data_handler(svc_args);
         break;
+    case TFM_SVC_PREPARE_DEPRIV_FLIH:
+        exc_return = tfm_flih_prepare_depriv_flih(flih_ctx, svc_args);
+        break;
+    case TFM_SVC_FLIH_FUNC_RETURN:
+        exc_return = tfm_flih_return_to_isr(flih_ctx, svc_args[0]);
+        break;
     default:
+        if (((uint32_t)&REGION_NAME(Image$$, ARM_LIB_STACK_MSP, $$ZI$$Limit)
+                                     - (uint32_t)msp) > TFM_STACK_SEALED_SIZE) {
+            /* The Main Stack has contents, not calling from Partition thread */
+            tfm_core_panic();
+        }
         svc_args[0] = SVC_Handler_IPC(svc_number, svc_args, exc_return);
         break;
     }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/arch.h b/lib/tf-m/secure_fw/spm/cmsis_func/arch.h
index 964ddf7f6aff3c71bc1405df0e548a80f5c47710..c483d7cfb05c3d784d267a546e24376d54989598 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/arch.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/arch.h
@@ -1,9 +1,11 @@
 /*
- * Copyright (c) 2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
  */
+#include <stdint.h>
+#include "tfm_api.h"
 
 #ifndef __ARCH_H__
 #define __ARCH_H__
@@ -24,4 +26,27 @@ extern nsfptr_t ns_entry;
  */
 void jump_to_ns_code(void);
 
+/**
+ * \brief Trigger EXC_RETURN
+ *
+ * \param[in] exc_return The EXC_RETURN value to initiate the return
+ *                       procedure
+ *
+ * \returns              Does not return
+ */
+void tfm_arch_trigger_exc_return(uint32_t exc_return);
+
+/**
+ * \brief Trigger an sfn request/return completion from Thread mode
+ *
+ * \param[in] res        The tfm_status_e return value to report back to SPM
+ * \param[in] exc_return The EXC_RETURN value to use to return from the original
+ *                       request/return
+ * \param[in] msp        The value of the top of the MSP to reset the MSP before
+ *                       trigger the TFM_SVC_SFN_COMPLETION
+ *
+ * \return               Does not return
+ */
+void tfm_sfn_completion(enum tfm_status_e res, uint32_t exc_return, uintptr_t msp);
+
 #endif /* __ARCH_H__ */
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_spe.h b/lib/tf-m/secure_fw/partitions/crypto/crypto_spe.h
index f80fd86bdc2780a34b93ec8b04a782069d2a3238..9308bbda0b629b5e2d0d46ae6950cc7b486381f9 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_spe.h
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_spe.h
@@ -82,6 +82,10 @@
         PSA_FUNCTION_NAME(psa_cipher_decrypt_setup)
 #define psa_cipher_update \
         PSA_FUNCTION_NAME(psa_cipher_update)
+#define psa_cipher_encrypt \
+        PSA_FUNCTION_NAME(psa_cipher_encrypt)
+#define psa_cipher_decrypt \
+        PSA_FUNCTION_NAME(psa_cipher_decrypt)
 #define psa_cipher_finish \
         PSA_FUNCTION_NAME(psa_cipher_finish)
 #define psa_cipher_abort \
@@ -116,8 +120,16 @@
         PSA_FUNCTION_NAME(psa_mac_sign_finish)
 #define psa_mac_verify_finish \
         PSA_FUNCTION_NAME(psa_mac_verify_finish)
+#define psa_mac_compute \
+        PSA_FUNCTION_NAME(psa_mac_compute)
+#define psa_mac_verify \
+        PSA_FUNCTION_NAME(psa_mac_verify)
 #define psa_mac_abort \
         PSA_FUNCTION_NAME(psa_mac_abort)
+#define psa_sign_message \
+        PSA_FUNCTION_NAME(psa_sign_message)
+#define psa_verify_message \
+        PSA_FUNCTION_NAME(psa_verify_message)
 #define psa_sign_hash \
         PSA_FUNCTION_NAME(psa_sign_hash)
 #define psa_verify_hash \
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.h b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.h
index 872d763a36ffb4d7c4d9d47c6910b3d4e48dfd5f..3c7b7cf3038489c8c2cf638b726d85b1b41fb850 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.h
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/sha256_alt.h
@@ -7,7 +7,7 @@
  * hash functions are defined in <em>FIPS 180-4: Secure Hash Standard (SHS)</em>.
  */
 /*
- *  Copyright (C) 2006-2018, Arm Limited (or its affiliates), All Rights Reserved
+ *  Copyright (C) 2006-2021, Arm Limited (or its affiliates), All Rights Reserved
  *  Copyright (C) 2019, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -47,7 +47,7 @@
  */
 typedef struct mbedtls_sha256_context
 {
-    int is224;                                      /*!< 0 = use SHA256, 1 = use SHA224 */
+    int MBEDTLS_PRIVATE(is224);                     /*!< 0 = use SHA256, 1 = use SHA224 */
     HASH_HandleTypeDef hhash;                       /*!< Handle of HASH HAL */
     uint8_t sbuf[ST_SHA256_BLOCK_SIZE + ST_SHA256_EXTRA_BYTES];
                                                     /*!< Buffer to store input data
@@ -62,4 +62,4 @@ mbedtls_sha256_context;
 
 
 #endif /* MBEDTLS_SHA256_ALT */
-#endif /* MBEDTLS_SHA256_ALT_H */
\ No newline at end of file
+#endif /* MBEDTLS_SHA256_ALT_H */
diff --git a/lib/tf-m/platform/ext/accelerator/cc312/mbedtls_accelerator_config.h b/lib/tf-m/platform/ext/accelerator/cc312/mbedtls_accelerator_config.h
index fc7f00d21585572a0b60e0f81b7114e1523a428a..beffcab02932618a1b15d7e86e4afd8441c26ee6 100644
--- a/lib/tf-m/platform/ext/accelerator/cc312/mbedtls_accelerator_config.h
+++ b/lib/tf-m/platform/ext/accelerator/cc312/mbedtls_accelerator_config.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -13,7 +13,7 @@ extern "C" {
 #endif /* __cplusplus */
 
 /* RNG Config */
-#undef MBEDTLS_TEST_NULL_ENTROPY
+#undef MBEDTLS_ENTROPY_NV_SEED
 #undef MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 #define MBEDTLS_PLATFORM_ENTROPY
diff --git a/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash_iap1.c b/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash_iap1.c
new file mode 100755
index 0000000000000000000000000000000000000000..178e6e0608a6cbb86c816ab53b186c3cd98655bb
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash_iap1.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright (c) 2013-2018 ARM Limited. All rights reserved.
+ * Copyright 2019-2020 NXP. All rights reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the License); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2019 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "Driver_Flash.h"
+#include "platform_base_address.h"
+#include "flash_layout.h"
+#include "fsl_iap.h"
+#include "log/tfm_log.h"
+
+#ifndef ARG_UNUSED
+#define ARG_UNUSED(arg)  ((void)arg)
+#endif
+
+/* Below CMDs apply to both C040HDATFC and C040HDFC flash */
+#define FLASH_CMD_INIT 0
+#define FLASH_CMD_READ_SINGLE_WORD 3
+
+/* INT_STATUS - Interrupt status bits - taken from LPC5588_cm33_core0.h */
+
+#define FLASH_INT_STATUS_OVL_MASK                (0x10U)
+
+/* Alignment macros - taken from bootloader_common.h */
+#ifndef ALIGN_DOWN
+#define ALIGN_DOWN(x, a) ((x) & -(a))
+#endif
+
+/* Flash property defines */
+
+/* Mask the number of bits required to select the 32-bit data word (DATAW) from the flash line */
+#define FLASH_DATAW_IDX_MAX 3    /* Max DATAW index, 3 for a 128-bit flash line, 7 for 256-bit. */
+
+#define FLASH_READMODE_REG          (FLASH->DATAW[0])
+#define FLASH_READMODE_ECC_MASK     (0x4U)
+#define FLASH_READMODE_ECC_SHIFT    (2U)
+#define FLASH_READMODE_ECC(x)       (((uint32_t)(((uint32_t)(x)) << FLASH_READMODE_ECC_SHIFT)) & FLASH_READMODE_ECC_MASK)
+#define FLASH_READMODE_MARGIN_MASK  (0xC00U)
+#define FLASH_READMODE_MARGIN_SHIFT (10U)
+#define FLASH_READMODE_MARGIN(x)    (((uint32_t)(((uint32_t)(x)) << FLASH_READMODE_MARGIN_SHIFT)) & FLASH_READMODE_MARGIN_MASK)
+#define FLASH_READMODE_DMACC_MASK   (0x8000U)
+#define FLASH_READMODE_DMACC_SHIFT  (15U)
+#define FLASH_READMODE_DMACC(x)     (((uint32_t)(((uint32_t)(x)) << FLASH_READMODE_DMACC_SHIFT)) & FLASH_READMODE_DMACC_MASK)
+
+/* Driver version */
+#define ARM_FLASH_DRV_VERSION    ARM_DRIVER_VERSION_MAJOR_MINOR(1, 0)
+
+/* ARM FLASH device structure */
+struct arm_flash_dev_t {
+    const uint32_t memory_base;   /*!< FLASH memory base address */
+    ARM_FLASH_INFO *data;         /*!< FLASH data */
+    flash_config_t flashInstance; /*!< FLASH config*/
+};
+
+/* Flash Status */
+static ARM_FLASH_STATUS FlashStatus = {0, 0, 0};
+
+/* Driver Version */
+static const ARM_DRIVER_VERSION DriverVersion = {
+    ARM_FLASH_API_VERSION,
+    ARM_FLASH_DRV_VERSION
+};
+
+/* Driver Capabilities */
+static const ARM_FLASH_CAPABILITIES DriverCapabilities = {
+    0, /* event_ready */
+    2, /* data_width = 0:8-bit, 1:16-bit, 2:32-bit */
+    1  /* erase_chip */
+};
+
+static ARM_FLASH_INFO ARM_FLASH0_DEV_DATA = {
+    .sector_info  = NULL,                  /* Uniform sector layout */
+    .sector_count = FLASH0_SIZE / FLASH0_PAGE_SIZE,
+    .sector_size  = FLASH0_PAGE_SIZE,
+    .page_size    = FLASH0_PAGE_SIZE,
+    .program_unit = FLASH0_PAGE_SIZE,
+    .erased_value = 0x00};
+
+static struct arm_flash_dev_t ARM_FLASH0_DEV = {
+#if (__DOMAIN_NS == 1)
+    .memory_base = FLASH0_BASE_NS,
+#else
+    .memory_base = FLASH0_BASE_S,
+#endif /* __DOMAIN_NS == 1 */
+    .data        = &(ARM_FLASH0_DEV_DATA)};
+
+struct arm_flash_dev_t *FLASH0_DEV = &ARM_FLASH0_DEV;
+
+/* Prototypes */
+
+/* Internal function Flash command sequence. Called by driver APIs only*/
+static status_t flash_command_sequence(flash_config_t *config);
+
+//static status_t FLASH_ReadInit(flash_config_t *config);
+static status_t FLASH_ReadData(flash_config_t *config, uint32_t start, uint8_t *dest, uint32_t lengthInBytes);
+static status_t FLASH_ReadSingleWord(flash_config_t *config, uint32_t start, uint32_t *readbackData);
+
+static bool is_range_valid(struct arm_flash_dev_t *flash_dev,
+                           uint32_t offset);
+static bool is_write_aligned(struct arm_flash_dev_t *flash_dev,
+                             uint32_t param);
+
+/* Functions */
+
+static ARM_DRIVER_VERSION ARM_Flash_GetVersion(void)
+{
+    return DriverVersion;
+}
+
+static ARM_FLASH_CAPABILITIES ARM_Flash_GetCapabilities(void)
+{
+    return DriverCapabilities;
+}
+
+static int32_t ARM_Flash_Initialize(ARM_Flash_SignalEvent_t cb_event)
+{
+    ARG_UNUSED(cb_event);
+    status_t status = kStatus_Success;
+
+    /* Call initialization from Flash API */
+    status = FLASH_Init(&FLASH0_DEV->flashInstance);
+
+    if(status != kStatus_Success){
+    	return ARM_DRIVER_ERROR;
+    }
+
+
+    /* Disable Error Detection functionality */
+    FLASH0_DEV->flashInstance.modeConfig.readSingleWord.readWithEccOff = 0x1;
+
+#if 0
+    /* Initialization of Flash by means of its registers to be able read data*/
+    if(FLASH_ReadInit(&FLASH0_DEV->flashInstance) != kStatus_Success){
+			return ARM_DRIVER_ERROR;
+    }
+#endif
+
+    return ARM_DRIVER_OK;
+}
+
+static int32_t ARM_Flash_Uninitialize(void)
+{
+    /* Nothing to be done */
+    return ARM_DRIVER_OK;
+}
+
+static int32_t ARM_Flash_PowerControl(ARM_POWER_STATE state)
+{
+    switch (state) {
+    case ARM_POWER_FULL:
+        /* Nothing to be done */
+        return ARM_DRIVER_OK;
+
+    case ARM_POWER_OFF:
+    case ARM_POWER_LOW:
+    default:
+        return ARM_DRIVER_ERROR_UNSUPPORTED;
+    }
+}
+
+static int32_t ARM_Flash_ReadData(uint32_t addr, void *data, uint32_t cnt)
+{
+    static uint32_t status;
+
+    /* Check Flash memory boundaries */
+    status = is_range_valid(FLASH0_DEV, addr + cnt);
+    if(status != kStatus_Success) {
+        return ARM_DRIVER_ERROR_PARAMETER;
+    }
+
+    /* Read Data */
+#if 1
+    if(cnt) {
+        status  = FLASH_ReadData(&FLASH0_DEV->flashInstance, addr, (uint8_t *)data, cnt);
+        if(status != kStatus_Success) {
+            return ARM_DRIVER_ERROR;
+        }
+    }
+#else /* Bus fault when reading erased memory */
+    (void)memcpy(data, (uint8_t *)addr, cnt);
+#endif
+    return ARM_DRIVER_OK;
+}
+
+static int32_t ARM_Flash_ProgramData(uint32_t addr, const void *data, uint32_t cnt)
+{
+    static uint32_t status;
+    uint32_t failedAddress, failedData;
+
+    /* Check Flash memory boundaries */
+    status = is_range_valid(FLASH0_DEV, addr);
+    status |= is_write_aligned(FLASH0_DEV, addr);
+    status |= is_write_aligned(FLASH0_DEV, cnt);
+    if(status != kStatus_Success) {
+        return ARM_DRIVER_ERROR_PARAMETER;
+    }
+
+    status = FLASH_Program(&FLASH0_DEV->flashInstance, addr, (uint8_t *)data, cnt);
+    if (status != kStatus_Success) {
+        return ARM_DRIVER_ERROR;
+    }
+
+    status = FLASH_VerifyProgram(&FLASH0_DEV->flashInstance, addr, cnt, (const uint8_t *)data,
+				 &failedAddress, &failedData);
+    if (status != kStatus_Success) {
+        return ARM_DRIVER_ERROR;
+    }
+
+    return ARM_DRIVER_OK;
+}
+
+static int32_t ARM_Flash_EraseSector(uint32_t addr)
+{
+    static uint32_t status;
+
+    status = is_range_valid(FLASH0_DEV, addr);
+    status |= is_write_aligned(FLASH0_DEV, addr);
+    if(status != kStatus_Success) {
+        return ARM_DRIVER_ERROR_PARAMETER;
+    }
+
+    status = FLASH_Erase(&FLASH0_DEV->flashInstance, addr, FLASH0_DEV->data->sector_size, kFLASH_ApiEraseKey);
+    if (status != kStatus_Success) {
+        return ARM_DRIVER_ERROR;
+    }
+
+    return ARM_DRIVER_OK;
+}
+
+static int32_t ARM_Flash_EraseChip(void)
+{
+    static uint32_t status;
+    uint32_t addr = FLASH0_DEV->memory_base;
+
+    status = FLASH_Erase(&FLASH0_DEV->flashInstance, addr, FLASH_TOTAL_SIZE, kFLASH_ApiEraseKey);
+    if (status != kStatus_Success)
+        return ARM_DRIVER_ERROR;
+
+    return ARM_DRIVER_OK;
+}
+
+static ARM_FLASH_STATUS ARM_Flash_GetStatus(void)
+{
+    return FlashStatus;
+}
+
+static ARM_FLASH_INFO * ARM_Flash_GetInfo(void)
+{
+    return FLASH0_DEV->data;
+}
+
+ARM_DRIVER_FLASH Driver_FLASH0 = {
+    ARM_Flash_GetVersion,
+    ARM_Flash_GetCapabilities,
+    ARM_Flash_Initialize,
+    ARM_Flash_Uninitialize,
+    ARM_Flash_PowerControl,
+    ARM_Flash_ReadData,
+    ARM_Flash_ProgramData,
+    ARM_Flash_EraseSector,
+    ARM_Flash_EraseChip,
+    ARM_Flash_GetStatus,
+    ARM_Flash_GetInfo
+};
+
+#if 0
+static status_t FLASH_ReadInit(flash_config_t *config)
+{
+    status_t status = kStatus_Fail;
+
+	    if (config == NULL)
+    {
+        return kStatus_FLASH_InvalidArgument;
+    }
+
+    /* config->PFlashTotalSize was initialized to 0xA0000 (640kB) by FLASH API.
+		   This value needs to be changed to 0x98000 (608kB)*/
+    config->PFlashTotalSize = FLASH_TOTAL_SIZE;
+
+    /* Immediately after leaving reset mode, an initialization phase takes place,
+       where some memory locations are read, and corresponding volatile locations
+       are initialized depending on the value just read. */
+    FLASH->INT_CLR_STATUS = FLASH_INT_CLR_STATUS_FAIL_MASK | FLASH_INT_CLR_STATUS_ERR_MASK | FLASH_INT_CLR_STATUS_ECC_ERR_MASK;
+    FLASH->CMD = FLASH_CMD_INIT;
+    status = flash_command_sequence(config);
+
+    if (kStatus_FLASH_Success != status)
+    {
+        return status;
+    }
+
+    return kStatus_FLASH_Success;
+}
+#endif
+
+static status_t FLASH_ReadData(flash_config_t *config, uint32_t start, uint8_t *dest, uint32_t lengthInBytes)
+{
+    status_t status = kStatus_Fail;
+
+    uint32_t readbackData[FLASH_DATAW_IDX_MAX + 1];
+    while (lengthInBytes)
+    {
+        uint32_t alignedStart = ALIGN_DOWN(start, (uint32_t)kFLASH_AlignementUnitSingleWordRead);
+        status = FLASH_ReadSingleWord(config, alignedStart, readbackData);
+        if (status != kStatus_FLASH_Success)
+        {
+            break;
+        }
+        for (uint32_t i = 0; i < sizeof(readbackData); i++)
+        {
+            if ((alignedStart == start) && lengthInBytes)
+            {
+                *dest = *((uint8_t *)readbackData + i);
+                dest++;
+                start++;
+                lengthInBytes--;
+            }
+            alignedStart++;
+        }
+    }
+
+    return status;
+}
+
+static status_t FLASH_ReadSingleWord(flash_config_t *config, uint32_t start, uint32_t *readbackData)
+{
+    status_t status = kStatus_Fail;
+
+    if (readbackData == NULL)
+    {
+        return kStatus_FLASH_InvalidArgument;
+    }
+
+    FLASH->INT_CLR_STATUS = FLASH_INT_CLR_STATUS_FAIL_MASK | FLASH_INT_CLR_STATUS_ERR_MASK |
+                            FLASH_INT_CLR_STATUS_DONE_MASK | FLASH_INT_CLR_STATUS_ECC_ERR_MASK;
+
+    /* Set start address */
+    FLASH->STARTA = start >> 4;
+
+    /* ReadSingleWord notes:
+    Flash contains one DMACC word per page. Such words are not readable through
+    the read interface. DMACC words are managed internally by the controller in
+    order to store a flag (all1), which can be used to verify whether a programming
+    operation was prematurely terminated.
+    DMACC words are all_0 for an erased page, all_1 for a programmed page */
+
+    /* Set read modes */
+    FLASH_READMODE_REG = FLASH_READMODE_ECC(config->modeConfig.readSingleWord.readWithEccOff) |
+                         FLASH_READMODE_MARGIN(config->modeConfig.readSingleWord.readMarginLevel) |
+                         FLASH_READMODE_DMACC(config->modeConfig.readSingleWord.readDmaccWord);
+
+    /* Calling flash command sequence function to execute the command */
+    FLASH->CMD = FLASH_CMD_READ_SINGLE_WORD;
+    status = flash_command_sequence(config);
+
+    if (kStatus_FLASH_Success == status)
+    {
+        for (uint32_t datawIndex = 0; datawIndex <= FLASH_DATAW_IDX_MAX; datawIndex++)
+        {
+            *readbackData++ = FLASH->DATAW[datawIndex];
+        }
+    }
+
+    return status;
+}
+
+/* This function is used to perform the command write sequence to the flash. */
+static status_t flash_command_sequence(flash_config_t *config)
+{
+    status_t status = kStatus_Fail;
+    uint32_t registerValue;
+
+    while (!(FLASH->INT_STATUS & FLASH_INT_STATUS_DONE_MASK))
+        ;
+
+    /* Check error bits */
+    /* Get flash status register value */
+    registerValue = FLASH->INT_STATUS;
+
+    /* Checking access error */
+    if (registerValue & FLASH_INT_STATUS_FAIL_MASK)
+    {
+        status = kStatus_FLASH_CommandFailure;
+    }
+    else if (registerValue & FLASH_INT_STATUS_ERR_MASK)
+    {
+        status = kStatus_FLASH_CommandNotSupported;
+    }
+    else if (registerValue & FLASH_INT_STATUS_ECC_ERR_MASK)
+    {
+        status = kStatus_FLASH_EccError;
+    }
+    else if (registerValue & FLASH_INT_STATUS_OVL_MASK)
+    {
+        status = kStatus_FLASH_RegulationLoss;
+    }
+    else
+    {
+        status = kStatus_FLASH_Success;
+    }
+
+    return status;
+}
+
+/* Check if the Flash memory boundaries are not violated. */
+static bool is_range_valid(struct arm_flash_dev_t *flash_dev,
+                           uint32_t offset)
+{
+
+    uint32_t flash_limit = FLASH_TOTAL_SIZE - 1;
+
+    return (offset > flash_limit) ? (kStatus_Fail) : (kStatus_Success) ;
+}
+
+/* Check if the parameter is aligned to program_unit. */
+static bool is_write_aligned(struct arm_flash_dev_t *flash_dev,
+                             uint32_t param)
+{
+    return ((param % flash_dev->data->program_unit) != 0) ? (kStatus_Fail) : (kStatus_Success);
+}
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_curves_alt.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_curves_alt.c
index b8e6b5c3aaaef18d52ff99ec1b7458c93f22ac7e..ad188d4bbef71f3b1cdcedd0e85ad566dcb7a806 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_curves_alt.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecp_curves_alt.c
@@ -1,7 +1,7 @@
 /*
  *  Elliptic curves over GF(p): curve-specific data and functions
  *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  Copyright (C) 2006-2021, ARM Limited, All Rights Reserved
  *  Copyright (C) 2019, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -568,9 +568,9 @@ static const mbedtls_mpi_uint brainpoolP512r1_n[] = {
  */
 static inline void ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size_t len )
 {
-    X->s = 1;
-    X->n = len / sizeof( mbedtls_mpi_uint );
-    X->p = (mbedtls_mpi_uint *) p;
+    X->MBEDTLS_PRIVATE(s) = 1;
+    X->MBEDTLS_PRIVATE(n) = len / sizeof( mbedtls_mpi_uint );
+    X->MBEDTLS_PRIVATE(p) = (mbedtls_mpi_uint *) p;
 }
 
 /*
@@ -579,9 +579,9 @@ static inline void ecp_mpi_load( mbedtls_mpi *X, const mbedtls_mpi_uint *p, size
 static inline void ecp_mpi_set1( mbedtls_mpi *X )
 {
     static mbedtls_mpi_uint one[] = { 1 };
-    X->s = 1;
-    X->n = 1;
-    X->p = one;
+    X->MBEDTLS_PRIVATE(s) = 1;
+    X->MBEDTLS_PRIVATE(n) = 1;
+    X->MBEDTLS_PRIVATE(p) = one;
 }
 
 /*
@@ -606,9 +606,9 @@ static int ecp_group_load( mbedtls_ecp_group *grp,
     ecp_mpi_load( &grp->B, b, blen );
     ecp_mpi_load( &grp->N, n, nlen );
 
-    ecp_mpi_load( &grp->G.X, gx, gxlen );
-    ecp_mpi_load( &grp->G.Y, gy, gylen );
-    ecp_mpi_set1( &grp->G.Z );
+    ecp_mpi_load( &grp->G.MBEDTLS_PRIVATE(X), gx, gxlen );
+    ecp_mpi_load( &grp->G.MBEDTLS_PRIVATE(Y), gy, gylen );
+    ecp_mpi_set1( &grp->G.MBEDTLS_PRIVATE(Z) );
 
     grp->pbits = mbedtls_mpi_bitlen( &grp->P );
     grp->nbits = mbedtls_mpi_bitlen( &grp->N );
@@ -628,7 +628,7 @@ static int ecp_group_load( mbedtls_ecp_group *grp,
     grp->st_a_abs = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
     MBEDTLS_MPI_CHK((grp->st_a_abs == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
 
-    if (grp->A.p == NULL)
+    if (grp->A.MBEDTLS_PRIVATE(p) == NULL)
     {
         /* NIST prime curves: A coef = -3 */
         mbedtls_platform_zeroize(grp->st_a_abs, grp->st_modulus_size);
@@ -649,11 +649,11 @@ static int ecp_group_load( mbedtls_ecp_group *grp,
 
     grp->st_gx = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
     MBEDTLS_MPI_CHK((grp->st_gx == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
-    mbedtls_mpi_write_binary(&grp->G.X, grp->st_gx, grp->st_modulus_size);
+    mbedtls_mpi_write_binary(&grp->G.MBEDTLS_PRIVATE(X), grp->st_gx, grp->st_modulus_size);
 
     grp->st_gy = mbedtls_calloc(grp->st_modulus_size, sizeof( uint8_t ));
     MBEDTLS_MPI_CHK((grp->st_gy == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
-    mbedtls_mpi_write_binary(&grp->G.Y, grp->st_gy, grp->st_modulus_size);
+    mbedtls_mpi_write_binary(&grp->G.MBEDTLS_PRIVATE(Y), grp->st_gy, grp->st_modulus_size);
 
     grp->st_n = mbedtls_calloc(grp->st_order_size, sizeof( uint8_t ));
     MBEDTLS_MPI_CHK((grp->st_n == NULL) ? MBEDTLS_ERR_ECP_ALLOC_FAILED : 0);
@@ -746,9 +746,9 @@ static int ecp_use_curve25519( mbedtls_ecp_group *grp )
 
     /* Y intentionally not set, since we use x/z coordinates.
      * This is used as a marker to identify Montgomery curves! */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 9 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );
-    mbedtls_mpi_free( &grp->G.Y );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.MBEDTLS_PRIVATE(X), 9 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.MBEDTLS_PRIVATE(Z), 1 ) );
+    mbedtls_mpi_free( &grp->G.MBEDTLS_PRIVATE(Y) );
 
     /* Actually, the required msb for private keys */
     grp->nbits = 254;
@@ -785,9 +785,9 @@ static int ecp_use_curve448( mbedtls_ecp_group *grp )
 
     /* Y intentionally not set, since we use x/z coordinates.
      * This is used as a marker to identify Montgomery curves! */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.X, 5 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.Z, 1 ) );
-    mbedtls_mpi_free( &grp->G.Y );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.MBEDTLS_PRIVATE(X), 5 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &grp->G.MBEDTLS_PRIVATE(Z), 1 ) );
+    mbedtls_mpi_free( &grp->G.MBEDTLS_PRIVATE(Y) );
 
     /* N = 2^446 - 13818066809895115352007386748515426880336692474882178609894547503885 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( &grp->N, 446, 1 ) );
@@ -949,7 +949,7 @@ static inline void carry64( mbedtls_mpi_uint *dst, mbedtls_mpi_uint *carry )
 }
 
 #define WIDTH       8 / sizeof( mbedtls_mpi_uint )
-#define A( i )      N->p + (i) * WIDTH
+#define A( i )      N->MBEDTLS_PRIVATE(p) + (i) * WIDTH
 #define ADD( i )    add64( p, A( i ), &c )
 #define NEXT        p += WIDTH; carry64( p, &c )
 #define LAST        p += WIDTH; *p = c; while( ++p < end ) *p = 0
@@ -966,8 +966,8 @@ static int ecp_mod_p192( mbedtls_mpi *N )
     /* Make sure we have enough blocks so that A(5) is legal */
     MBEDTLS_MPI_CHK( mbedtls_mpi_grow( N, 6 * WIDTH ) );
 
-    p = N->p;
-    end = p + N->n;
+    p = N->MBEDTLS_PRIVATE(p);
+    end = p + N->MBEDTLS_PRIVATE(n);
 
     ADD( 3 ); ADD( 5 );             NEXT; // A0 += A3 + A5
     ADD( 3 ); ADD( 4 ); ADD( 5 );   NEXT; // A1 += A3 + A4 + A5
@@ -1008,22 +1008,22 @@ cleanup:
 #if defined(MBEDTLS_HAVE_INT32)
 /* 32 bit */
 
-#define MAX32       N->n
-#define A( j )      N->p[j]
-#define STORE32     N->p[i] = cur;
+#define MAX32       N->MBEDTLS_PRIVATE(n)
+#define A( j )      N->MBEDTLS_PRIVATE(p)[j]
+#define STORE32     N->MBEDTLS_PRIVATE(p)[i] = cur;
 
 #else                               /* 64-bit */
 
-#define MAX32       N->n * 2
-#define A( j ) (j) % 2 ? (uint32_t)( N->p[(j)/2] >> 32 ) : \
-                         (uint32_t)( N->p[(j)/2] )
+#define MAX32       N->MBEDTLS_PRIVATE(n) * 2
+#define A( j ) (j) % 2 ? (uint32_t)( N->MBEDTLS_PRIVATE(p)[(j)/2] >> 32 ) : \
+                         (uint32_t)( N->MBEDTLS_PRIVATE(p)[(j)/2] )
 #define STORE32                                   \
     if( i % 2 ) {                                 \
-        N->p[i/2] &= 0x00000000FFFFFFFF;          \
-        N->p[i/2] |= ((mbedtls_mpi_uint) cur) << 32;        \
+        N->MBEDTLS_PRIVATE(p)[i/2] &= 0x00000000FFFFFFFF;          \
+        N->MBEDTLS_PRIVATE(p)[i/2] |= ((mbedtls_mpi_uint) cur) << 32;        \
     } else {                                      \
-        N->p[i/2] &= 0xFFFFFFFF00000000;          \
-        N->p[i/2] |= (mbedtls_mpi_uint) cur;                \
+        N->MBEDTLS_PRIVATE(p)[i/2] &= 0xFFFFFFFF00000000;          \
+        N->MBEDTLS_PRIVATE(p)[i/2] |= (mbedtls_mpi_uint) cur;                \
     }
 
 #endif /* sizeof( mbedtls_mpi_uint ) */
@@ -1058,10 +1058,10 @@ static inline void sub32( uint32_t *dst, uint32_t src, signed char *carry )
     mbedtls_mpi C;                                                      \
     mbedtls_mpi_uint Cp[ (b) / 8 / sizeof( mbedtls_mpi_uint) + 1 ];     \
                                                                         \
-    C.s = 1;                                                            \
-    C.n = (b) / 8 / sizeof( mbedtls_mpi_uint) + 1;                      \
-    C.p = Cp;                                                           \
-    memset( Cp, 0, C.n * sizeof( mbedtls_mpi_uint ) );                  \
+    C.MBEDTLS_PRIVATE(s) = 1;                                                            \
+    C.MBEDTLS_PRIVATE(n) = (b) / 8 / sizeof( mbedtls_mpi_uint) + 1;                      \
+    C.MBEDTLS_PRIVATE(p) = Cp;                                                           \
+    memset( Cp, 0, C.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );                  \
                                                                         \
     MBEDTLS_MPI_CHK( mbedtls_mpi_grow( N, (b) * 2 / 8 /                 \
                                        sizeof( mbedtls_mpi_uint ) ) );  \
@@ -1094,14 +1094,14 @@ static inline int fix_negative( mbedtls_mpi *N, signed char c, mbedtls_mpi *C, s
     ((void) bits);
 #else
     if( bits == 224 )
-        C->p[ C->n - 1 ] = ((mbedtls_mpi_uint) -c) << 32;
+        C->MBEDTLS_PRIVATE(p)[ C->MBEDTLS_PRIVATE(n) - 1 ] = ((mbedtls_mpi_uint) -c) << 32;
     else
 #endif
-        C->p[ C->n - 1 ] = (mbedtls_mpi_uint) -c;
+        C->MBEDTLS_PRIVATE(p)[ C->MBEDTLS_PRIVATE(n) - 1 ] = (mbedtls_mpi_uint) -c;
 
     /* N = - ( C - N ) */
     MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, C, N ) );
-    N->s = -1;
+    N->MBEDTLS_PRIVATE(s) = -1;
 
 cleanup:
 
@@ -1253,22 +1253,22 @@ static int ecp_mod_p521( mbedtls_mpi *N )
      * we need to hold bits 513 to 1056, which is 34 limbs, that is
      * P521_WIDTH + 1. Otherwise P521_WIDTH is enough. */
 
-    if( N->n < P521_WIDTH )
+    if( N->MBEDTLS_PRIVATE(n) < P521_WIDTH )
         return( 0 );
 
     /* M = A1 */
-    M.s = 1;
-    M.n = N->n - ( P521_WIDTH - 1 );
-    if( M.n > P521_WIDTH + 1 )
-        M.n = P521_WIDTH + 1;
-    M.p = Mp;
-    memcpy( Mp, N->p + P521_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
+    M.MBEDTLS_PRIVATE(s) = 1;
+    M.MBEDTLS_PRIVATE(n) = N->MBEDTLS_PRIVATE(n) - ( P521_WIDTH - 1 );
+    if( M.MBEDTLS_PRIVATE(n) > P521_WIDTH + 1 )
+        M.MBEDTLS_PRIVATE(n) = P521_WIDTH + 1;
+    M.MBEDTLS_PRIVATE(p) = Mp;
+    memcpy( Mp, N->MBEDTLS_PRIVATE(p) + P521_WIDTH - 1, M.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 521 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );
 
     /* N = A0 */
-    N->p[P521_WIDTH - 1] &= P521_MASK;
-    for( i = P521_WIDTH; i < N->n; i++ )
-        N->p[i] = 0;
+    N->MBEDTLS_PRIVATE(p)[P521_WIDTH - 1] &= P521_MASK;
+    for( i = P521_WIDTH; i < N->MBEDTLS_PRIVATE(n); i++ )
+        N->MBEDTLS_PRIVATE(p)[i] = 0;
 
     /* N = A0 + A1 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( N, N, &M ) );
@@ -1299,24 +1299,24 @@ static int ecp_mod_p255( mbedtls_mpi *N )
     mbedtls_mpi M;
     mbedtls_mpi_uint Mp[P255_WIDTH + 2];
 
-    if( N->n < P255_WIDTH )
+    if( N->MBEDTLS_PRIVATE(n) < P255_WIDTH )
         return( 0 );
 
     /* M = A1 */
-    M.s = 1;
-    M.n = N->n - ( P255_WIDTH - 1 );
-    if( M.n > P255_WIDTH + 1 )
+    M.MBEDTLS_PRIVATE(s) = 1;
+    M.MBEDTLS_PRIVATE(n) = N->MBEDTLS_PRIVATE(n) - ( P255_WIDTH - 1 );
+    if( M.MBEDTLS_PRIVATE(n) > P255_WIDTH + 1 )
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
-    M.p = Mp;
+    M.MBEDTLS_PRIVATE(p) = Mp;
     memset( Mp, 0, sizeof Mp );
-    memcpy( Mp, N->p + P255_WIDTH - 1, M.n * sizeof( mbedtls_mpi_uint ) );
+    memcpy( Mp, N->MBEDTLS_PRIVATE(p) + P255_WIDTH - 1, M.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, 255 % ( 8 * sizeof( mbedtls_mpi_uint ) ) ) );
-    M.n++; /* Make room for multiplication by 19 */
+    M.MBEDTLS_PRIVATE(n)++; /* Make room for multiplication by 19 */
 
     /* N = A0 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( N, 255, 0 ) );
-    for( i = P255_WIDTH; i < N->n; i++ )
-        N->p[i] = 0;
+    for( i = P255_WIDTH; i < N->MBEDTLS_PRIVATE(n); i++ )
+        N->MBEDTLS_PRIVATE(p)[i] = 0;
 
     /* N = A0 + 19 * A1 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M, &M, 19 ) );
@@ -1356,29 +1356,29 @@ static int ecp_mod_p448( mbedtls_mpi *N )
     mbedtls_mpi M, Q;
     mbedtls_mpi_uint Mp[P448_WIDTH + 1], Qp[P448_WIDTH];
 
-    if( N->n <= P448_WIDTH )
+    if( N->MBEDTLS_PRIVATE(n) <= P448_WIDTH )
         return( 0 );
 
     /* M = A1 */
-    M.s = 1;
-    M.n = N->n - ( P448_WIDTH );
-    if( M.n > P448_WIDTH )
+    M.MBEDTLS_PRIVATE(s) = 1;
+    M.MBEDTLS_PRIVATE(n) = N->MBEDTLS_PRIVATE(n) - ( P448_WIDTH );
+    if( M.MBEDTLS_PRIVATE(n) > P448_WIDTH )
         /* Shouldn't be called with N larger than 2^896! */
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
-    M.p = Mp;
+    M.MBEDTLS_PRIVATE(p) = Mp;
     memset( Mp, 0, sizeof( Mp ) );
-    memcpy( Mp, N->p + P448_WIDTH, M.n * sizeof( mbedtls_mpi_uint ) );
+    memcpy( Mp, N->MBEDTLS_PRIVATE(p) + P448_WIDTH, M.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );
 
     /* N = A0 */
-    for( i = P448_WIDTH; i < N->n; i++ )
-        N->p[i] = 0;
+    for( i = P448_WIDTH; i < N->MBEDTLS_PRIVATE(n); i++ )
+        N->MBEDTLS_PRIVATE(p)[i] = 0;
 
     /* N += A1 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &M ) );
 
     /* Q = B1, N += B1 */
     Q = M;
-    Q.p = Qp;
+    Q.MBEDTLS_PRIVATE(p) = Qp;
     memcpy( Qp, Mp, sizeof( Qp ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Q, 224 ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &Q ) );
@@ -1386,10 +1386,10 @@ static int ecp_mod_p448( mbedtls_mpi *N )
     /* M = (B0 + B1) * 2^224, N += M */
     if( sizeof( mbedtls_mpi_uint ) > 4 )
         Mp[P224_WIDTH_MIN] &= ( (mbedtls_mpi_uint)-1 ) >> ( P224_UNUSED_BITS );
-    for( i = P224_WIDTH_MAX; i < M.n; ++i )
+    for( i = P224_WIDTH_MAX; i < M.MBEDTLS_PRIVATE(n); ++i )
         Mp[i] = 0;
     MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M, &M, &Q ) );
-    M.n = P448_WIDTH + 1; /* Make room for shifted carry bit from the addition */
+    M.MBEDTLS_PRIVATE(n) = P448_WIDTH + 1; /* Make room for shifted carry bit from the addition */
     MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &M, 224 ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &M ) );
 
@@ -1418,33 +1418,33 @@ static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t
     mbedtls_mpi M, R;
     mbedtls_mpi_uint Mp[P_KOBLITZ_MAX + P_KOBLITZ_R + 1];
 
-    if( N->n < p_limbs )
+    if( N->MBEDTLS_PRIVATE(n) < p_limbs )
         return( 0 );
 
     /* Init R */
-    R.s = 1;
-    R.p = Rp;
-    R.n = P_KOBLITZ_R;
+    R.MBEDTLS_PRIVATE(s) = 1;
+    R.MBEDTLS_PRIVATE(p) = Rp;
+    R.MBEDTLS_PRIVATE(n) = P_KOBLITZ_R;
 
     /* Common setup for M */
-    M.s = 1;
-    M.p = Mp;
+    M.MBEDTLS_PRIVATE(s) = 1;
+    M.MBEDTLS_PRIVATE(p) = Mp;
 
     /* M = A1 */
-    M.n = N->n - ( p_limbs - adjust );
-    if( M.n > p_limbs + adjust )
-        M.n = p_limbs + adjust;
+    M.MBEDTLS_PRIVATE(n) = N->MBEDTLS_PRIVATE(n) - ( p_limbs - adjust );
+    if( M.MBEDTLS_PRIVATE(n) > p_limbs + adjust )
+        M.MBEDTLS_PRIVATE(n) = p_limbs + adjust;
     memset( Mp, 0, sizeof Mp );
-    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
+    memcpy( Mp, N->MBEDTLS_PRIVATE(p) + p_limbs - adjust, M.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );
     if( shift != 0 )
         MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
-    M.n += R.n; /* Make room for multiplication by R */
+    M.MBEDTLS_PRIVATE(n) += R.MBEDTLS_PRIVATE(n); /* Make room for multiplication by R */
 
     /* N = A0 */
     if( mask != 0 )
-        N->p[p_limbs - 1] &= mask;
-    for( i = p_limbs; i < N->n; i++ )
-        N->p[i] = 0;
+        N->MBEDTLS_PRIVATE(p)[p_limbs - 1] &= mask;
+    for( i = p_limbs; i < N->MBEDTLS_PRIVATE(n); i++ )
+        N->MBEDTLS_PRIVATE(p)[i] = 0;
 
     /* N = A0 + R * A1 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
@@ -1453,20 +1453,20 @@ static inline int ecp_mod_koblitz( mbedtls_mpi *N, mbedtls_mpi_uint *Rp, size_t
     /* Second pass */
 
     /* M = A1 */
-    M.n = N->n - ( p_limbs - adjust );
-    if( M.n > p_limbs + adjust )
-        M.n = p_limbs + adjust;
+    M.MBEDTLS_PRIVATE(n) = N->MBEDTLS_PRIVATE(n) - ( p_limbs - adjust );
+    if( M.MBEDTLS_PRIVATE(n) > p_limbs + adjust )
+        M.MBEDTLS_PRIVATE(n) = p_limbs + adjust;
     memset( Mp, 0, sizeof Mp );
-    memcpy( Mp, N->p + p_limbs - adjust, M.n * sizeof( mbedtls_mpi_uint ) );
+    memcpy( Mp, N->MBEDTLS_PRIVATE(p) + p_limbs - adjust, M.MBEDTLS_PRIVATE(n) * sizeof( mbedtls_mpi_uint ) );
     if( shift != 0 )
         MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &M, shift ) );
-    M.n += R.n; /* Make room for multiplication by R */
+    M.MBEDTLS_PRIVATE(n) += R.MBEDTLS_PRIVATE(n); /* Make room for multiplication by R */
 
     /* N = A0 */
     if( mask != 0 )
-        N->p[p_limbs - 1] &= mask;
-    for( i = p_limbs; i < N->n; i++ )
-        N->p[i] = 0;
+        N->MBEDTLS_PRIVATE(p)[p_limbs - 1] &= mask;
+    for( i = p_limbs; i < N->MBEDTLS_PRIVATE(n); i++ )
+        N->MBEDTLS_PRIVATE(p)[i] = 0;
 
     /* N = A0 + R * A1 */
     MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &M, &M, &R ) );
diff --git a/lib/tf-m/interface/src/psa/psa_service.c b/lib/tf-m/interface/src/psa/psa_service.c
index a8ecef426f2be347d7df895aeae77035c4c798e9..211c36fe56188978aabbe2f8ffd43cddb6c3c368 100644
--- a/lib/tf-m/interface/src/psa/psa_service.c
+++ b/lib/tf-m/interface/src/psa/psa_service.c
@@ -119,3 +119,11 @@ psa_irq_status_t psa_irq_disable(psa_signal_t irq_signal)
                    "BX LR            \n"
                    : : "I" (TFM_SVC_PSA_IRQ_DISABLE));
 }
+
+__attribute__((naked))
+void psa_reset_signal(psa_signal_t irq_signal)
+{
+    __ASM volatile("SVC %0           \n"
+                   "BX LR            \n"
+                   : : "I" (TFM_SVC_PSA_RESET_SIGNAL));
+}
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
index e7dd252e7a7e11ba1326aa9c96a8bfae83818e26..e600f9dcff6d5608cadb53120a89a91ab9755e9c 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_table.c
@@ -71,6 +71,8 @@ struct ps_obj_table_t {
                                                              */
 };
 
+static uint8_t ps_table_key_label[] = "table_key_label";
+
 /* Object table indexes */
 #define PS_OBJ_TABLE_IDX_0 0
 #define PS_OBJ_TABLE_IDX_1 1
@@ -546,7 +548,7 @@ static psa_status_t ps_object_table_save_table(
 
 #ifdef PS_ENCRYPTION
     /* Set object table key */
-    err = ps_crypto_setkey();
+    err = ps_crypto_setkey(ps_table_key_label, sizeof(ps_table_key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
@@ -844,7 +846,7 @@ psa_status_t ps_object_table_init(uint8_t *obj_data)
 
 #ifdef PS_ENCRYPTION
     /* Set object table key */
-    err = ps_crypto_setkey();
+    err = ps_crypto_setkey(ps_table_key_label, sizeof(ps_table_key_label));
     if (err != PSA_SUCCESS) {
         return err;
     }
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.h b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.h
index ae9855ef62f8687d9b59ecd0ff118653266ceceb..9b829a356d807f987bb34d2cb364acd372ebbf09 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2019, Arm Limited. All rights reserved.
- * Copyright (c) 2019, Cypress Semiconductor Corporation. All rights reserved
+ * Copyright (c) 2019, 2021, Cypress Semiconductor Corporation. All rights reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -93,12 +93,4 @@ int platform_mailbox_send_msg_data(uint32_t data);
  */
 void platform_mailbox_wait_for_notify(void);
 
-/**
- * \brief IPC initialization
- *
- * \retval 0               The operation succeeds.
- * \retval else            The operation fails.
- */
-int platform_ns_ipc_init(void);
-
 #endif
diff --git a/lib/tf-m/interface/include/psa/service.h b/lib/tf-m/interface/include/psa/service.h
index 8cd6556a439e17a283bae2d0e187c632901ad8dc..12efd2e7384e229a645b1d5b15bd0cc3e1ab16e4 100644
--- a/lib/tf-m/interface/include/psa/service.h
+++ b/lib/tf-m/interface/include/psa/service.h
@@ -46,12 +46,19 @@ extern "C" {
 /* An IPC message type that indicates the end of a connection. */
 #define PSA_IPC_DISCONNECT      (-2)
 
+/* FLIH return types */
+#define PSA_FLIH_NO_SIGNAL      ((psa_flih_result_t) 0)
+#define PSA_FLIH_SIGNAL         ((psa_flih_result_t) 1)
+
 /* Store a set of one or more Secure Partition signals */
 typedef uint32_t psa_signal_t;
 
 /* A type used to temporarily store a previous interrupt state. */
 typedef uint32_t psa_irq_status_t;
 
+/* The type of the return value from an FLIH function */
+typedef uint32_t psa_flih_result_t;
+
 /**
  * Describe a message received by an RoT Service after calling \ref psa_get().
  */
@@ -252,6 +259,7 @@ void psa_clear(void);
  * \arg                           irq_signal is not an interrupt signal.
  * \arg                           irq_signal indicates more than one signal.
  * \arg                           irq_signal is not currently asserted.
+ * \arg                           The interrupt is not using SLIH.
  */
 void psa_eoi(psa_signal_t irq_signal);
 
@@ -273,8 +281,8 @@ void psa_panic(void);
  *
  * \retval void
  * \retval "PROGRAMMER ERROR" If one or more of the following are true:
- *                            \ref irq_signal is not an interrupt signal.
- *                            \ref irq_signal indicates more than one signal.
+ * \arg                       \a irq_signal is not an interrupt signal.
+ * \arg                       \a irq_signal indicates more than one signal.
  */
 void psa_irq_enable(psa_signal_t irq_signal);
 
@@ -290,13 +298,31 @@ void psa_irq_enable(psa_signal_t irq_signal);
  * \retval 0                  The interrupt was disabled prior to this call.
  *         1                  The interrupt was enabled prior to this call.
  * \retval "PROGRAMMER ERROR" If one or more of the following are true:
- *                            \ref irq_signal is not an interrupt signal.
- *                            \ref irq_signal indicates more than one signal.
+ * \arg                       \a irq_signal is not an interrupt signal.
+ * \arg                       \a irq_signal indicates more than one signal.
  *
  * \note The current implementation always return 1. Do not use the return.
  */
 psa_irq_status_t psa_irq_disable(psa_signal_t irq_signal);
 
+/**
+ * \brief Reset the signal for an interrupt that is using FLIH handling.
+ *
+ * \param[in] irq_signal    The interrupt signal to be reset.
+ *                          This must have a single bit set, corresponding to a
+ *                          currently asserted signal for an interrupt that is
+ *                          defined to use FLIH handling.
+ *
+ * \retval void
+ * \retval "Programmer Error" if one or more of the following are true:
+ * \arg                       \a irq_signal is not a signal for an interrupt
+ *                            that is specified with FLIH handling in the Secure
+ *                            Partition manifest.
+ * \arg                       \a irq_signal indicates more than one signal.
+ * \arg                       \a irq_signal is not currently asserted.
+ */
+void psa_reset_signal(psa_signal_t irq_signal);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/lib/ext/t_cose/src/t_cose_crypto.h b/lib/tf-m/lib/ext/t_cose/src/t_cose_crypto.h
index 019f909f3bfe91ba0832c3bd792574b06db666d7..d068fc206d06f9ba0e5c110aac7b38afe899d41b 100644
--- a/lib/tf-m/lib/ext/t_cose/src/t_cose_crypto.h
+++ b/lib/tf-m/lib/ext/t_cose/src/t_cose_crypto.h
@@ -2,7 +2,7 @@
  * t_cose_crypto.h
  *
  * Copyright 2019, Laurence Lundblade
- * Copyright (c) 2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -194,7 +194,7 @@ t_cose_crypto_sig_size(int32_t            cose_algorithm_id,
  * \retval T_COSE_ERR_FAIL
  *         General unspecific failure.
  * \retval T_COSE_ERR_TAMPERING_DETECTED
- *         Equivalent to \c PSA_ERROR_TAMPERING_DETECTED.
+ *         Equivalent to \c PSA_ERROR_CORRUPTION_DETECTED.
  *
  * This is called to do public key signing. The implementation will
  * vary from one platform / OS to another but should conform to the
@@ -268,7 +268,7 @@ t_cose_crypto_pub_key_sign(int32_t                cose_algorithm_id,
  * \retval T_COSE_ERR_FAIL
  *         General unspecific failure.
  * \retval T_COSE_ERR_TAMPERING_DETECTED
- *         Equivalent to \c PSA_ERROR_TAMPERING_DETECTED.
+ *         Equivalent to \c PSA_ERROR_CORRUPTION_DETECTED.
  */
 enum t_cose_err_t
 t_cose_crypto_pub_key_verify(int32_t               cose_algorithm_id,
diff --git a/lib/tf-m/secure_fw/partitions/ns_proxy_partition/load_info_ns_proxy.c b/lib/tf-m/secure_fw/partitions/ns_proxy_partition/load_info_ns_proxy.c
index b099dc4a84aeac4475e749fdb5dbf8c4f0b78a52..85e6387a5a2971e0eb431d34511c993385c5b89b 100644
--- a/lib/tf-m/secure_fw/partitions/ns_proxy_partition/load_info_ns_proxy.c
+++ b/lib/tf-m/secure_fw/partitions/ns_proxy_partition/load_info_ns_proxy.c
@@ -11,12 +11,11 @@
 #include <stddef.h>
 #include "region.h"
 #include "region_defs.h"
+#include "spm_ipc.h"
 #include "spm_partition_defs.h"
 #include "load/partition_defs.h"
 #include "load/service_defs.h"
 #include "load/asset_defs.h"
-#include "psa_manifest/pid.h"
-#include "psa_manifest/sid.h"
 
 #define TFM_SP_NS_PROXY_NDEPS                                   (0)
 #define TFM_SP_NS_PROXY_NSERVS                                  (0)
@@ -48,7 +47,8 @@ const struct partition_tfm_sp_ns_proxy_load_info_t
     .load_info = {
         .psa_ff_ver                 = 0x0100 | PARTITION_INFO_MAGIC,
         .pid                        = TFM_SP_NON_SECURE_ID,
-        .flags                      = PARTITION_PRI_LOWEST | SPM_PART_FLAG_IPC
+        .flags                      = (PARTITION_PRI_LOWEST - 1)
+                                                             | SPM_PART_FLAG_IPC
 #if TFM_MULTI_CORE_TOPOLOGY
                                     | SPM_PART_FLAG_PSA_ROT
 #endif
@@ -62,15 +62,22 @@ const struct partition_tfm_sp_ns_proxy_load_info_t
         .nassets                    = TFM_SP_NS_PROXY_NASSETS,
 #endif
     },
-    .stack_addr                     = PART_REGION_ADDR(ARM_LIB_STACK, $$ZI$$Base),
+    .stack_addr                     = PART_REGION_ADDR(ARM_LIB_STACK,
+                                                                    $$ZI$$Base),
     .heap_addr                      = 0,
 #if TFM_LVL == 3
     .assets                         = {
         {
-            .mem.addr_x             = PART_REGION_ADDR(ARM_LIB_STACK, $$ZI$$Base),
-            .mem.addr_y             = PART_REGION_ADDR(ARM_LIB_STACK, $$ZI$$Limit),
+            .mem.addr_x             = PART_REGION_ADDR(ARM_LIB_STACK,
+                                                                    $$ZI$$Base),
+            .mem.addr_y             = PART_REGION_ADDR(ARM_LIB_STACK,
+                                                                   $$ZI$$Limit),
             .attr                   = ASSET_MEM_RD_BIT | ASSET_MEM_WR_BIT,
         },
     },
 #endif
 };
+
+/* Placeholder for partition runtime space. Do not reference it. */
+static struct partition_t tfm_sp_ns_proxy_partition_runtime_item
+    __attribute__((used, section(".bss.part_runtime")));
diff --git a/lib/tf-m/interface/include/psa/crypto.h b/lib/tf-m/interface/include/psa/crypto.h
index 0099baab7d950fb1fb66d0e285af0219322ffa74..5ccc5e7889d2e1c588b5340e42f5478deb5aec74 100644
--- a/lib/tf-m/interface/include/psa/crypto.h
+++ b/lib/tf-m/interface/include/psa/crypto.h
@@ -95,18 +95,6 @@ psa_status_t psa_crypto_init(void);
  * @{
  */
 
-/** \def PSA_KEY_ATTRIBUTES_INIT
- *
- * This macro returns a suitable initializer for a key attribute structure
- * of type #psa_key_attributes_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_KEY_ATTRIBUTES_INIT {0}
-#endif
-
 /** Return an initial value for a key attributes structure.
  */
 static psa_key_attributes_t psa_key_attributes_init(void);
@@ -677,6 +665,8 @@ psa_status_t psa_import_key(const psa_key_attributes_t *attributes,
  *   For Weierstrass curves, this is the content of the `privateKey` field of
  *   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,
  *   the format is defined by RFC 7748, and output is masked according to 5.
+ *   For twisted Edwards curves, the private key is as defined by RFC 8032
+ *   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
  * - For Diffie-Hellman key exchange key pairs (key types for which
  *   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the
  *   format is the representation of the private key `x` as a big-endian byte
@@ -742,7 +732,12 @@ psa_status_t psa_export_key(psa_key_id_t key,
  *      modulus            INTEGER,    -- n
  *      publicExponent     INTEGER  }  -- e
  *   ```
- * - For elliptic curve public keys (key types for which
+ * - For elliptic curve keys on a twisted Edwards curve (key types for which
+ *   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY
+ *   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined
+ *   by RFC 8032
+ *   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).
+ * - For other elliptic curve public keys (key types for which
  *   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed
  *   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.
  *   Let `m` be the bit size associated with the curve, i.e. the bit size of
@@ -899,22 +894,10 @@ psa_status_t psa_hash_compare(psa_algorithm_t alg,
  *   \endcode
  *
  * This is an implementation-defined \c struct. Applications should not
- * make any assumptions about the content of this structure except
- * as directed by the documentation of a specific implementation. */
+ * make any assumptions about the content of this structure.
+ * Implementation details can change in future versions without notice. */
 typedef struct psa_hash_operation_s psa_hash_operation_t;
 
-/** \def PSA_HASH_OPERATION_INIT
- *
- * This macro returns a suitable initializer for a hash operation object
- * of type #psa_hash_operation_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_HASH_OPERATION_INIT {0}
-#endif
-
 /** Return an initial value for a hash operation object.
  */
 static psa_hash_operation_t psa_hash_operation_init(void);
@@ -1268,23 +1251,12 @@ psa_status_t psa_mac_verify(psa_key_id_t key,
  *   operation = psa_mac_operation_init();
  *   \endcode
  *
+ *
  * This is an implementation-defined \c struct. Applications should not
- * make any assumptions about the content of this structure except
- * as directed by the documentation of a specific implementation. */
+ * make any assumptions about the content of this structure.
+ * Implementation details can change in future versions without notice. */
 typedef struct psa_mac_operation_s psa_mac_operation_t;
 
-/** \def PSA_MAC_OPERATION_INIT
- *
- * This macro returns a suitable initializer for a MAC operation object of type
- * #psa_mac_operation_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_MAC_OPERATION_INIT {0}
-#endif
-
 /** Return an initial value for a MAC operation object.
  */
 static psa_mac_operation_t psa_mac_operation_init(void);
@@ -1693,22 +1665,10 @@ psa_status_t psa_cipher_decrypt(psa_key_id_t key,
  *   \endcode
  *
  * This is an implementation-defined \c struct. Applications should not
- * make any assumptions about the content of this structure except
- * as directed by the documentation of a specific implementation. */
+ * make any assumptions about the content of this structure.
+ * Implementation details can change in future versions without notice. */
 typedef struct psa_cipher_operation_s psa_cipher_operation_t;
 
-/** \def PSA_CIPHER_OPERATION_INIT
- *
- * This macro returns a suitable initializer for a cipher operation object of
- * type #psa_cipher_operation_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_CIPHER_OPERATION_INIT {0}
-#endif
-
 /** Return an initial value for a cipher operation object.
  */
 static psa_cipher_operation_t psa_cipher_operation_init(void);
@@ -2074,9 +2034,16 @@ psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation);
  *                                authentication tag is appended to the
  *                                encrypted data.
  * \param ciphertext_size         Size of the \p ciphertext buffer in bytes.
- *                                This must be at least
- *                                #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\p alg,
- *                                \p plaintext_length).
+ *                                This must be appropriate for the selected
+ *                                algorithm and key:
+ *                                - A sufficient output size is
+ *                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type,
+ *                                  \p alg, \p plaintext_length) where
+ *                                  \c key_type is the type of \p key.
+ *                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p
+ *                                  plaintext_length) evaluates to the maximum
+ *                                  ciphertext size of any supported AEAD
+ *                                  encryption.
  * \param[out] ciphertext_length  On success, the size of the output
  *                                in the \p ciphertext buffer.
  *
@@ -2090,7 +2057,11 @@ psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation);
  *         \p alg is not supported or is not an AEAD algorithm.
  * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
  * \retval #PSA_ERROR_BUFFER_TOO_SMALL
- *         \p ciphertext_size is too small
+ *         \p ciphertext_size is too small.
+ *         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\c key_type, \p alg,
+ *         \p plaintext_length) or
+ *         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p plaintext_length) can be used to
+ *         determine the required buffer size.
  * \retval #PSA_ERROR_COMMUNICATION_FAILURE
  * \retval #PSA_ERROR_HARDWARE_FAILURE
  * \retval #PSA_ERROR_CORRUPTION_DETECTED
@@ -2134,9 +2105,16 @@ psa_status_t psa_aead_encrypt(psa_key_id_t key,
  * \param ciphertext_length       Size of \p ciphertext in bytes.
  * \param[out] plaintext          Output buffer for the decrypted data.
  * \param plaintext_size          Size of the \p plaintext buffer in bytes.
- *                                This must be at least
- *                                #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\p alg,
- *                                \p ciphertext_length).
+ *                                This must be appropriate for the selected
+ *                                algorithm and key:
+ *                                - A sufficient output size is
+ *                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type,
+ *                                  \p alg, \p ciphertext_length) where
+ *                                  \c key_type is the type of \p key.
+ *                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p
+ *                                  ciphertext_length) evaluates to the maximum
+ *                                  plaintext size of any supported AEAD
+ *                                  decryption.
  * \param[out] plaintext_length   On success, the size of the output
  *                                in the \p plaintext buffer.
  *
@@ -2152,7 +2130,11 @@ psa_status_t psa_aead_encrypt(psa_key_id_t key,
  *         \p alg is not supported or is not an AEAD algorithm.
  * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
  * \retval #PSA_ERROR_BUFFER_TOO_SMALL
- *         \p plaintext_size or \p nonce_length is too small
+ *         \p plaintext_size is too small.
+ *         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\c key_type, \p alg,
+ *         \p ciphertext_length) or
+ *         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p ciphertext_length) can be used
+ *         to determine the required buffer size.
  * \retval #PSA_ERROR_COMMUNICATION_FAILURE
  * \retval #PSA_ERROR_HARDWARE_FAILURE
  * \retval #PSA_ERROR_CORRUPTION_DETECTED
@@ -2200,22 +2182,10 @@ psa_status_t psa_aead_decrypt(psa_key_id_t key,
  *   \endcode
  *
  * This is an implementation-defined \c struct. Applications should not
- * make any assumptions about the content of this structure except
- * as directed by the documentation of a specific implementation. */
+ * make any assumptions about the content of this structure.
+ * Implementation details can change in future versions without notice. */
 typedef struct psa_aead_operation_s psa_aead_operation_t;
 
-/** \def PSA_AEAD_OPERATION_INIT
- *
- * This macro returns a suitable initializer for an AEAD operation object of
- * type #psa_aead_operation_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_AEAD_OPERATION_INIT {0}
-#endif
-
 /** Return an initial value for an AEAD operation object.
  */
 static psa_aead_operation_t psa_aead_operation_init(void);
@@ -2573,10 +2543,18 @@ psa_status_t psa_aead_update_ad(psa_aead_operation_t *operation,
  * \param input_length          Size of the \p input buffer in bytes.
  * \param[out] output           Buffer where the output is to be written.
  * \param output_size           Size of the \p output buffer in bytes.
- *                              This must be at least
- *                              #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c alg,
- *                              \p input_length) where \c alg is the
- *                              algorithm that is being calculated.
+ *                              This must be appropriate for the selected
+ *                                algorithm and key:
+ *                                - A sufficient output size is
+ *                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type,
+ *                                  \c alg, \p input_length) where
+ *                                  \c key_type is the type of key and \c alg is
+ *                                  the algorithm that were used to set up the
+ *                                  operation.
+ *                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p
+ *                                  input_length) evaluates to the maximum
+ *                                  output size of any supported AEAD
+ *                                  algorithm.
  * \param[out] output_length    On success, the number of bytes
  *                              that make up the returned output.
  *
@@ -2587,9 +2565,9 @@ psa_status_t psa_aead_update_ad(psa_aead_operation_t *operation,
  *         set, and have lengths set if required by the algorithm).
  * \retval #PSA_ERROR_BUFFER_TOO_SMALL
  *         The size of the \p output buffer is too small.
- *         You can determine a sufficient buffer size by calling
- *         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c alg, \p input_length)
- *         where \c alg is the algorithm that is being calculated.
+ *         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\c key_type, \c alg, \p input_length) or
+ *         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p input_length) can be used to
+ *         determine the required buffer size.
  * \retval #PSA_ERROR_INVALID_ARGUMENT
  *         The total length of input to psa_aead_update_ad() so far is
  *         less than the additional data length that was previously
@@ -2626,9 +2604,7 @@ psa_status_t psa_aead_update(psa_aead_operation_t *operation,
  * This function has two output buffers:
  * - \p ciphertext contains trailing ciphertext that was buffered from
  *   preceding calls to psa_aead_update().
- * - \p tag contains the authentication tag. Its length is always
- *   #PSA_AEAD_TAG_LENGTH(\c alg) where \c alg is the AEAD algorithm
- *   that the operation performs.
+ * - \p tag contains the authentication tag.
  *
  * When this function returns successfuly, the operation becomes inactive.
  * If this function returns an error status, the operation enters an error
@@ -2638,18 +2614,32 @@ psa_status_t psa_aead_update(psa_aead_operation_t *operation,
  * \param[out] ciphertext       Buffer where the last part of the ciphertext
  *                              is to be written.
  * \param ciphertext_size       Size of the \p ciphertext buffer in bytes.
- *                              This must be at least
- *                              #PSA_AEAD_FINISH_OUTPUT_SIZE(\c alg) where
- *                              \c alg is the algorithm that is being
- *                              calculated.
+ *                              This must be appropriate for the selected
+ *                              algorithm and key:
+ *                              - A sufficient output size is
+ *                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type,
+ *                                \c alg) where \c key_type is the type of key
+ *                                and \c alg is the algorithm that were used to
+ *                                set up the operation.
+ *                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to
+ *                                the maximum output size of any supported AEAD
+ *                                algorithm.
  * \param[out] ciphertext_length On success, the number of bytes of
  *                              returned ciphertext.
  * \param[out] tag              Buffer where the authentication tag is
  *                              to be written.
  * \param tag_size              Size of the \p tag buffer in bytes.
- *                              This must be at least
- *                              #PSA_AEAD_TAG_LENGTH(\c alg) where \c alg is
- *                              the algorithm that is being calculated.
+ *                              This must be appropriate for the selected
+ *                              algorithm and key:
+ *                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\c
+ *                                key_type, \c key_bits, \c alg) where
+ *                                \c key_type and \c key_bits are the type and
+ *                                bit-size of the key, and \c alg is the
+ *                                algorithm that were used in the call to
+ *                                psa_aead_encrypt_setup().
+ *                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the
+ *                                maximum tag size of any supported AEAD
+ *                                algorithm.
  * \param[out] tag_length       On success, the number of bytes
  *                              that make up the returned tag.
  *
@@ -2660,11 +2650,11 @@ psa_status_t psa_aead_update(psa_aead_operation_t *operation,
  *         operation with a nonce set).
  * \retval #PSA_ERROR_BUFFER_TOO_SMALL
  *         The size of the \p ciphertext or \p tag buffer is too small.
- *         You can determine a sufficient buffer size for \p ciphertext by
- *         calling #PSA_AEAD_FINISH_OUTPUT_SIZE(\c alg)
- *         where \c alg is the algorithm that is being calculated.
- *         You can determine a sufficient buffer size for \p tag by
- *         calling #PSA_AEAD_TAG_LENGTH(\c alg).
+ *         #PSA_AEAD_FINISH_OUTPUT_SIZE(\c key_type, \c alg) or
+ *         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the
+ *         required \p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\c key_type,
+ *         \c key_bits, \c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to
+ *         determine the required \p tag buffer size.
  * \retval #PSA_ERROR_INVALID_ARGUMENT
  *         The total length of input to psa_aead_update_ad() so far is
  *         less than the additional data length that was previously
@@ -2723,10 +2713,15 @@ psa_status_t psa_aead_finish(psa_aead_operation_t *operation,
  *                              that could not be processed until the end
  *                              of the input.
  * \param plaintext_size        Size of the \p plaintext buffer in bytes.
- *                              This must be at least
- *                              #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c alg) where
- *                              \c alg is the algorithm that is being
- *                              calculated.
+ *                              This must be appropriate for the selected algorithm and key:
+ *                              - A sufficient output size is
+ *                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type,
+ *                                \c alg) where \c key_type is the type of key
+ *                                and \c alg is the algorithm that were used to
+ *                                set up the operation.
+ *                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to
+ *                                the maximum output size of any supported AEAD
+ *                                algorithm.
  * \param[out] plaintext_length On success, the number of bytes of
  *                              returned plaintext.
  * \param[in] tag               Buffer containing the authentication tag.
@@ -2742,9 +2737,9 @@ psa_status_t psa_aead_finish(psa_aead_operation_t *operation,
  *         operation with a nonce set).
  * \retval #PSA_ERROR_BUFFER_TOO_SMALL
  *         The size of the \p plaintext buffer is too small.
- *         You can determine a sufficient buffer size for \p plaintext by
- *         calling #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c alg)
- *         where \c alg is the algorithm that is being calculated.
+ *         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\c key_type, \c alg) or
+ *         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the
+ *         required buffer size.
  * \retval #PSA_ERROR_INVALID_ARGUMENT
  *         The total length of input to psa_aead_update_ad() so far is
  *         less than the additional data length that was previously
@@ -2803,12 +2798,130 @@ psa_status_t psa_aead_abort(psa_aead_operation_t *operation);
  * @{
  */
 
+/**
+ * \brief Sign a message with a private key. For hash-and-sign algorithms,
+ *        this includes the hashing step.
+ *
+ * \note To perform a multi-part hash-and-sign signature algorithm, first use
+ *       a multi-part hash operation and then pass the resulting hash to
+ *       psa_sign_hash(). PSA_ALG_GET_HASH(\p alg) can be used to determine the
+ *       hash algorithm to use.
+ *
+ * \param[in]  key              Identifier of the key to use for the operation.
+ *                              It must be an asymmetric key pair. The key must
+ *                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.
+ * \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
+ *                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
+ *                              is true), that is compatible with the type of
+ *                              \p key.
+ * \param[in]  input            The input message to sign.
+ * \param[in]  input_length     Size of the \p input buffer in bytes.
+ * \param[out] signature        Buffer where the signature is to be written.
+ * \param[in]  signature_size   Size of the \p signature buffer in bytes. This
+ *                              must be appropriate for the selected
+ *                              algorithm and key:
+ *                              - The required signature size is
+ *                                #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
+ *                                where \c key_type and \c key_bits are the type and
+ *                                bit-size respectively of key.
+ *                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the
+ *                                maximum signature size of any supported
+ *                                signature algorithm.
+ * \param[out] signature_length On success, the number of bytes that make up
+ *                              the returned signature value.
+ *
+ * \retval #PSA_SUCCESS
+ * \retval #PSA_ERROR_INVALID_HANDLE
+ * \retval #PSA_ERROR_NOT_PERMITTED
+ *         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
+ *         or it does not permit the requested algorithm.
+ * \retval #PSA_ERROR_BUFFER_TOO_SMALL
+ *         The size of the \p signature buffer is too small. You can
+ *         determine a sufficient buffer size by calling
+ *         #PSA_SIGN_OUTPUT_SIZE(\c key_type, \c key_bits, \p alg)
+ *         where \c key_type and \c key_bits are the type and bit-size
+ *         respectively of \p key.
+ * \retval #PSA_ERROR_NOT_SUPPORTED
+ * \retval #PSA_ERROR_INVALID_ARGUMENT
+ * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
+ * \retval #PSA_ERROR_COMMUNICATION_FAILURE
+ * \retval #PSA_ERROR_HARDWARE_FAILURE
+ * \retval #PSA_ERROR_CORRUPTION_DETECTED
+ * \retval #PSA_ERROR_STORAGE_FAILURE
+ * \retval #PSA_ERROR_DATA_CORRUPT
+ * \retval #PSA_ERROR_DATA_INVALID
+ * \retval #PSA_ERROR_INSUFFICIENT_ENTROPY
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The library has not been previously initialized by psa_crypto_init().
+ *         It is implementation-dependent whether a failure to initialize
+ *         results in this error code.
+ */
+psa_status_t psa_sign_message( psa_key_id_t key,
+                               psa_algorithm_t alg,
+                               const uint8_t * input,
+                               size_t input_length,
+                               uint8_t * signature,
+                               size_t signature_size,
+                               size_t * signature_length );
+
+/** \brief Verify the signature of a message with a public key, using
+ *         a hash-and-sign verification algorithm.
+ *
+ * \note To perform a multi-part hash-and-sign signature verification
+ *       algorithm, first use a multi-part hash operation to hash the message
+ *       and then pass the resulting hash to psa_verify_hash().
+ *       PSA_ALG_GET_HASH(\p alg) can be used to determine the hash algorithm
+ *       to use.
+ *
+ * \param[in]  key              Identifier of the key to use for the operation.
+ *                              It must be a public key or an asymmetric key
+ *                              pair. The key must allow the usage
+ *                              #PSA_KEY_USAGE_VERIFY_MESSAGE.
+ * \param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX
+ *                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\p alg)
+ *                              is true), that is compatible with the type of
+ *                              \p key.
+ * \param[in]  input            The message whose signature is to be verified.
+ * \param[in]  input_length     Size of the \p input buffer in bytes.
+ * \param[out] signature        Buffer containing the signature to verify.
+ * \param[in]  signature_length Size of the \p signature buffer in bytes.
+ *
+ * \retval #PSA_SUCCESS
+ * \retval #PSA_ERROR_INVALID_HANDLE
+ * \retval #PSA_ERROR_NOT_PERMITTED
+ *         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,
+ *         or it does not permit the requested algorithm.
+ * \retval #PSA_ERROR_INVALID_SIGNATURE
+ *         The calculation was performed successfully, but the passed signature
+ *         is not a valid signature.
+ * \retval #PSA_ERROR_NOT_SUPPORTED
+ * \retval #PSA_ERROR_INVALID_ARGUMENT
+ * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
+ * \retval #PSA_ERROR_COMMUNICATION_FAILURE
+ * \retval #PSA_ERROR_HARDWARE_FAILURE
+ * \retval #PSA_ERROR_CORRUPTION_DETECTED
+ * \retval #PSA_ERROR_STORAGE_FAILURE
+ * \retval #PSA_ERROR_DATA_CORRUPT
+ * \retval #PSA_ERROR_DATA_INVALID
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The library has not been previously initialized by psa_crypto_init().
+ *         It is implementation-dependent whether a failure to initialize
+ *         results in this error code.
+ */
+psa_status_t psa_verify_message( psa_key_id_t key,
+                                 psa_algorithm_t alg,
+                                 const uint8_t * input,
+                                 size_t input_length,
+                                 const uint8_t * signature,
+                                 size_t signature_length );
+
 /**
  * \brief Sign a hash or short message with a private key.
  *
  * Note that to perform a hash-and-sign signature algorithm, you must
  * first calculate the hash by calling psa_hash_setup(), psa_hash_update()
- * and psa_hash_finish(). Then pass the resulting hash as the \p hash
+ * and psa_hash_finish(), or alternatively by calling psa_hash_compute().
+ * Then pass the resulting hash as the \p hash
  * parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
  * to determine the hash algorithm to use.
  *
@@ -2855,11 +2968,12 @@ psa_status_t psa_sign_hash(psa_key_id_t key,
                            size_t *signature_length);
 
 /**
- * \brief Verify the signature a hash or short message using a public key.
+ * \brief Verify the signature of a hash or short message using a public key.
  *
  * Note that to perform a hash-and-sign signature algorithm, you must
  * first calculate the hash by calling psa_hash_setup(), psa_hash_update()
- * and psa_hash_finish(). Then pass the resulting hash as the \p hash
+ * and psa_hash_finish(), or alternatively by calling psa_hash_compute().
+ * Then pass the resulting hash as the \p hash
  * parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\p alg)
  * to determine the hash algorithm to use.
  *
@@ -3055,23 +3169,11 @@ psa_status_t psa_asymmetric_decrypt(psa_key_id_t key,
  *   \endcode
  *
  * This is an implementation-defined \c struct. Applications should not
- * make any assumptions about the content of this structure except
- * as directed by the documentation of a specific implementation.
+ * make any assumptions about the content of this structure.
+ * Implementation details can change in future versions without notice.
  */
 typedef struct psa_key_derivation_s psa_key_derivation_operation_t;
 
-/** \def PSA_KEY_DERIVATION_OPERATION_INIT
- *
- * This macro returns a suitable initializer for a key derivation operation
- * object of type #psa_key_derivation_operation_t.
- */
-#ifdef __DOXYGEN_ONLY__
-/* This is an example definition for documentation purposes.
- * Implementations should define a suitable value in `crypto_struct.h`.
- */
-#define PSA_KEY_DERIVATION_OPERATION_INIT {0}
-#endif
-
 /** Return an initial value for a key derivation operation object.
  */
 static psa_key_derivation_operation_t psa_key_derivation_operation_init(void);
@@ -3249,6 +3351,50 @@ psa_status_t psa_key_derivation_input_bytes(
     const uint8_t *data,
     size_t data_length);
 
+/** Provide a numeric input for key derivation or key agreement.
+ *
+ * Which inputs are required and in what order depends on the algorithm.
+ * However, when an algorithm requires a particular order, numeric inputs
+ * usually come first as they tend to be configuration parameters.
+ * Refer to the documentation of each key derivation or key agreement
+ * algorithm for information.
+ *
+ * This function is used for inputs which are fixed-size non-negative
+ * integers.
+ *
+ * If this function returns an error status, the operation enters an error
+ * state and must be aborted by calling psa_key_derivation_abort().
+ *
+ * \param[in,out] operation       The key derivation operation object to use.
+ *                                It must have been set up with
+ *                                psa_key_derivation_setup() and must not
+ *                                have produced any output yet.
+ * \param step                    Which step the input data is for.
+ * \param[in] value               The value of the numeric input.
+ *
+ * \retval #PSA_SUCCESS
+ *         Success.
+ * \retval #PSA_ERROR_INVALID_ARGUMENT
+ *         \c step is not compatible with the operation's algorithm.
+ * \retval #PSA_ERROR_INVALID_ARGUMENT
+ *         \c step does not allow numeric inputs.
+ * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
+ * \retval #PSA_ERROR_COMMUNICATION_FAILURE
+ * \retval #PSA_ERROR_HARDWARE_FAILURE
+ * \retval #PSA_ERROR_CORRUPTION_DETECTED
+ * \retval #PSA_ERROR_STORAGE_FAILURE
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The operation state is not valid for this input \p step.
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The library has not been previously initialized by psa_crypto_init().
+ *         It is implementation-dependent whether a failure to initialize
+ *         results in this error code.
+ */
+psa_status_t psa_key_derivation_input_integer(
+    psa_key_derivation_operation_t *operation,
+    psa_key_derivation_step_t step,
+    uint64_t value);
+
 /** Provide an input for key derivation in the form of a key.
  *
  * Which inputs are required and in what order depends on the algorithm.
@@ -3273,12 +3419,29 @@ psa_status_t psa_key_derivation_input_bytes(
  * \param step                    Which step the input data is for.
  * \param key                     Identifier of the key. It must have an
  *                                appropriate type for step and must allow the
- *                                usage #PSA_KEY_USAGE_DERIVE.
+ *                                usage #PSA_KEY_USAGE_DERIVE or
+ *                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)
+ *                                and the algorithm used by the operation.
+ *
+ * \note Once all inputs steps are completed, the operations will allow:
+ * - psa_key_derivation_output_bytes() if each input was either a direct input
+ *   or  a key with #PSA_KEY_USAGE_DERIVE set;
+ * - psa_key_derivation_output_key() if the input for step
+ *   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD
+ *   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was
+ *   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;
+ * - psa_key_derivation_verify_bytes() if each input was either a direct input
+ *   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;
+ * - psa_key_derivation_verify_key() under the same conditions as
+ *   psa_key_derivation_verify_bytes().
  *
  * \retval #PSA_SUCCESS
  *         Success.
  * \retval #PSA_ERROR_INVALID_HANDLE
  * \retval #PSA_ERROR_NOT_PERMITTED
+ *         The key allows neither #PSA_KEY_USAGE_DERIVE nor
+ *         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this
+ *         algorithm.
  * \retval #PSA_ERROR_INVALID_ARGUMENT
  *         \c step is not compatible with the operation's algorithm.
  * \retval #PSA_ERROR_INVALID_ARGUMENT
@@ -3391,6 +3554,9 @@ psa_status_t psa_key_derivation_key_agreement(
  * \param output_length     Number of bytes to output.
  *
  * \retval #PSA_SUCCESS
+ * \retval #PSA_ERROR_NOT_PERMITTED
+ *         One of the inputs was a key whose policy didn't allow
+ *         #PSA_KEY_USAGE_DERIVE.
  * \retval #PSA_ERROR_INSUFFICIENT_DATA
  *                          The operation's capacity was less than
  *                          \p output_length bytes. Note that in this case,
@@ -3433,7 +3599,8 @@ psa_status_t psa_key_derivation_output_bytes(
  * state and must be aborted by calling psa_key_derivation_abort().
  *
  * How much output is produced and consumed from the operation, and how
- * the key is derived, depends on the key type:
+ * the key is derived, depends on the key type and on the key size
+ * (denoted \c bits below):
  *
  * - For key types for which the key is an arbitrary sequence of bytes
  *   of a given size, this function is functionally equivalent to
@@ -3443,14 +3610,14 @@ psa_status_t psa_key_derivation_output_bytes(
  *   if the implementation provides an isolation boundary then
  *   the key material is not exposed outside the isolation boundary.
  *   As a consequence, for these key types, this function always consumes
- *   exactly (\p bits / 8) bytes from the operation.
+ *   exactly (\c bits / 8) bytes from the operation.
  *   The following key types defined in this specification follow this scheme:
  *
  *     - #PSA_KEY_TYPE_AES;
- *     - #PSA_KEY_TYPE_ARC4;
  *     - #PSA_KEY_TYPE_CAMELLIA;
  *     - #PSA_KEY_TYPE_DERIVE;
- *     - #PSA_KEY_TYPE_HMAC.
+ *     - #PSA_KEY_TYPE_HMAC;
+ *     - #PSA_KEY_TYPE_PASSWORD_HASH.
  *
  * - For ECC keys on a Montgomery elliptic curve
  *   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\c curve) where \c curve designates a
@@ -3464,8 +3631,8 @@ psa_status_t psa_key_derivation_output_bytes(
  *       string and process it as specified in RFC 7748 &sect;5.
  *
  * - For key types for which the key is represented by a single sequence of
- *   \p bits bits with constraints as to which bit sequences are acceptable,
- *   this function draws a byte string of length (\p bits / 8) bytes rounded
+ *   \c bits bits with constraints as to which bit sequences are acceptable,
+ *   this function draws a byte string of length (\c bits / 8) bytes rounded
  *   up to the nearest whole number of bytes. If the resulting byte string
  *   is acceptable, it becomes the key, otherwise the drawn bytes are discarded.
  *   This process is repeated until an acceptable byte string is drawn.
@@ -3512,6 +3679,10 @@ psa_status_t psa_key_derivation_output_bytes(
  * on the derived key based on the attributes and strength of the secret key.
  *
  * \param[in] attributes    The attributes for the new key.
+ *                          If the key type to be created is
+ *                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in
+ *                          the policy must be the same as in the current
+ *                          operation.
  * \param[in,out] operation The key derivation operation object to read from.
  * \param[out] key          On success, an identifier for the newly created
  *                          key. For persistent keys, this is the key
@@ -3536,8 +3707,10 @@ psa_status_t psa_key_derivation_output_bytes(
  * \retval #PSA_ERROR_INVALID_ARGUMENT
  *         The provided key attributes are not valid for the operation.
  * \retval #PSA_ERROR_NOT_PERMITTED
- *         The #PSA_KEY_DERIVATION_INPUT_SECRET input was not provided through
- *         a key.
+ *         The #PSA_KEY_DERIVATION_INPUT_SECRET or
+ *         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a
+ *         key; or one of the inputs was a key whose policy didn't allow
+ *         #PSA_KEY_USAGE_DERIVE.
  * \retval #PSA_ERROR_BAD_STATE
  *         The operation state is not valid (it must be active and completed
  *         all required input steps).
@@ -3559,6 +3732,129 @@ psa_status_t psa_key_derivation_output_key(
     psa_key_derivation_operation_t *operation,
     psa_key_id_t *key);
 
+/** Compare output data from a key derivation operation to an expected value.
+ *
+ * This function calculates output bytes from a key derivation algorithm and
+ * compares those bytes to an expected value in constant time.
+ * If you view the key derivation's output as a stream of bytes, this
+ * function destructively reads the expected number of bytes from the
+ * stream before comparing them.
+ * The operation's capacity decreases by the number of bytes read.
+ *
+ * This is functionally equivalent to the following code:
+ * \code
+ * psa_key_derivation_output_bytes(operation, tmp, output_length);
+ * if (memcmp(output, tmp, output_length) != 0)
+ *     return PSA_ERROR_INVALID_SIGNATURE;
+ * \endcode
+ * except (1) it works even if the key's policy does not allow outputting the
+ * bytes, and (2) the comparison will be done in constant time.
+ *
+ * If this function returns an error status other than
+ * #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
+ * the operation enters an error state and must be aborted by calling
+ * psa_key_derivation_abort().
+ *
+ * \param[in,out] operation The key derivation operation object to read from.
+ * \param[in] expected_output Buffer containing the expected derivation output.
+ * \param output_length     Length ot the expected output; this is also the
+ *                          number of bytes that will be read.
+ *
+ * \retval #PSA_SUCCESS
+ * \retval #PSA_ERROR_INVALID_SIGNATURE
+ *         The output was read successfully, but it differs from the expected
+ *         output.
+ * \retval #PSA_ERROR_NOT_PERMITTED
+ *         One of the inputs was a key whose policy didn't allow
+ *         #PSA_KEY_USAGE_VERIFY_DERIVATION.
+ * \retval #PSA_ERROR_INSUFFICIENT_DATA
+ *                          The operation's capacity was less than
+ *                          \p output_length bytes. Note that in this case,
+ *                          the operation's capacity is set to 0, thus
+ *                          subsequent calls to this function will not
+ *                          succeed, even with a smaller expected output.
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The operation state is not valid (it must be active and completed
+ *         all required input steps).
+ * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
+ * \retval #PSA_ERROR_COMMUNICATION_FAILURE
+ * \retval #PSA_ERROR_HARDWARE_FAILURE
+ * \retval #PSA_ERROR_CORRUPTION_DETECTED
+ * \retval #PSA_ERROR_STORAGE_FAILURE
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The library has not been previously initialized by psa_crypto_init().
+ *         It is implementation-dependent whether a failure to initialize
+ *         results in this error code.
+ */
+psa_status_t psa_key_derivation_verify_bytes(
+    psa_key_derivation_operation_t *operation,
+    const uint8_t *expected_output,
+    size_t output_length);
+
+/** Compare output data from a key derivation operation to an expected value
+ * stored in a key object.
+ *
+ * This function calculates output bytes from a key derivation algorithm and
+ * compares those bytes to an expected value, provided as key of type
+ * #PSA_KEY_TYPE_PASSWORD_HASH.
+ * If you view the key derivation's output as a stream of bytes, this
+ * function destructively reads the number of bytes corresponding the the
+ * length of the expected value from the stream before comparing them.
+ * The operation's capacity decreases by the number of bytes read.
+ *
+ * This is functionally equivalent to exporting the key and calling
+ * psa_key_derivation_verify_bytes() on the result, except that it
+ * works even if the key cannot be exported.
+ *
+ * If this function returns an error status other than
+ * #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,
+ * the operation enters an error state and must be aborted by calling
+ * psa_key_derivation_abort().
+ *
+ * \param[in,out] operation The key derivation operation object to read from.
+ * \param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH
+ *                          containing the expected output. Its policy must
+ *                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag
+ *                          and the permitted algorithm must match the
+ *                          operation. The value of this key was likely
+ *                          computed by a previous call to
+ *                          psa_key_derivation_output_key().
+ *
+ * \retval #PSA_SUCCESS
+ * \retval #PSA_ERROR_INVALID_SIGNATURE
+ *         The output was read successfully, but if differs from the expected
+ *         output.
+ * \retval #PSA_ERROR_INVALID_HANDLE
+ *         The key passed as the expected value does not exist.
+ * \retval #PSA_ERROR_INVALID_ARGUMENT
+ *         The key passed as the expected value has an invalid type.
+ * \retval #PSA_ERROR_NOT_PERMITTED
+ *         The key passed as the expected value does not allow this usage or
+ *         this algorithm; or one of the inputs was a key whose policy didn't
+ *         allow #PSA_KEY_USAGE_VERIFY_DERIVATION.
+ * \retval #PSA_ERROR_INSUFFICIENT_DATA
+ *                          The operation's capacity was less than
+ *                          the length of the expected value. In this case,
+ *                          the operation's capacity is set to 0, thus
+ *                          subsequent calls to this function will not
+ *                          succeed, even with a smaller expected output.
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The operation state is not valid (it must be active and completed
+ *         all required input steps).
+ * \retval #PSA_ERROR_INSUFFICIENT_MEMORY
+ * \retval #PSA_ERROR_COMMUNICATION_FAILURE
+ * \retval #PSA_ERROR_HARDWARE_FAILURE
+ * \retval #PSA_ERROR_CORRUPTION_DETECTED
+ * \retval #PSA_ERROR_STORAGE_FAILURE
+ * \retval #PSA_ERROR_BAD_STATE
+ *         The library has not been previously initialized by psa_crypto_init().
+ *         It is implementation-dependent whether a failure to initialize
+ *         results in this error code.
+ */
+psa_status_t psa_key_derivation_verify_key(
+    psa_key_derivation_operation_t *operation,
+    psa_key_id_t expected);
+
 /** Abort a key derivation operation.
  *
  * Aborting an operation frees all associated resources except for the \c
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
index e77eb1a2abb42b75192422ba5fceae0f9a8302d0..89a0c54f45f394051e8562ae807d9464d785c907 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/plat_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -72,6 +72,10 @@ void tfm_plat_test_secure_timer_stop(void)
     cmsdk_timer_clear_interrupt(&CMSDK_TIMER0_DEV_S);
 }
 
+void tfm_plat_test_secure_timer_clear_intr(void) {
+    cmsdk_timer_clear_interrupt(&CMSDK_TIMER0_DEV_S);
+}
+
 void tfm_plat_test_non_secure_timer_start(void)
 {
     if (!cmsdk_timer_is_initialized(&CMSDK_TIMER1_DEV_NS)) {
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h b/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
index 4ad749ea5aad443238ab7383c6a8719e64519228..33b2ddb400f1ea97ea819bed2430924c007d290b 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_spm_log.h
@@ -36,25 +36,37 @@
 
 #if (TFM_SPM_LOG_LEVEL == TFM_SPM_LOG_LEVEL_DEBUG)
 #define SPMLOG_DBGMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_DBGMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_DBGMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_DBGMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_DBGMSG(msg)
 #endif
 
 #if (TFM_SPM_LOG_LEVEL >= TFM_SPM_LOG_LEVEL_INFO)
 #define SPMLOG_INFMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_INFMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_INFMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_INFMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_INFMSG(msg)
 #endif
 
 #if (TFM_SPM_LOG_LEVEL >= TFM_SPM_LOG_LEVEL_ERROR)
 #define SPMLOG_ERRMSGVAL(msg, val) spm_log_msgval(msg, sizeof(msg), val)
+#if (TFM_SYSTEM_FP >= 1)
+#define SPMLOG_ERRMSGVALF(msg, val) spm_log_msgvalf(msg, sizeof(msg), val)
+#endif
 #define SPMLOG_ERRMSG(msg) tfm_hal_output_spm_log(msg, sizeof(msg))
 #else
 #define SPMLOG_ERRMSGVAL(msg, val)
+#define SPMLOG_DBGMSGVALF(msg, val)
 #define SPMLOG_ERRMSG(msg)
 #endif
 
@@ -71,4 +83,19 @@
  */
 int32_t spm_log_msgval(const char *msg, size_t len, uint32_t value);
 
+#if (TFM_SYSTEM_FP >= 1)
+/**
+ * \brief SPM output API to print floating point number and call the HAL API
+ *        tfm_hal_output_spm_log.
+ *
+ * \param[in]  msg    A string message
+ * \param[in]  len    The length of the message
+ * \param[in]  value  A floating point value need to be output
+ *
+ * \retval >=0        Number of chars output.
+ * \retval <0         TFM HAL error code.
+ */
+int32_t spm_log_msgvalf(const char *msg, size_t len, double value);
+#endif
+
 #endif /* __TFM_SPM_LOG_H__ */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
index 8c7869585f971daec6741cdc48a6bb45082e29b8..9bdea560ccd1f204c7ecd8f934dc52f6bf45d2d9 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Device/Source/startup_stm32l5xx_s.c
@@ -348,6 +348,9 @@ void Reset_Handler(void)
 {
   __disable_irq();
   __set_MSPLIM((uint32_t)(&__MSP_STACK_LIMIT));
+#if defined ( __GNUC__ )
+  __set_MSP((uint32_t)(&__MSP_INITIAL_SP));
+#endif
   SystemInit();   /* CMSIS System Initialization */
   __set_PSP((uint32_t)(&__INITIAL_SP));
   __set_PSPLIM((uint32_t)(&__STACK_LIMIT));
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/cmsis_core/cmsis_cpu.h b/lib/tf-m/platform/ext/target/arm/mps2/an519/cmsis_core/cmsis_cpu.h
index cd9cff61c12a15f934fb79885352c8f0ec415d25..b6f0ef445c89f26d6141e58028bab5d5e2f810dc 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/cmsis_core/cmsis_cpu.h
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/cmsis_core/cmsis_cpu.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2018 ARM Limited
+ * Copyright (c) 2016-2021 ARM Limited
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@
 #define __MPU_PRESENT             1U        /* MPU present */
 #define __SAUREGION_PRESENT       1U        /* SAU regions present */
 #define __VTOR_PRESENT            1U        /* VTOR present */
-#define __NVIC_PRIO_BITS          4U        /* Number of Bits used for Priority Levels */
+#define __NVIC_PRIO_BITS          2U        /* Number of Bits used for Priority Levels */
 #define __Vendor_SysTickConfig    0U        /* Set to 1 if different SysTick Config is used */
 #define __FPU_PRESENT             0U        /* no FPU present */
 #define __DSP_PRESENT             0U        /* no DSP extension present */
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
index 1c4beae78271d5ac1c59d69bfa4bc7092ae400e2..011a3ce6ef237c24bb485220e83566c8625dae42 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_mac.c
@@ -321,8 +321,38 @@ psa_status_t tfm_crypto_mac_compute(psa_invec in_vec[],
                                     psa_outvec out_vec[],
                                     size_t out_len)
 {
-    /* FixMe: To be implemented */
+#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
     return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status = PSA_SUCCESS;
+
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 2, out_len, 1, 1);
+
+    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    uint8_t *mac = out_vec[0].base;
+    size_t mac_size = out_vec[0].len;
+    mbedtls_svc_key_id_t encoded_key;
+
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_mac_compute(encoded_key, alg, input, input_length, mac, mac_size,
+                           &out_vec[0].len);
+#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
 }
 
 psa_status_t tfm_crypto_mac_verify(psa_invec in_vec[],
@@ -330,7 +360,37 @@ psa_status_t tfm_crypto_mac_verify(psa_invec in_vec[],
                                    psa_outvec out_vec[],
                                    size_t out_len)
 {
-    /* FixMe: To be implemented */
+#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
     return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status = PSA_SUCCESS;
+
+    CRYPTO_IN_OUT_LEN_VALIDATE(in_len, 1, 3, out_len, 0, 0);
+
+    if (in_vec[0].len != sizeof(struct tfm_crypto_pack_iovec)) {
+        return PSA_ERROR_PROGRAMMER_ERROR;
+    }
+    const struct tfm_crypto_pack_iovec *iov = in_vec[0].base;
+    psa_key_id_t key_id = iov->key_id;
+    psa_algorithm_t alg = iov->alg;
+    const uint8_t *input = in_vec[1].base;
+    size_t input_length = in_vec[1].len;
+    const uint8_t *mac = in_vec[2].base;
+    size_t mac_length = in_vec[2].len;
+    mbedtls_svc_key_id_t encoded_key;
+
+    status = tfm_crypto_check_handle_owner(key_id);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    status = tfm_crypto_encode_id_and_owner(key_id, &encoded_key);
+    if (status != PSA_SUCCESS) {
+        return status;
+    }
+
+    return psa_mac_verify(encoded_key, alg, input, input_length, mac,
+                          mac_length);
+#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
 }
 /*!@}*/
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
index 66d6ce144582771587102c4e5d2f525d489e4c5e..290210578d8e3d1b920734ec016758069bddf4ef 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/startup_an547_ns.c
@@ -172,6 +172,7 @@ DEFAULT_IRQ_HANDLER(GPIO3_3_Handler)
 DEFAULT_IRQ_HANDLER(UARTRX5_Handler)
 DEFAULT_IRQ_HANDLER(UARTTX5_Handler)
 DEFAULT_IRQ_HANDLER(UART5_Handler)
+DEFAULT_IRQ_HANDLER(ARM_VSI0_Handler)
 
 /*----------------------------------------------------------------------------
   Exception / Interrupt Vector table
@@ -182,6 +183,8 @@ DEFAULT_IRQ_HANDLER(UART5_Handler)
 #pragma GCC diagnostic ignored "-Wpedantic"
 #endif
 
+extern void arm_npu_irq_handler(void);
+
 extern const pFunc __VECTOR_TABLE[496];
        const pFunc __VECTOR_TABLE[496] __VECTOR_TABLE_ATTRIBUTE = {
   (pFunc)(&__MSP_INITIAL_SP),        /*      Initial Stack Pointer */
@@ -259,7 +262,7 @@ extern const pFunc __VECTOR_TABLE[496];
   SPI_ADC_Handler,                   /*  53: SPI ADC Handler */
   SPI_SHIELD0_Handler,               /*  54: SPI (Shield 0) Handler */
   SPI_SHIELD1_Handler,               /*  55: SPI (Shield 0) Handler */
-  ETHOS_U55_Handler,                 /*  56: Ethos-U55 Handler */
+  arm_npu_irq_handler,               /*  56: Ethos-U55 Handler */
   0,                                 /*  57: Reserved */
   0,                                 /*  58: Reserved */
   0,                                 /*  59: Reserved */
@@ -334,6 +337,100 @@ extern const pFunc __VECTOR_TABLE[496];
   0,                                 /*  128: Reserved */
   0,                                 /*  129: Reserved */
   0,                                 /*  130: Reserved */
+  0,                                /*  131: Reserved */
+  0,                                /*  132: Reserved */
+  0,                                /*  133: Reserved */
+  0,                                /*  134: Reserved */
+  0,                                /*  135: Reserved */
+  0,                                /*  136: Reserved */
+  0,                                /*  137: Reserved */
+  0,                                /*  138: Reserved */
+  0,                                /*  139: Reserved */
+  0,                                /*  140: Reserved */
+  0,                                /*  141: Reserved */
+  0,                                /*  142: Reserved */
+  0,                                /*  143: Reserved */
+  0,                                /*  144: Reserved */
+  0,                                /*  145: Reserved */
+  0,                                /*  146: Reserved */
+  0,                                /*  147: Reserved */
+  0,                                /*  148: Reserved */
+  0,                                /*  149: Reserved */
+  0,                                /*  150: Reserved */
+  0,                                /*  151: Reserved */
+  0,                                /*  152: Reserved */
+  0,                                /*  153: Reserved */
+  0,                                /*  154: Reserved */
+  0,                                /*  155: Reserved */
+  0,                                /*  156: Reserved */
+  0,                                /*  157: Reserved */
+  0,                                /*  158: Reserved */
+  0,                                /*  159: Reserved */
+  0,                                /*  160: Reserved */
+  0,                                /*  161: Reserved */
+  0,                                /*  162: Reserved */
+  0,                                /*  163: Reserved */
+  0,                                /*  164: Reserved */
+  0,                                /*  165: Reserved */
+  0,                                /*  166: Reserved */
+  0,                                /*  167: Reserved */
+  0,                                /*  168: Reserved */
+  0,                                /*  169: Reserved */
+  0,                                /*  170: Reserved */
+  0,                                /*  171: Reserved */
+  0,                                /*  172: Reserved */
+  0,                                /*  173: Reserved */
+  0,                                /*  174: Reserved */
+  0,                                /*  175: Reserved */
+  0,                                /*  176: Reserved */
+  0,                                /*  177: Reserved */
+  0,                                /*  178: Reserved */
+  0,                                /*  179: Reserved */
+  0,                                /*  180: Reserved */
+  0,                                /*  181: Reserved */
+  0,                                /*  182: Reserved */
+  0,                                /*  183: Reserved */
+  0,                                /*  184: Reserved */
+  0,                                /*  185: Reserved */
+  0,                                /*  186: Reserved */
+  0,                                /*  187: Reserved */
+  0,                                /*  188: Reserved */
+  0,                                /*  189: Reserved */
+  0,                                /*  190: Reserved */
+  0,                                /*  191: Reserved */
+  0,                                /*  192: Reserved */
+  0,                                /*  193: Reserved */
+  0,                                /*  194: Reserved */
+  0,                                /*  195: Reserved */
+  0,                                /*  196: Reserved */
+  0,                                /*  197: Reserved */
+  0,                                /*  198: Reserved */
+  0,                                /*  199: Reserved */
+  0,                                /*  200: Reserved */
+  0,                                /*  201: Reserved */
+  0,                                /*  202: Reserved */
+  0,                                /*  203: Reserved */
+  0,                                /*  204: Reserved */
+  0,                                /*  205: Reserved */
+  0,                                /*  206: Reserved */
+  0,                                /*  207: Reserved */
+  0,                                /*  208: Reserved */
+  0,                                /*  209: Reserved */
+  0,                                /*  210: Reserved */
+  0,                                /*  211: Reserved */
+  0,                                /*  212: Reserved */
+  0,                                /*  213: Reserved */
+  0,                                /*  214: Reserved */
+  0,                                /*  215: Reserved */
+  0,                                /*  216: Reserved */
+  0,                                /*  217: Reserved */
+  0,                                /*  218: Reserved */
+  0,                                /*  219: Reserved */
+  0,                                /*  220: Reserved */
+  0,                                /*  221: Reserved */
+  0,                                /*  222: Reserved */
+  0,                                /*  223: Reserved */
+  ARM_VSI0_Handler,                 /*  224: VSI 0 */
 };
 
 #if defined ( __GNUC__ )
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
index 66d50d87edfe50b86aedc72dabb0e208e00fa969..015ae73316a4e6a7a1878b6777e0a602c9fd5833 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_base.c
@@ -118,18 +118,60 @@ __attribute__((naked)) void HardFault_Handler(void)
 }
 
 #if defined(__ICCARM__)
-uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return);
+uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
+                              uint32_t *psp);
 #pragma required = tfm_core_svc_handler
 #endif
 
 __attribute__((naked)) void SVC_Handler(void)
 {
     __ASM volatile(
+#if !defined(__ICCARM__)
+    ".syntax unified                        \n"
+#endif
     "MRS     r0, MSP                        \n"
-    "MRS     r1, PSP                        \n"
-    "MOV     r2, lr                         \n"
+    "MOV     r1, lr                         \n"
+    "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
+    "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
     "BL      tfm_core_svc_handler           \n"
-    "BX      r0                             \n"
+    "MOV     lr, r0                         \n"
+    "LDR     r1, [sp]                       \n" /* Original EXC_RETURN */
+    "MOVS    r2, #8                         \n"
+    "ANDS    r0, r2                         \n" /* Mode bit */
+    "ANDS    r1, r2                         \n"
+    "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
+    "BGT     to_flih_func                   \n"
+    "BLT     from_flih_func                 \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
+    "to_flih_func:                          \n"
+    "PUSH    {r4-r7}                        \n"
+    "MOV     r4, r8                         \n"
+    "MOV     r5, r9                         \n"
+    "MOV     r6, r10                        \n"
+    "MOV     r7, r11                        \n"
+    "PUSH    {r4-r7}                        \n"
+    "LDR     r4, =0xFEF5EDA5                \n" /* clear r4-r11 */
+    "MOV     r5, r4                         \n"
+    "MOV     r6, r4                         \n"
+    "MOV     r7, r4                         \n"
+    "MOV     r8, r4                         \n"
+    "MOV     r9, r4                         \n"
+    "MOV     r10, r4                        \n"
+    "MOV     r11, r4                        \n"
+    "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
+    "BX      lr                             \n"
+    "from_flih_func:                        \n"
+    "ADD     sp, #24                        \n"
+    "POP     {r4-r7}                        \n"
+    "MOV     r8, r4                         \n"
+    "MOV     r9, r5                         \n"
+    "MOV     r10, r6                        \n"
+    "MOV     r11, r7                        \n"
+    "POP     {r4-r7}                        \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
     );
 }
 
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdh_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdh_alt.c
index e12ee1b4a0cb456a5dbb18d44d6a4b4b35ce1977..087f704c0a7257fefc2cc69795a94b328b7b6652 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdh_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdh_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -16,7 +16,6 @@
 #include "cc_ecc_internal.h"
 
 
-
 const mbedtls_ecp_curve_info curve_25519_data = { MBEDTLS_ECP_DP_CURVE25519,   29,     255,     "curve25519"};
 
 #if defined(MBEDTLS_ECDH_GEN_PUBLIC_ALT)
@@ -74,7 +73,7 @@ int mbedtls_ecdh_compute_shared( mbedtls_ecp_group *grp, mbedtls_mpi *z,
         goto cleanup;
     }
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, &P.X ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, &P.MBEDTLS_PRIVATE(X) ) );
 
 cleanup:
     mbedtls_ecp_point_free( &P );
@@ -109,8 +108,8 @@ static int mbedtls_ecp_tls_write_group_edwards( const mbedtls_ecp_group *grp, si
     /*
      * Next two bytes are the namedcurve value
      */
-    buf[0] = curve_info->tls_id >> 8;
-    buf[1] = curve_info->tls_id & 0xFF;
+    buf[0] = curve_info->MBEDTLS_PRIVATE(tls_id) >> 8;
+    buf[1] = curve_info->MBEDTLS_PRIVATE(tls_id) & 0xFF;
 
     return( 0 );
 }
@@ -130,24 +129,24 @@ int mbedtls_ecdh_make_params_edwards( mbedtls_ecdh_context *ctx, size_t *olen,
     int ret;
     size_t grp_len, pt_len;
 
-    if( ctx == NULL || ctx->grp.pbits == 0 ||
+    if( ctx == NULL || ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp).pbits == 0 ||
             olen == NULL || buf == NULL ||
-            blen <= 0 || (ctx->grp.id != MBEDTLS_ECP_DP_CURVE25519) ){
+            blen <= 0 || (ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp).id != MBEDTLS_ECP_DP_CURVE25519) ){
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
     }
 
-    if( ( ret = mbedtls_ecdh_gen_public( &ctx->grp, &ctx->d, &ctx->Q, f_rng, p_rng ) )
+    if( ( ret = mbedtls_ecdh_gen_public( &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp), &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(d), &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(Q), f_rng, p_rng ) )
                 != 0 )
         return( ret );
 
-    if( ( ret = mbedtls_ecp_tls_write_group_edwards( &ctx->grp, &grp_len, buf, blen ) )
+    if( ( ret = mbedtls_ecp_tls_write_group_edwards( &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp), &grp_len, buf, blen ) )
                 != 0 )
         return( ret );
 
     buf += grp_len;
     blen -= grp_len;
 
-    if( ( ret = mbedtls_ecp_tls_write_point( &ctx->grp, &ctx->Q, ctx->point_format,
+    if( ( ret = mbedtls_ecp_tls_write_point( &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp), &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(Q), ctx->MBEDTLS_PRIVATE(point_format),
                                      &pt_len, buf, blen ) ) != 0 )
         return( ret );
 
@@ -182,10 +181,10 @@ static int mbedtls_ecp_tls_read_group_edwards( mbedtls_ecp_group *grp, const uns
     tls_id <<= 8;
     tls_id |= *(*buf)++;
 
-    if (curve_info->tls_id != tls_id){
+    if (curve_info->MBEDTLS_PRIVATE(tls_id) != tls_id){
             return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
     }
-    return mbedtls_ecp_group_load( grp, curve_info->grp_id );
+    return mbedtls_ecp_group_load( grp, curve_info->MBEDTLS_PRIVATE(grp_id) );
 }
 
 /*
@@ -203,10 +202,10 @@ int mbedtls_ecdh_read_params_edwards( mbedtls_ecdh_context *ctx,
     if( ctx == NULL || buf == NULL || end == NULL){
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
     }
-    if( ( ret = mbedtls_ecp_tls_read_group_edwards( &ctx->grp, buf, end - *buf ) ) != 0 )
+    if( ( ret = mbedtls_ecp_tls_read_group_edwards( &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp), buf, end - *buf ) ) != 0 )
         return( ret );
 
-    if( ( ret = mbedtls_ecp_tls_read_point( &ctx->grp, &ctx->Qp, buf, end - *buf ) )
+    if( ( ret = mbedtls_ecp_tls_read_point( &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(grp), &ctx->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(mbed_ecdh).MBEDTLS_PRIVATE(Qp), buf, end - *buf ) )
                 != 0 ){
             return( ret );
     }
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c b/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
index b996368fcc68d927a1bf6785f714cd81747bae9d..d7f9549bcd145745bc9e9a26d4d417a16bc55491 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/spm_hal.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
- * Copyright (c) 2019-2020, Cypress Semiconductor Corporation. All rights reserved.
+ * Copyright (c) 2019-2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -25,6 +25,7 @@
 #include "cy_device.h"
 #include "cy_device_headers.h"
 #include "cy_ipc_drv.h"
+#include "cy_p64_watchdog.h"
 #include "cy_prot.h"
 #include "cy_pra.h"
 #include "pc_config.h"
@@ -34,6 +35,19 @@
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+static enum tfm_plat_err_t handle_boot_wdt(void)
+{
+    /* Update watchdog timer to mark successfull start up of the image */
+    LOG_MSG("Checking boot watchdog\r\n");
+    if (cy_p64_wdg_is_enabled()) {
+        cy_p64_wdg_stop();
+        cy_p64_wdg_free();
+        LOG_MSG("Disabled boot watchdog\r\n");
+    }
+
+    return TFM_PLAT_ERR_SUCCESS;
+}
+
 enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
         bool privileged,
         const struct platform_data_t *platform_data)
@@ -66,6 +80,9 @@ void tfm_spm_hal_boot_ns_cpu(uintptr_t start_addr)
 {
     smpu_print_config();
 
+    /* Reset boot watchdog */
+    handle_boot_wdt();
+
     if (cy_access_port_control(CY_CM4_AP, CY_AP_EN) == 0) {
         /* The delay is required after Access port was enabled for
         * debugger/programmer to connect and set TEST BIT */
@@ -112,11 +129,9 @@ void tfm_spm_hal_wait_for_ns_cpu_ready(void)
     }
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
 
     return TFM_PLAT_ERR_SUCCESS;
 }
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
index 83528581a6202410b7f1d2093881dddc47c579e1..ba336218db629eeac0847e90a4266c6beb81a0b1 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/plat_test.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -64,6 +64,10 @@ void tfm_plat_test_secure_timer_start(void)
     cmsdk_timer_enable_interrupt(&CMSDK_TIMER0_DEV_S);
 }
 
+void tfm_plat_test_secure_timer_clear_intr(void) {
+    cmsdk_timer_clear_interrupt(&CMSDK_TIMER0_DEV_S);
+}
+
 void tfm_plat_test_secure_timer_stop(void)
 {
     cmsdk_timer_disable(&CMSDK_TIMER0_DEV_S);
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
index 58d38b959d4f26e706b72b9b40ccede631aab97d..754f8dd159121cb5cd2c0d3da3b72c4128a276c1 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/device_definition.h
@@ -94,111 +94,56 @@ extern struct uart_cmsdk_dev_t UART5_CMSDK_DEV_NS;
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP2_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP3_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP0_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP1_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP2_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS;
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 #include "ppc_sse300_drv.h"
 extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S;
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP3_NS
-#include "ppc_sse300_drv.h"
-extern struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS;
-#endif
-
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 #include "syscounter_armv8-m_cntrl_drv.h"
@@ -297,92 +242,6 @@ extern struct arm_mps3_io_dev_t MPS3_IO_DEV_S;
 extern struct arm_mps3_io_dev_t MPS3_IO_DEV_NS;
 #endif
 
-#ifdef SMSC9220_ETH_S
-#include "smsc9220_eth_drv.h"
-extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S;
-#endif
-
-#ifdef SMSC9220_ETH_NS
-#include "smsc9220_eth_drv.h"
-extern struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS;
-#endif
-
-/* CMSDK GPIO driver structures */
-#ifdef GPIO0_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO0_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO1_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO1_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO2_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO2_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS;
-#endif
-
-#ifdef GPIO3_CMSDK_S
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S;
-#endif
-
-#ifdef GPIO3_CMSDK_NS
-#include "gpio_cmsdk_drv.h"
-extern struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS;
-#endif
-
-/* I2C_SBCon driver structures */
-#ifdef I2C0_SBCON_S
-#include "timeout.h"
-#include "i2c_sbcon_drv.h"
-extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S;
-#endif
-
-#ifdef I2C0_SBCON_NS
-#include "timeout.h"
-#include "i2c_sbcon_drv.h"
-extern struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS;
-#endif
-
-/* I2S driver structures */
-#ifdef MPS3_I2S_S
-#include "audio_i2s_mps3_drv.h"
-extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S;
-#endif
-
-#ifdef MPS3_I2S_NS
-#include "audio_i2s_mps3_drv.h"
-extern struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS;
-#endif
-
-/* TGU driver structure */
-#ifdef TGU_ARMV8_M_ITCM_S
-#include "tgu_armv8_m_drv.h"
-extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S;
-#endif
-
-#ifdef TGU_ARMV8_M_DTCM_S
-#include "tgu_armv8_m_drv.h"
-extern struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S;
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h
index 7d2055bd1e31e552bf84302fc830dbc9ad63e276..7e6f468ea22191cb317c6f2186c3a52c15d20503 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -25,7 +25,7 @@ struct tfm_event_t {
  * Parameters:
  *  pevnt      -    The pointer of event object allocated by the caller
  */
-void __STATIC_INLINE tfm_event_init(struct tfm_event_t *pevnt)
+__STATIC_INLINE void tfm_event_init(struct tfm_event_t *pevnt)
 {
     pevnt->magic = TFM_EVENT_MAGIC;
     pevnt->owner = NULL;
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
index 4f2fb3a8450b066c75b53ccd968c68f4b63a7a85..5058dd80523ebb886ec47fa2ae768044e7acc126 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2019-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -117,12 +117,22 @@ __STATIC_INLINE uintptr_t tfm_arch_seal_thread_stack(uintptr_t stk)
     return stk;
 }
 
+/**
+ * \brief Get architecture context value into context struct
+ *
+ * \param[in] p_actx        Pointer of context data
+ */
+__STATIC_INLINE void tfm_arch_get_ctx(struct tfm_arch_ctx_t *p_actx)
+{
+    p_actx->sp = __get_PSP();
+}
+
 /**
  * \brief Update architecture context value into hardware
  *
  * \param[in] p_actx        Pointer of context data
  */
-__STATIC_INLINE void tfm_arch_update_ctx(struct tfm_arch_ctx_t *p_actx)
+__STATIC_INLINE void tfm_arch_set_ctx(struct tfm_arch_ctx_t *p_actx)
 {
     __set_PSP(p_actx->sp);
 }
diff --git a/lib/tf-m/platform/include/tfm_spm_hal.h b/lib/tf-m/platform/include/tfm_spm_hal.h
index 57304926bc69d15cf4464f87a96734519cbe2c11..91e98073f42e662cc9c4ee9392181a93ade4f047 100644
--- a/lib/tf-m/platform/include/tfm_spm_hal.h
+++ b/lib/tf-m/platform/include/tfm_spm_hal.h
@@ -9,6 +9,7 @@
 #define __TFM_SPM_HAL_H__
 
 #include <stdint.h>
+#include "cmsis.h"
 #include "fih.h"
 #include "tfm_secure_api.h"
 #ifdef TFM_MULTI_CORE_TOPOLOGY
@@ -16,6 +17,12 @@
 #endif
 #include "tfm_plat_defs.h"
 
+/*
+ * Quantized default IRQ priority, the value is:
+ * (Number of configurable priority) / 4: (1UL << __NVIC_PRIO_BITS) / 4
+ */
+#define DEFAULT_IRQ_PRIORITY    (1UL << (__NVIC_PRIO_BITS - 2))
+
 /**
  * \brief Holds peripheral specific data fields required to manage the
  *        peripherals isolation
@@ -195,16 +202,17 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void);
  * \brief Set the priority of a secure IRQ
  *
  * \param[in] irq_line    The IRQ to set the priority for. Might be less than 0
- * \param[in] priority    The priority to set. [0..255]
  *
  * \details This function sets the priority for the IRQ passed in the parameter.
- *          The precision of the priority value might be adjusted to match the
- *          available priority bits in the underlying target platform.
  *
  * \return Returns values as specified by the \ref tfm_plat_err_t
+ *
+ * \note The priority value must be less than the value of PendSV (0x80) and
+ *       greater than SVC (0x0).
+ *       Platforms are responsible for the priority values assignment to each
+ *       IRQ based on their platforms and use cases.
  */
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority);
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line);
 
 /**
  * \brief Clears a pending IRQ
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
index 60c42c2b79f437401e39c5e498e3d9701f470947..9febb966498433407e5cf23ee030604100d5959a 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_default.h
@@ -496,23 +496,6 @@
 //#define MBEDTLS_ECP_RANDOMIZE_MXZ_ALT
 //#define MBEDTLS_ECP_NORMALIZE_MXZ_ALT
 
-/**
- * \def MBEDTLS_TEST_NULL_ENTROPY
- *
- * Enables testing and use of mbed TLS without any configured entropy sources.
- * This permits use of the library on platforms before an entropy source has
- * been integrated (see for example the MBEDTLS_ENTROPY_HARDWARE_ALT or the
- * MBEDTLS_ENTROPY_NV_SEED switches).
- *
- * WARNING! This switch MUST be disabled in production builds, and is suitable
- * only for development.
- * Enabling the switch negates any security provided by the library.
- *
- * Requires MBEDTLS_ENTROPY_C, MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
- *
- */
-#define MBEDTLS_TEST_NULL_ENTROPY
-
 /**
  * \def MBEDTLS_ENTROPY_HARDWARE_ALT
  *
@@ -798,7 +781,7 @@
  *
  * Uncomment this macro to prevent loading of default entropy functions.
  */
-#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 /**
  * \def MBEDTLS_NO_PLATFORM_ENTROPY
@@ -853,7 +836,7 @@
  * \note The entropy collector will write to the seed file before entropy is
  *       given to an external source, to update it.
  */
-//#define MBEDTLS_ENTROPY_NV_SEED
+#define MBEDTLS_ENTROPY_NV_SEED
 
 /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
  *
@@ -1783,6 +1766,22 @@
  */
 //#define MBEDTLS_SHA1_C
 
+/**
+ * \def MBEDTLS_SHA224_C
+ *
+ * Enable the SHA-224 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA256_C. The library does not currently support enabling
+ *           SHA-224 without SHA-256.
+ *
+ * Module:  library/sha256.c
+ * Caller:  library/md.c
+ *          library/ssl_cookie.c
+ *
+ * This module adds support for SHA-224.
+ */
+#define MBEDTLS_SHA224_C
+
 /**
  * \def MBEDTLS_SHA256_C
  *
@@ -1797,6 +1796,22 @@
  */
 #define MBEDTLS_SHA256_C
 
+/**
+ * \def MBEDTLS_SHA384_C
+ *
+ * Enable the SHA-384 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA512_C
+ *
+ * Module:  library/sha512.c
+ * Caller:  library/md.c
+ *          library/ssl_cli.c
+ *          library/ssl_srv.c
+ *
+ * Comment to disable SHA-384
+ */
+#define MBEDTLS_SHA384_C
+
 /**
  * \def MBEDTLS_SHA512_C
  *
@@ -1998,6 +2013,8 @@
 
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
+#else
+#include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
 /* Target and application specific configurations
diff --git a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
index 7e85b22e99264e609af992efc525c47928f0af3a..ff1d17b56061eaded7bbd8e44147a5d9b741c1c2 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
+++ b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_api.h
@@ -218,6 +218,8 @@ psa_status_t tfm_crypto_encode_id_and_owner(psa_key_id_t key_id,
     X(tfm_crypto_aead_finish)                 \
     X(tfm_crypto_aead_verify)                 \
     X(tfm_crypto_aead_abort)                  \
+    X(tfm_crypto_sign_message)                \
+    X(tfm_crypto_verify_message)              \
     X(tfm_crypto_sign_hash)                   \
     X(tfm_crypto_verify_hash)                 \
     X(tfm_crypto_asymmetric_encrypt)          \
diff --git a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_secure_api.c b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_secure_api.c
index be1d0bad125170f18926906c33ed4388ccb838c4..1d90e9274ac49de98253130043ff9e1fd9a5c12b 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_secure_api.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/tfm_crypto_secure_api.c
@@ -1038,16 +1038,71 @@ psa_status_t psa_aead_decrypt(psa_key_id_t key_id,
 #endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
 }
 
-psa_status_t psa_asymmetric_sign(psa_key_id_t key_id,
-                                 psa_algorithm_t alg,
-                                 const uint8_t *hash,
-                                 size_t hash_length,
-                                 uint8_t *signature,
-                                 size_t signature_size,
-                                 size_t *signature_length)
+psa_status_t psa_sign_message(psa_key_id_t key_id,
+                              psa_algorithm_t alg,
+                              const uint8_t *input,
+                              size_t input_length,
+                              uint8_t *signature,
+                              size_t signature_size,
+                              size_t *signature_length)
+{
+#ifdef TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_SIGN_MESSAGE_SID,
+        .key_id = key_id,
+        .alg = alg,
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = signature, .len = signature_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_sign_message,
+                          TFM_CRYPTO_SIGN_MESSAGE);
+
+    if (status == PSA_SUCCESS) {
+        *signature_length = out_vec[0].len;
+    }
+
+    return status;
+#endif /* TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED */
+}
+
+psa_status_t psa_verify_message(psa_key_id_t key_id,
+                                psa_algorithm_t alg,
+                                const uint8_t *input,
+                                size_t input_length,
+                                const uint8_t *signature,
+                                size_t signature_length)
 {
-    return psa_sign_hash(key_id, alg, hash, hash_length, signature,
-                         signature_size, signature_length);
+#ifdef TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_VERIFY_MESSAGE_SID,
+        .key_id = key_id,
+        .alg = alg
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = signature, .len = signature_length}
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_message,
+                                    TFM_CRYPTO_VERIFY_MESSAGE);
+
+    return status;
+#endif /* TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED */
 }
 
 psa_status_t psa_sign_hash(psa_key_id_t key_id,
@@ -1085,17 +1140,6 @@ psa_status_t psa_sign_hash(psa_key_id_t key_id,
 #endif /* TFM_CRYPTO_ASYM_SIGN_MODULE_DISABLED */
 }
 
-psa_status_t psa_asymmetric_verify(psa_key_id_t key_id,
-                                   psa_algorithm_t alg,
-                                   const uint8_t *hash,
-                                   size_t hash_length,
-                                   const uint8_t *signature,
-                                   size_t signature_length)
-{
-    return psa_verify_hash(key_id, alg, hash, hash_length,
-                           signature, signature_length);
-}
-
 psa_status_t psa_verify_hash(psa_key_id_t key_id,
                              psa_algorithm_t alg,
                              const uint8_t *hash,
@@ -1490,11 +1534,33 @@ psa_status_t psa_mac_compute(psa_key_id_t key_id,
                              size_t mac_size,
                              size_t *mac_length)
 {
+#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_COMPUTE_SID,
+        .key_id = key_id,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = mac, .len = mac_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_mac_compute,
+                          TFM_CRYPTO_MAC_COMPUTE);
+
+    if (status == PSA_SUCCESS) {
+        *mac_length = out_vec[0].len;
+    }
 
     return status;
+#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
 }
 
 psa_status_t psa_mac_verify(psa_key_id_t key_id,
@@ -1504,11 +1570,27 @@ psa_status_t psa_mac_verify(psa_key_id_t key_id,
                             const uint8_t *mac,
                             const size_t mac_length)
 {
+#ifdef TFM_CRYPTO_MAC_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_VERIFY_SID,
+        .key_id = key_id,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = mac, .len = mac_length},
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_mac_verify,
+                                    TFM_CRYPTO_MAC_VERIFY);
 
     return status;
+#endif /* TFM_CRYPTO_MAC_MODULE_DISABLED */
 }
 
 psa_status_t psa_cipher_encrypt(psa_key_id_t key_id,
@@ -1519,11 +1601,33 @@ psa_status_t psa_cipher_encrypt(psa_key_id_t key_id,
                                 size_t output_size,
                                 size_t *output_length)
 {
+#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_ENCRYPT_SID,
+        .key_id = key_id,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_encrypt,
+                          TFM_CRYPTO_CIPHER_ENCRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
+#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
 }
 
 psa_status_t psa_cipher_decrypt(psa_key_id_t key_id,
@@ -1534,11 +1638,33 @@ psa_status_t psa_cipher_decrypt(psa_key_id_t key_id,
                                 size_t output_size,
                                 size_t *output_length)
 {
+#ifdef TFM_CRYPTO_CIPHER_MODULE_DISABLED
+    return PSA_ERROR_NOT_SUPPORTED;
+#else
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_DECRYPT_SID,
+        .key_id = key_id,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_decrypt,
+                          TFM_CRYPTO_CIPHER_DECRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
+#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
 }
 
 psa_status_t psa_raw_key_agreement(psa_algorithm_t alg,
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_bl2.S b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_bl2.S
index 82c88615fb1db3d5b27ec02ae7e4c7b1afb5ab22..81bc1c6c4c6364b2ee5363b551cf10039c2e6159 100644
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_bl2.S
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/Device/Source/armgcc/startup_LPC55S69_cm33_core0_bl2.S
@@ -1,5 +1,5 @@
 ;/*
-; * Copyright (c) 2009-2018 ARM Limited
+; * Copyright (c) 2009-2020 Arm Limited
 ; *
 ; * Licensed under the Apache License, Version 2.0 (the "License");
 ; * you may not use this file except in compliance with the License.
@@ -17,6 +17,8 @@
 ; * This file is derivative of CMSIS V5.00 startup_ARMCM33.S
 ; */
 
+#include "tfm_plat_config.h"
+
     .syntax    unified
     .arch    armv8-m.main
 
@@ -41,68 +43,67 @@ __Vectors:
     .long   PendSV_Handler                                  /* PendSV Handler*/
     .long   SysTick_Handler                                 /* SysTick Handler*/
 
-    /* External Interrupts */
-    .long   WDT_BOD_IRQHandler  /* Windowed watchdog timer, Brownout detect, Flash interrupt */
-    .long   DMA0_IRQHandler  /* DMA0 controller */
-    .long   GINT0_IRQHandler  /* GPIO group 0 */
-    .long   GINT1_IRQHandler  /* GPIO group 1 */
-    .long   PIN_INT0_IRQHandler  /* Pin interrupt 0 or pattern match engine slice 0 */
-    .long   PIN_INT1_IRQHandler  /* Pin interrupt 1or pattern match engine slice 1 */
-    .long   PIN_INT2_IRQHandler  /* Pin interrupt 2 or pattern match engine slice 2 */
-    .long   PIN_INT3_IRQHandler  /* Pin interrupt 3 or pattern match engine slice 3 */
-    .long   UTICK0_IRQHandler  /* Micro-tick Timer */
-    .long   MRT0_IRQHandler  /* Multi-rate timer */
-    .long   CTIMER0_IRQHandler  /* Standard counter/timer CTIMER0 */
-    .long   CTIMER1_IRQHandler  /* Standard counter/timer CTIMER1 */
-    .long   SCT0_IRQHandler  /* SCTimer/PWM */
-    .long   CTIMER3_IRQHandler  /* Standard counter/timer CTIMER3 */
-    .long   FLEXCOMM0_IRQHandler  /* Flexcomm Interface 0 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM1_IRQHandler  /* Flexcomm Interface 1 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM2_IRQHandler  /* Flexcomm Interface 2 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM3_IRQHandler  /* Flexcomm Interface 3 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM4_IRQHandler  /* Flexcomm Interface 4 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM5_IRQHandler  /* Flexcomm Interface 5 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM6_IRQHandler  /* Flexcomm Interface 6 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   FLEXCOMM7_IRQHandler  /* Flexcomm Interface 7 (USART, SPI, I2C, I2S, FLEXCOMM) */
-    .long   ADC0_IRQHandler  /* ADC0  */
-    .long   Reserved39_IRQHandler  /* Reserved interrupt */
-    .long   ACMP_IRQHandler  /* ACMP  interrupts */
-    .long   Reserved41_IRQHandler  /* Reserved interrupt */
-    .long   Reserved42_IRQHandler  /* Reserved interrupt */
-    .long   USB0_NEEDCLK_IRQHandler  /* USB Activity Wake-up Interrupt */
-    .long   USB0_IRQHandler  /* USB device */
-    .long   RTC_IRQHandler  /* RTC alarm and wake-up interrupts */
-    .long   Reserved46_IRQHandler  /* Reserved interrupt */
-    .long   MAILBOX_IRQHandler  /* WAKEUP,Mailbox interrupt (present on selected devices) */
-    .long   PIN_INT4_IRQHandler  /* Pin interrupt 4 or pattern match engine slice 4 int */
-    .long   PIN_INT5_IRQHandler  /* Pin interrupt 5 or pattern match engine slice 5 int */
-    .long   PIN_INT6_IRQHandler  /* Pin interrupt 6 or pattern match engine slice 6 int */
-    .long   PIN_INT7_IRQHandler  /* Pin interrupt 7 or pattern match engine slice 7 int */
-    .long   CTIMER2_IRQHandler  /* Standard counter/timer CTIMER2 */
-    .long   CTIMER4_IRQHandler  /* Standard counter/timer CTIMER4 */
-    .long   OS_EVENT_IRQHandler  /* OSEVTIMER0 and OSEVTIMER0_WAKEUP interrupts */
-    .long   Reserved55_IRQHandler  /* Reserved interrupt */
-    .long   Reserved56_IRQHandler  /* Reserved interrupt */
-    .long   Reserved57_IRQHandler  /* Reserved interrupt */
-    .long   SDIO_IRQHandler  /* SD/MMC  */
-    .long   Reserved59_IRQHandler  /* Reserved interrupt */
-    .long   Reserved60_IRQHandler  /* Reserved interrupt */
-    .long   Reserved61_IRQHandler  /* Reserved interrupt */
-    .long   USB1_UTMI_IRQHandler  /* USB1_UTMI */
-    .long   USB1_IRQHandler  /* USB1 interrupt */
-    .long   USB1_NEEDCLK_IRQHandler  /* USB1 activity */
-    .long   SEC_HYPERVISOR_CALL_IRQHandler  /* SEC_HYPERVISOR_CALL interrupt */
-    .long   SEC_GPIO_INT0_IRQ0_IRQHandler  /* SEC_GPIO_INT0_IRQ0 interrupt */
-    .long   SEC_GPIO_INT0_IRQ1_IRQHandler  /* SEC_GPIO_INT0_IRQ1 interrupt */
-    .long   PLU_IRQHandler  /* PLU interrupt */
-    .long   SEC_VIO_IRQHandler  /* SEC_VIO interrupt */
-    .long   HASHCRYPT_IRQHandler  /* HASHCRYPT interrupt */
-    .long   CASER_IRQHandler  /* CASPER interrupt */
-    .long   PUF_IRQHandler  /* PUF interrupt */
-    .long   PQ_IRQHandler  /* PQ interrupt */
-    .long   DMA1_IRQHandler  /* DMA1 interrupt */
-    .long   LSPI_HS_IRQHandler  /* Flexcomm Interface 8 (SPI, , FLEXCOMM) */
-
+                                                            /* External Interrupts*/
+    .long    WDT_BOD_IRQHandler                              /* Windowed watchdog timer, Brownout detect, Flash interrupt */
+    .long    DMA0_IRQHandler                              /* DMA0 controller */
+    .long    GINT0_IRQHandler                              /* GPIO group 0 */
+    .long    GINT1_IRQHandler                              /* GPIO group 1 */
+    .long    PIN_INT0_IRQHandler                              /* Pin interrupt 0 or pattern match engine slice 0 */
+    .long    PIN_INT1_IRQHandler                              /* Pin interrupt 1or pattern match engine slice 1 */
+    .long    PIN_INT2_IRQHandler                              /* Pin interrupt 2 or pattern match engine slice 2 */
+    .long    PIN_INT3_IRQHandler                              /* Pin interrupt 3 or pattern match engine slice 3 */
+    .long    UTICK0_IRQHandler                              /* Micro-tick Timer */
+    .long    MRT0_IRQHandler                              /* Multi-rate timer */
+    .long    CTIMER0_IRQHandler                              /* Standard counter/timer CTIMER0 */
+    .long    CTIMER1_IRQHandler                              /* Standard counter/timer CTIMER1 */
+    .long    SCT0_IRQHandler                              /* SCTimer/PWM */
+    .long    CTIMER3_IRQHandler                              /* Standard counter/timer CTIMER3 */
+    .long    FLEXCOMM0_IRQHandler                              /* Flexcomm Interface 0 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM1_IRQHandler                              /* Flexcomm Interface 1 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM2_IRQHandler                              /* Flexcomm Interface 2 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM3_IRQHandler                              /* Flexcomm Interface 3 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM4_IRQHandler                              /* Flexcomm Interface 4 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM5_IRQHandler                              /* Flexcomm Interface 5 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM6_IRQHandler                              /* Flexcomm Interface 6 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    FLEXCOMM7_IRQHandler                              /* Flexcomm Interface 7 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    .long    ADC0_IRQHandler                              /* ADC0  */
+    .long    Reserved39_IRQHandler                              /* Reserved interrupt */
+    .long    ACMP_IRQHandler                              /* ACMP  interrupts */
+    .long    Reserved41_IRQHandler                              /* Reserved interrupt */
+    .long    Reserved42_IRQHandler                              /* Reserved interrupt */
+    .long    USB0_NEEDCLK_IRQHandler                              /* USB Activity Wake-up Interrupt */
+    .long    USB0_IRQHandler                              /* USB device */
+    .long    RTC_IRQHandler                              /* RTC alarm and wake-up interrupts */
+    .long    Reserved46_IRQHandler                              /* Reserved interrupt */
+    .long    MAILBOX_IRQHandler                              /* WAKEUP,Mailbox interrupt (present on selected devices) */
+    .long    PIN_INT4_IRQHandler                              /* Pin interrupt 4 or pattern match engine slice 4 int */
+    .long    PIN_INT5_IRQHandler                              /* Pin interrupt 5 or pattern match engine slice 5 int */
+    .long    PIN_INT6_IRQHandler                              /* Pin interrupt 6 or pattern match engine slice 6 int */
+    .long    PIN_INT7_IRQHandler                              /* Pin interrupt 7 or pattern match engine slice 7 int */
+    .long    CTIMER2_IRQHandler                              /* Standard counter/timer CTIMER2 */
+    .long    CTIMER4_IRQHandler                              /* Standard counter/timer CTIMER4 */
+    .long    OS_EVENT_IRQHandler                              /* OSEVTIMER0 and OSEVTIMER0_WAKEUP interrupts */
+    .long    Reserved55_IRQHandler                              /* Reserved interrupt */
+    .long    Reserved56_IRQHandler                              /* Reserved interrupt */
+    .long    Reserved57_IRQHandler                              /* Reserved interrupt */
+    .long    SDIO_IRQHandler                              /* SD/MMC  */
+    .long    Reserved59_IRQHandler                              /* Reserved interrupt */
+    .long    Reserved60_IRQHandler                              /* Reserved interrupt */
+    .long    Reserved61_IRQHandler                              /* Reserved interrupt */
+    .long    USB1_PHY_IRQHandler                              /* USB1_PHY */
+    .long    USB1_IRQHandler                              /* USB1 interrupt */
+    .long    USB1_NEEDCLK_IRQHandler                              /* USB1 activity */
+    .long    SEC_HYPERVISOR_CALL_IRQHandler                              /* SEC_HYPERVISOR_CALL interrupt */
+    .long    SEC_GPIO_INT0_IRQ0_IRQHandler                              /* SEC_GPIO_INT0_IRQ0 interrupt */
+    .long    SEC_GPIO_INT0_IRQ1_IRQHandler                              /* SEC_GPIO_INT0_IRQ1 interrupt */
+    .long    PLU_IRQHandler                              /* PLU interrupt */
+    .long    SEC_VIO_IRQHandler                              /* SEC_VIO interrupt */
+    .long    HASHCRYPT_IRQHandler                              /* HASHCRYPT interrupt */
+    .long    CASER_IRQHandler                              /* CASPER interrupt */
+    .long    PUF_IRQHandler                              /* PUF interrupt */
+    .long    PQ_IRQHandler                              /* PQ interrupt */
+    .long    DMA1_IRQHandler                              /* DMA1 interrupt */
+    .long    FLEXCOMM8_IRQHandler                              /* Flexcomm Interface 8 (SPI, , FLEXCOMM) */
     .size    __Vectors, . - __Vectors
 
     .text
@@ -716,12 +717,12 @@ Reserved61_IRQHandler:
 
     .align 1
     .thumb_func
-    .weak USB1_UTMI_IRQHandler
-    .type USB1_UTMI_IRQHandler, %function
-USB1_UTMI_IRQHandler:
-    ldr   r0,=USB1_UTMI_DriverIRQHandler
+    .weak USB1_PHY_IRQHandler
+    .type USB1_PHY_IRQHandler, %function
+USB1_PHY_IRQHandler:
+    ldr   r0,=USB1_PHY_DriverIRQHandler
     bx    r0
-    .size USB1_UTMI_IRQHandler, . - USB1_UTMI_IRQHandler
+    .size USB1_PHY_IRQHandler, . - USB1_PHY_IRQHandler
 
     .align 1
     .thumb_func
@@ -833,12 +834,12 @@ DMA1_IRQHandler:
 
     .align 1
     .thumb_func
-    .weak LSPI_HS_IRQHandler
-    .type LSPI_HS_IRQHandler, %function
-LSPI_HS_IRQHandler:
-    ldr   r0,=LSPI_HS_DriverIRQHandler
+    .weak FLEXCOMM8_IRQHandler
+    .type FLEXCOMM8_IRQHandler, %function
+FLEXCOMM8_IRQHandler:
+    ldr   r0,=FLEXCOMM8_DriverIRQHandler
     bx    r0
-    .size LSPI_HS_IRQHandler, . - LSPI_HS_IRQHandler
+    .size FLEXCOMM8_IRQHandler, . - FLEXCOMM8_IRQHandler
 
 /*    Macro to define default handlers. Default handler
  *    will be weak symbol and just dead loops. They can be
@@ -853,65 +854,65 @@ LSPI_HS_IRQHandler:
     def_irq_handler    UsageFault_Handler
     def_irq_handler    SecureFault_Handler
     def_irq_handler    DebugMon_Handler
-                def_irq_handler     WDT_BOD_DriverIRQHandler
-                def_irq_handler     DMA0_DriverIRQHandler
-                def_irq_handler     GINT0_DriverIRQHandler
-                def_irq_handler     GINT1_DriverIRQHandler
-                def_irq_handler     PIN_INT0_DriverIRQHandler
-                def_irq_handler     PIN_INT1_DriverIRQHandler
-                def_irq_handler     PIN_INT2_DriverIRQHandler
-                def_irq_handler     PIN_INT3_DriverIRQHandler
-                def_irq_handler     UTICK0_DriverIRQHandler
-                def_irq_handler     MRT0_DriverIRQHandler
-                def_irq_handler     CTIMER0_DriverIRQHandler
-                def_irq_handler     CTIMER1_DriverIRQHandler
-                def_irq_handler     SCT0_DriverIRQHandler
-                def_irq_handler     CTIMER3_DriverIRQHandler
-                def_irq_handler     FLEXCOMM0_DriverIRQHandler
-                def_irq_handler     FLEXCOMM1_DriverIRQHandler
-                def_irq_handler     FLEXCOMM2_DriverIRQHandler
-                def_irq_handler     FLEXCOMM3_DriverIRQHandler
-                def_irq_handler     FLEXCOMM4_DriverIRQHandler
-                def_irq_handler     FLEXCOMM5_DriverIRQHandler
-                def_irq_handler     FLEXCOMM6_DriverIRQHandler
-                def_irq_handler     FLEXCOMM7_DriverIRQHandler
-                def_irq_handler     ADC0_DriverIRQHandler
-                def_irq_handler     Reserved39_DriverIRQHandler
-                def_irq_handler     ACMP_DriverIRQHandler
-                def_irq_handler     Reserved41_DriverIRQHandler
-                def_irq_handler     Reserved42_DriverIRQHandler
-                def_irq_handler     USB0_NEEDCLK_DriverIRQHandler
-                def_irq_handler     USB0_DriverIRQHandler
-                def_irq_handler     RTC_DriverIRQHandler
-                def_irq_handler     Reserved46_DriverIRQHandler
-                def_irq_handler     MAILBOX_DriverIRQHandler
-                def_irq_handler     PIN_INT4_DriverIRQHandler
-                def_irq_handler     PIN_INT5_DriverIRQHandler
-                def_irq_handler     PIN_INT6_DriverIRQHandler
-                def_irq_handler     PIN_INT7_DriverIRQHandler
-                def_irq_handler     CTIMER2_DriverIRQHandler
-                def_irq_handler     CTIMER4_DriverIRQHandler
-                def_irq_handler     OS_EVENT_DriverIRQHandler
-                def_irq_handler     Reserved55_DriverIRQHandler
-                def_irq_handler     Reserved56_DriverIRQHandler
-                def_irq_handler     Reserved57_DriverIRQHandler
-                def_irq_handler     SDIO_DriverIRQHandler
-                def_irq_handler     Reserved59_DriverIRQHandler
-                def_irq_handler     Reserved60_DriverIRQHandler
-                def_irq_handler     Reserved61_DriverIRQHandler
-                def_irq_handler     USB1_UTMI_DriverIRQHandler
-                def_irq_handler     USB1_DriverIRQHandler
-                def_irq_handler     USB1_NEEDCLK_DriverIRQHandler
-                def_irq_handler     SEC_HYPERVISOR_CALL_DriverIRQHandler
-                def_irq_handler     SEC_GPIO_INT0_IRQ0_DriverIRQHandler
-                def_irq_handler     SEC_GPIO_INT0_IRQ1_DriverIRQHandler
-                def_irq_handler     PLU_DriverIRQHandler
-                def_irq_handler     SEC_VIO_DriverIRQHandler
-                def_irq_handler     HASHCRYPT_DriverIRQHandler
-                def_irq_handler     CASER_DriverIRQHandler
-                def_irq_handler     PUF_DriverIRQHandler
-                def_irq_handler     PQ_DriverIRQHandler
-                def_irq_handler     DMA1_DriverIRQHandler
-                def_irq_handler     LSPI_HS_DriverIRQHandler
+    def_irq_handler    WDT_BOD_DriverIRQHandler              /* Windowed watchdog timer, Brownout detect, Flash interrupt */
+    def_irq_handler    DMA0_DriverIRQHandler              /* DMA0 controller */
+    def_irq_handler    GINT0_DriverIRQHandler              /* GPIO group 0 */
+    def_irq_handler    GINT1_DriverIRQHandler              /* GPIO group 1 */
+    def_irq_handler    PIN_INT0_DriverIRQHandler              /* Pin interrupt 0 or pattern match engine slice 0 */
+    def_irq_handler    PIN_INT1_DriverIRQHandler              /* Pin interrupt 1or pattern match engine slice 1 */
+    def_irq_handler    PIN_INT2_DriverIRQHandler              /* Pin interrupt 2 or pattern match engine slice 2 */
+    def_irq_handler    PIN_INT3_DriverIRQHandler              /* Pin interrupt 3 or pattern match engine slice 3 */
+    def_irq_handler    UTICK0_DriverIRQHandler              /* Micro-tick Timer */
+    def_irq_handler    MRT0_DriverIRQHandler              /* Multi-rate timer */
+    def_irq_handler    CTIMER0_DriverIRQHandler              /* Standard counter/timer CTIMER0 */
+    def_irq_handler    CTIMER1_DriverIRQHandler              /* Standard counter/timer CTIMER1 */
+    def_irq_handler    SCT0_DriverIRQHandler              /* SCTimer/PWM */
+    def_irq_handler    CTIMER3_DriverIRQHandler              /* Standard counter/timer CTIMER3 */
+    def_irq_handler    FLEXCOMM0_DriverIRQHandler              /* Flexcomm Interface 0 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM1_DriverIRQHandler              /* Flexcomm Interface 1 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM2_DriverIRQHandler              /* Flexcomm Interface 2 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM3_DriverIRQHandler              /* Flexcomm Interface 3 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM4_DriverIRQHandler              /* Flexcomm Interface 4 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM5_DriverIRQHandler              /* Flexcomm Interface 5 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM6_DriverIRQHandler              /* Flexcomm Interface 6 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    FLEXCOMM7_DriverIRQHandler              /* Flexcomm Interface 7 (USART, SPI, I2C, I2S, FLEXCOMM) */
+    def_irq_handler    ADC0_DriverIRQHandler              /* ADC0  */
+    def_irq_handler    Reserved39_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    ACMP_DriverIRQHandler              /* ACMP  interrupts */
+    def_irq_handler    Reserved41_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    Reserved42_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    USB0_NEEDCLK_DriverIRQHandler              /* USB Activity Wake-up Interrupt */
+    def_irq_handler    USB0_DriverIRQHandler              /* USB device */
+    def_irq_handler    RTC_DriverIRQHandler              /* RTC alarm and wake-up interrupts */
+    def_irq_handler    Reserved46_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    MAILBOX_DriverIRQHandler              /* WAKEUP,Mailbox interrupt (present on selected devices) */
+    def_irq_handler    PIN_INT4_DriverIRQHandler              /* Pin interrupt 4 or pattern match engine slice 4 int */
+    def_irq_handler    PIN_INT5_DriverIRQHandler              /* Pin interrupt 5 or pattern match engine slice 5 int */
+    def_irq_handler    PIN_INT6_DriverIRQHandler              /* Pin interrupt 6 or pattern match engine slice 6 int */
+    def_irq_handler    PIN_INT7_DriverIRQHandler              /* Pin interrupt 7 or pattern match engine slice 7 int */
+    def_irq_handler    CTIMER2_DriverIRQHandler              /* Standard counter/timer CTIMER2 */
+    def_irq_handler    CTIMER4_DriverIRQHandler              /* Standard counter/timer CTIMER4 */
+    def_irq_handler    OS_EVENT_DriverIRQHandler              /* OSEVTIMER0 and OSEVTIMER0_WAKEUP interrupts */
+    def_irq_handler    Reserved55_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    Reserved56_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    Reserved57_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    SDIO_DriverIRQHandler              /* SD/MMC  */
+    def_irq_handler    Reserved59_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    Reserved60_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    Reserved61_DriverIRQHandler              /* Reserved interrupt */
+    def_irq_handler    USB1_PHY_DriverIRQHandler              /* USB1_PHY */
+    def_irq_handler    USB1_DriverIRQHandler              /* USB1 interrupt */
+    def_irq_handler    USB1_NEEDCLK_DriverIRQHandler              /* USB1 activity */
+    def_irq_handler    SEC_HYPERVISOR_CALL_DriverIRQHandler              /* SEC_HYPERVISOR_CALL interrupt */
+    def_irq_handler    SEC_GPIO_INT0_IRQ0_DriverIRQHandler              /* SEC_GPIO_INT0_IRQ0 interrupt */
+    def_irq_handler    SEC_GPIO_INT0_IRQ1_DriverIRQHandler              /* SEC_GPIO_INT0_IRQ1 interrupt */
+    def_irq_handler    PLU_DriverIRQHandler              /* PLU interrupt */
+    def_irq_handler    SEC_VIO_DriverIRQHandler              /* SEC_VIO interrupt */
+    def_irq_handler    HASHCRYPT_DriverIRQHandler              /* HASHCRYPT interrupt */
+    def_irq_handler    CASER_DriverIRQHandler              /* CASPER interrupt */
+    def_irq_handler    PUF_DriverIRQHandler              /* PUF interrupt */
+    def_irq_handler    PQ_DriverIRQHandler              /* PQ interrupt */
+    def_irq_handler    DMA1_DriverIRQHandler              /* DMA1 interrupt */
+    def_irq_handler    FLEXCOMM8_DriverIRQHandler              /* Flexcomm Interface 8 (SPI, , FLEXCOMM) */
 
     .end
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h
index 3841f942a002a8cbdce56dc9b7485cefe25029b8..f02b524e03812fb643748022b2a48c587ae0e8bc 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.h
@@ -45,6 +45,7 @@ struct tfm_core_thread_t {
     void            *param;             /* entry parameter              */
     uintptr_t       stk_btm;            /* stack bottom (lower address) */
     uintptr_t       stk_top;            /* stack top    (higher address)*/
+    uintptr_t       flih_ctx;           /* FLIH context pointer         */
     uint32_t        prior;              /* priority                     */
     uint32_t        state;              /* state                        */
 
@@ -81,7 +82,7 @@ void tfm_core_thrd_init(struct tfm_core_thread_t *pth,
  *  Set thread priority. Priority is set to THRD_PRIOR_MEDIUM in
  *  tfm_core_thrd_init().
  */
-void __STATIC_INLINE tfm_core_thrd_set_priority(struct tfm_core_thread_t *pth,
+__STATIC_INLINE void tfm_core_thrd_set_priority(struct tfm_core_thread_t *pth,
                                                 uint32_t prior)
 {
     pth->prior &= ~THRD_PRIOR_MASK;
@@ -98,7 +99,7 @@ void __STATIC_INLINE tfm_core_thrd_set_priority(struct tfm_core_thread_t *pth,
  * Notes
  *  Reuse prior of thread context to shift down non-secure thread priority.
  */
-void __STATIC_INLINE tfm_core_thrd_set_secure(struct tfm_core_thread_t *pth,
+__STATIC_INLINE void tfm_core_thrd_set_secure(struct tfm_core_thread_t *pth,
                                               uint32_t attr_secure)
 {
     pth->prior &= ~THRD_ATTR_NON_SECURE;
@@ -129,7 +130,7 @@ void tfm_core_thrd_set_state(struct tfm_core_thread_t *pth, uint32_t new_state);
  * Return :
  *  State of thread
  */
-uint32_t __STATIC_INLINE tfm_core_thrd_get_state(struct tfm_core_thread_t *pth)
+__STATIC_INLINE uint32_t tfm_core_thrd_get_state(struct tfm_core_thread_t *pth)
 {
     return pth->state;
 }
@@ -145,7 +146,7 @@ uint32_t __STATIC_INLINE tfm_core_thrd_get_state(struct tfm_core_thread_t *pth)
  *  This API is useful for blocked syscall blocking thread. Syscall
  *  could set its return value to the caller before caller goes.
  */
-void __STATIC_INLINE tfm_core_thrd_set_retval(struct tfm_core_thread_t *pth,
+__STATIC_INLINE void tfm_core_thrd_set_retval(struct tfm_core_thread_t *pth,
                                               uint32_t retval)
 {
     TFM_STATE_RET_VAL(&pth->arch_ctx) = retval;
@@ -174,6 +175,18 @@ uint32_t tfm_core_thrd_start(struct tfm_core_thread_t *pth);
  */
 struct tfm_core_thread_t *tfm_core_thrd_get_curr(void);
 
+/*
+ * Set the current running thread
+ * Note:
+ *  This API is intended to update the current thread in FLIH handling.
+ *  So that in nested FLIH interrupts, the handler knows which isolation
+ *  boundary was preempted.
+ *  Although the CURR_THRD is updated, it does not mean the running Partition
+ *  thread is changed. It could also be the FLIH function which runs with the
+ *  same isolation boundary of the CURR_THRD.
+ */
+void tfm_core_thrd_set_curr(struct tfm_core_thread_t *pth);
+
 /*
  * Get next thread to run in list.
  *
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
index b9031a8b1251a7610fec1d919e9dc1e475f98c96..15bfc0055d820b5ce2e12a713d5a28364b14870b 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/src/tfm_platform_system.c
@@ -8,6 +8,8 @@
 #include "tfm_platform_system.h"
 #include "target_cfg.h"
 #include "cmsis.h"
+#include "tfm_ioctl_api.h"
+#include "string.h"
 
 void tfm_platform_hal_system_reset(void)
 {
@@ -22,10 +24,14 @@ enum tfm_platform_err_t tfm_platform_hal_ioctl(tfm_platform_ioctl_req_t request,
                                                psa_invec  *in_vec,
                                                psa_outvec *out_vec)
 {
-    (void)request;
-    (void)in_vec;
     (void)out_vec;
 
+    if (request == TFM_PLATFORM_IOCTL_MEMCPY_SERVICE) {
+        tfm_pin_service_args_t* args = (tfm_pin_service_args_t*)in_vec;
+        memcpy(args->dest, args->source, args->size);
+        return TFM_PLATFORM_ERR_SUCCESS;
+    }
+
     /* Not needed for this platform */
     return TFM_PLATFORM_ERR_NOT_SUPPORTED;
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h b/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
index 2fbaa257632a7e022dbb68cb98d54c79ce7035d3..568b456c7b065de13465e3ecdcea7e365dd7fc92 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/include/spm_func.h
@@ -13,6 +13,7 @@
 #include "spm_partition_defs.h"
 #include "tfm_arch.h"
 #include "psa/client.h"
+#include "tfm_api.h"
 
 #define SPM_PARTITION_STATE_UNINIT       0
 #define SPM_PARTITION_STATE_IDLE         1
@@ -271,16 +272,17 @@ void tfm_spm_partition_set_signal_mask(uint32_t partition_idx,
 void tfm_spm_secure_api_init_done(void);
 
 /**
- * \brief Called if veneer is running in thread mode
+ * \brief Called for requests or returns from partition
  */
-uint32_t tfm_spm_partition_request_svc_handler(
-        const uint32_t *svc_args, uint32_t lr);
+void tfm_spm_partition_request_return_handler(
+        const uint32_t *svc_args, uint32_t exc_return, uint32_t *msp);
 
 /**
- * \brief Called when secure service returns
+ * \brief Called when SPM has completed a partition request or return
  */
-uint32_t tfm_spm_partition_return_handler(uint32_t lr);
-
+void tfm_spm_partition_completion_handler(enum tfm_status_e res,
+                                          uint32_t exc_return,
+                                          uint32_t *msp);
 /**
  * \brief Stores caller's client id in state context
  */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.h b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.h
index 65c80233fc7340af2ca2ae6ee0482c356c3afbf4..59ab0fa95c37e8e9d733384a50d08bc1678b296e 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.h
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.h
@@ -10,7 +10,7 @@
  *
  */
 /*
- *  Copyright (C) 2006-2018, Arm Limited (or its affiliates), All Rights Reserved
+ *  Copyright (C) 2006-2021, Arm Limited (or its affiliates), All Rights Reserved
  *  Copyright (C) 2020, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -50,37 +50,37 @@ extern "C" {
  */
 typedef struct mbedtls_rsa_context
 {
-    int ver;                    /*!<  Always 0.*/
-    size_t len;                 /*!<  The size of \p N in Bytes. */
+    int MBEDTLS_PRIVATE(ver);        /*!<  Always 0.*/
+    size_t MBEDTLS_PRIVATE(len);     /*!<  The size of \p N in Bytes. */
 
-    mbedtls_mpi N;              /*!<  The public modulus. */
-    mbedtls_mpi E;              /*!<  The public exponent. */
+    mbedtls_mpi MBEDTLS_PRIVATE(N);  /*!<  The public modulus. */
+    mbedtls_mpi MBEDTLS_PRIVATE(E);  /*!<  The public exponent. */
 
-    mbedtls_mpi D;              /*!<  The private exponent. */
-    mbedtls_mpi P;              /*!<  The first prime factor. */
-    mbedtls_mpi Q;              /*!<  The second prime factor. */
+    mbedtls_mpi MBEDTLS_PRIVATE(D);  /*!<  The private exponent. */
+    mbedtls_mpi MBEDTLS_PRIVATE(P);  /*!<  The first prime factor. */
+    mbedtls_mpi MBEDTLS_PRIVATE(Q);  /*!<  The second prime factor. */
 
-    mbedtls_mpi DP;             /*!<  <code>D % (P - 1)</code>. */
-    mbedtls_mpi DQ;             /*!<  <code>D % (Q - 1)</code>. */
-    mbedtls_mpi QP;             /*!<  <code>1 / (Q % P)</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(DP); /*!<  <code>D % (P - 1)</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(DQ); /*!<  <code>D % (Q - 1)</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(QP); /*!<  <code>1 / (Q % P)</code>. */
 
-    mbedtls_mpi RN;             /*!<  cached <code>R^2 mod N</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(RN); /*!<  cached <code>R^2 mod N</code>. */
 
-    mbedtls_mpi RP;             /*!<  cached <code>R^2 mod P</code>. */
-    mbedtls_mpi RQ;             /*!<  cached <code>R^2 mod Q</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(RP); /*!<  cached <code>R^2 mod P</code>. */
+    mbedtls_mpi MBEDTLS_PRIVATE(RQ); /*!<  cached <code>R^2 mod Q</code>. */
 
-    mbedtls_mpi Vi;             /*!<  The cached blinding value. */
-    mbedtls_mpi Vf;             /*!<  The cached un-blinding value. */
+    mbedtls_mpi MBEDTLS_PRIVATE(Vi); /*!<  The cached blinding value. */
+    mbedtls_mpi MBEDTLS_PRIVATE(Vf); /*!<  The cached un-blinding value. */
 
-    int padding;                /*!< Selects padding mode:
+    int MBEDTLS_PRIVATE(padding);    /*!< Selects padding mode:
                                      #MBEDTLS_RSA_PKCS_V15 for 1.5 padding and
                                      #MBEDTLS_RSA_PKCS_V21 for OAEP or PSS. */
-    int hash_id;                /*!< Hash identifier of mbedtls_md_type_t type,
+    int MBEDTLS_PRIVATE(hash_id);    /*!< Hash identifier of mbedtls_md_type_t type,
                                      as specified in md.h for use in the MGF
                                      mask generating function used in the
                                      EME-OAEP and EMSA-PSS encodings. */
 #if defined(MBEDTLS_THREADING_C)
-    mbedtls_threading_mutex_t mutex;    /*!<  Thread-safety mutex. */
+    mbedtls_threading_mutex_t MBEDTLS_PRIVATE(mutex);    /*!<  Thread-safety mutex. */
 #endif
 }
 mbedtls_rsa_context;
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
index 30907b20db24f49f94e45848d6b312f63504fb5c..6debc62b38de71c08da6fa173f99646cdd298125 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an524/spm_hal.c
@@ -132,11 +132,9 @@ enum tfm_plat_err_t tfm_spm_hal_init_debug(void)
     return TFM_PLAT_ERR_SUCCESS;
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/arch.c b/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
index 9d453369d68e8a9f02633fbd700899f5977956b2..bf637daba13787f67aa09d4cd08e5846fe65ce73 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/arch.c
@@ -56,6 +56,15 @@ void tfm_disable_irq(psa_signal_t irq_signal)
           : : "I" (TFM_SVC_DISABLE_IRQ));
 }
 
+__attribute__((naked))
+void tfm_sfn_completion(enum tfm_status_e res, uint32_t exc_return, uintptr_t msp)
+{
+    __ASM volatile("MSR msp, r2\n"
+                   "SVC %0\n"
+                   "BX LR\n"
+                   : : "I" (TFM_SVC_SFN_COMPLETION) : );
+}
+
 __attribute__((naked))
 static psa_signal_t psa_wait_internal(psa_signal_t signal_mask,
                                       uint32_t timeout)
@@ -83,6 +92,12 @@ psa_signal_t psa_wait(psa_signal_t signal_mask, uint32_t timeout)
     }
 }
 
+__attribute__((naked))
+void tfm_arch_trigger_exc_return(uint32_t exc_return)
+{
+    __ASM volatile("BX R0");
+}
+
 __attribute__((naked))
 void psa_eoi(psa_signal_t irq_signal)
 {
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h
new file mode 100644
index 0000000000000000000000000000000000000000..754e554900323d95ac3b5e7702e92db769ae0d15
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/services/include/tfm_ioctl_api.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2019, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#ifndef __TFM_IOCTL_API__
+#define __TFM_IOCTL_API__
+
+#include <limits.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include "tfm_api.h"
+#include "tfm_platform_api.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum tfm_platform_ioctl_reqest_types_t {
+    TFM_PLATFORM_IOCTL_MEMCPY_SERVICE,
+} tfm_platform_ioctl_reqest_types_t;
+
+typedef struct tfm_pin_service_args_t {
+    void* dest;
+    void* source;
+    uint32_t size;
+} tfm_pin_service_args_t;
+
+tfm_platform_gpio_port_read(uint32_t pin_mask, uint32_t *data,
+                            uint32_t *result);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TFM_IOCTL_API__ */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c
index ca18e752e59a55a5c0cd93140e7dc4a705e45f62..ef371a1b43d0f39c8b3d9605fd66f707d37cc710 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_thread.c
@@ -44,6 +44,15 @@ struct tfm_core_thread_t *tfm_core_thrd_get_curr(void)
     return CURR_THRD;
 }
 
+void tfm_core_thrd_set_curr(struct tfm_core_thread_t *pth)
+{
+    if (!pth) {
+        tfm_core_panic();
+    }
+
+    CURR_THRD = pth;
+}
+
 /* Insert a new thread into list by descending priority (Highest at head) */
 static void insert_by_prior(struct tfm_core_thread_t **head,
                             struct tfm_core_thread_t *node)
@@ -73,6 +82,7 @@ void tfm_core_thrd_init(struct tfm_core_thread_t *pth,
     pth->param = param;
     pth->stk_btm = stk_btm;
     pth->stk_top = stk_top;
+    pth->flih_ctx = stk_top;
 }
 
 uint32_t tfm_core_thrd_start(struct tfm_core_thread_t *pth)
@@ -134,7 +144,7 @@ void tfm_core_thrd_start_scheduler(struct tfm_core_thread_t *pth)
     TFM_CORE_ASSERT(pth != NULL);
     TFM_CORE_ASSERT(pth->arch_ctx.sp != 0);
 
-    tfm_arch_update_ctx(&pth->arch_ctx);
+    tfm_arch_set_ctx(&pth->arch_ctx);
 
     CURR_THRD = pth;
 
@@ -155,6 +165,8 @@ void tfm_core_thrd_switch_context(struct tfm_arch_ctx_t *p_actx,
     spm_memcpy(&prev->arch_ctx, p_actx, sizeof(*p_actx));
     spm_memcpy(p_actx, &next->arch_ctx, sizeof(next->arch_ctx));
 
+    prev->flih_ctx = prev->arch_ctx.sp;
+
     /* Update current thread indicator */
     CURR_THRD = next;
 }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c b/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
index a06edc144cc40cf07481c836f6918d6da46b5c33..e6412a51923af017a6e0b6184afec73c9a644f30 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/tfm_core_svcalls_func.c
@@ -28,7 +28,6 @@ extern int32_t platform_svc_handlers(uint8_t svc_num,
  */
 #include "tfm_secure_irq_handlers.inc"
 
-
 uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
 {
     uint8_t svc_number = 0;
@@ -61,10 +60,13 @@ uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return)
     }
     switch (svc_number) {
     case TFM_SVC_SFN_REQUEST:
-        retval = tfm_spm_partition_request_svc_handler(svc_args, exc_return);
+        tfm_spm_partition_request_return_handler(svc_args, exc_return, msp);
         break;
     case TFM_SVC_SFN_RETURN:
-        retval = tfm_spm_partition_return_handler(exc_return);
+        tfm_spm_partition_request_return_handler(NULL, exc_return, msp);
+        break;
+    case TFM_SVC_SFN_COMPLETION:
+        tfm_spm_partition_completion_handler(svc_args[0], svc_args[1], msp);
         break;
     case TFM_SVC_SPM_REQUEST:
         tfm_spm_request_handler((struct tfm_state_context_t *)svc_args);
diff --git a/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h b/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
index 58576d3f7be7b123d110f2629da629dec302ae10..5fbc2b229d54269ba7f5cccb224a4d756c18e3c9 100644
--- a/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
+++ b/lib/tf-m/secure_fw/spm/include/tfm_arch_v8m.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -21,6 +21,7 @@
 #define EXC_RETURN_FPU_FRAME_BASIC              (1 << 4)
 #define EXC_RETURN_MODE_THREAD                  (1 << 3)
 #define EXC_RETURN_STACK_PROCESS                (1 << 2)
+#define EXC_RETURN_STACK_MAIN                   (0 << 2)
 #define EXC_RETURN_RES0                         (0 << 1)
 #define EXC_RETURN_EXC_SECURE                   (1)
 
@@ -32,6 +33,13 @@
         EXC_RETURN_STACK_PROCESS | EXC_RETURN_RES0 |            \
         EXC_RETURN_EXC_SECURE
 
+#define EXC_RETURN_THREAD_S_MSP                                 \
+        EXC_RETURN_INDICATOR | EXC_RETURN_RES1 |                \
+        EXC_RETURN_SECURE_STACK | EXC_RETURN_STACK_RULE |       \
+        EXC_RETURN_FPU_FRAME_BASIC | EXC_RETURN_MODE_THREAD |   \
+        EXC_RETURN_STACK_MAIN | EXC_RETURN_RES0 |               \
+        EXC_RETURN_EXC_SECURE
+
 #if defined(__ARM_ARCH_8_1M_MAIN__) || defined(__ARM_ARCH_8M_MAIN__)
 struct tfm_arch_ctx_t {
     uint32_t    r4;
@@ -130,11 +138,22 @@ __STATIC_INLINE uintptr_t tfm_arch_seal_thread_stack(uintptr_t stk)
 }
 
 /**
- * \brief Update architecture context value into hardware
+ * \brief Get architecture context value into context struct
+ *
+ * \param[in] p_actx        Pointer of context data
+ */
+__STATIC_INLINE void tfm_arch_get_ctx(struct tfm_arch_ctx_t *p_actx)
+{
+    p_actx->sp = __get_PSP();
+    p_actx->sp_limit = __get_PSPLIM();
+}
+
+/**
+ * \brief Set architecture context value into hardware
  *
  * \param[in] p_actx        Pointer of context data
  */
-__STATIC_INLINE void tfm_arch_update_ctx(struct tfm_arch_ctx_t *p_actx)
+__STATIC_INLINE void tfm_arch_set_ctx(struct tfm_arch_ctx_t *p_actx)
 {
     __set_PSP(p_actx->sp);
     __set_PSPLIM(p_actx->sp_limit);
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
index c1663d0e5e0cb73d17fb36f69bdbd3fd861669cf..7472f600a8214e2fe216227b784502185dd14ac9 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_medium.h
@@ -491,23 +491,6 @@
 //#define MBEDTLS_ECP_RANDOMIZE_MXZ_ALT
 //#define MBEDTLS_ECP_NORMALIZE_MXZ_ALT
 
-/**
- * \def MBEDTLS_TEST_NULL_ENTROPY
- *
- * Enables testing and use of mbed TLS without any configured entropy sources.
- * This permits use of the library on platforms before an entropy source has
- * been integrated (see for example the MBEDTLS_ENTROPY_HARDWARE_ALT or the
- * MBEDTLS_ENTROPY_NV_SEED switches).
- *
- * WARNING! This switch MUST be disabled in production builds, and is suitable
- * only for development.
- * Enabling the switch negates any security provided by the library.
- *
- * Requires MBEDTLS_ENTROPY_C, MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
- *
- */
-#define MBEDTLS_TEST_NULL_ENTROPY
-
 /**
  * \def MBEDTLS_ENTROPY_HARDWARE_ALT
  *
@@ -793,7 +776,7 @@
  *
  * Uncomment this macro to prevent loading of default entropy functions.
  */
-#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 /**
  * \def MBEDTLS_NO_PLATFORM_ENTROPY
@@ -848,7 +831,7 @@
  * \note The entropy collector will write to the seed file before entropy is
  *       given to an external source, to update it.
  */
-//#define MBEDTLS_ENTROPY_NV_SEED
+#define MBEDTLS_ENTROPY_NV_SEED
 
 /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
  *
@@ -1778,6 +1761,22 @@
  */
 //#define MBEDTLS_SHA1_C
 
+/**
+ * \def MBEDTLS_SHA224_C
+ *
+ * Enable the SHA-224 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA256_C. The library does not currently support enabling
+ *           SHA-224 without SHA-256.
+ *
+ * Module:  library/sha256.c
+ * Caller:  library/md.c
+ *          library/ssl_cookie.c
+ *
+ * This module adds support for SHA-224.
+ */
+#define MBEDTLS_SHA224_C
+
 /**
  * \def MBEDTLS_SHA256_C
  *
@@ -1792,6 +1791,22 @@
  */
 #define MBEDTLS_SHA256_C
 
+/**
+ * \def MBEDTLS_SHA384_C
+ *
+ * Enable the SHA-384 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA512_C
+ *
+ * Module:  library/sha512.c
+ * Caller:  library/md.c
+ *          library/ssl_cli.c
+ *          library/ssl_srv.c
+ *
+ * Comment to disable SHA-384
+ */
+//#define MBEDTLS_SHA384_C
+
 /**
  * \def MBEDTLS_SHA512_C
  *
@@ -1993,6 +2008,8 @@
 
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
+#else
+#include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
 /* Target and application specific configurations
diff --git a/lib/tf-m/interface/include/tfm_crypto_defs.h b/lib/tf-m/interface/include/tfm_crypto_defs.h
index b4c771f2dffea094c8348004557f0136da3bdcf9..5a860b8378b9402cebb6db52ed4ea7feefccf352 100644
--- a/lib/tf-m/interface/include/tfm_crypto_defs.h
+++ b/lib/tf-m/interface/include/tfm_crypto_defs.h
@@ -103,6 +103,8 @@ enum {
     TFM_CRYPTO_AEAD_FINISH_SID,
     TFM_CRYPTO_AEAD_VERIFY_SID,
     TFM_CRYPTO_AEAD_ABORT_SID,
+    TFM_CRYPTO_SIGN_MESSAGE_SID,
+    TFM_CRYPTO_VERIFY_MESSAGE_SID,
     TFM_CRYPTO_SIGN_HASH_SID,
     TFM_CRYPTO_VERIFY_HASH_SID,
     TFM_CRYPTO_ASYMMETRIC_ENCRYPT_SID,
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
index fc41394c53ff6f4e6a829350da32589c2180350e..c63e3ccf9d5bc6544ce76ba504992c43373fa638 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v6m_v7m.c
@@ -8,6 +8,7 @@
 #include <inttypes.h>
 #include "tfm_hal_device_header.h"
 #include "tfm_arch.h"
+#include "svc_num.h"
 #include "exception_info.h"
 
 #if !defined(__ARM_ARCH_6M__) && !defined(__ARM_ARCH_7M__) && \
@@ -86,18 +87,60 @@ void tfm_arch_init_actx(struct tfm_arch_ctx_t *p_actx,
 }
 
 #if defined(__ICCARM__)
-uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return);
+uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
+                              uint32_t *psp);
 #pragma required = tfm_core_svc_handler
 #endif
 
 __attribute__((naked)) void SVC_Handler(void)
 {
     __ASM volatile(
+#if !defined(__ICCARM__)
+    ".syntax unified                        \n"
+#endif
     "MRS     r0, MSP                        \n"
-    "MRS     r1, PSP                        \n"
-    "MOV     r2, lr                         \n"
+    "MOV     r1, lr                         \n"
+    "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
+    "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
     "BL      tfm_core_svc_handler           \n"
-    "BX      r0                             \n"
+    "MOV     lr, r0                         \n"
+    "LDR     r1, [sp]                       \n" /* Original EXC_RETURN */
+    "MOVS    r2, #8                         \n"
+    "ANDS    r0, r2                         \n" /* Mode bit */
+    "ANDS    r1, r2                         \n"
+    "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
+    "BGT     to_flih_func                   \n"
+    "BLT     from_flih_func                 \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
+    "to_flih_func:                          \n"
+    "PUSH    {r4-r7}                        \n"
+    "MOV     r4, r8                         \n"
+    "MOV     r5, r9                         \n"
+    "MOV     r6, r10                        \n"
+    "MOV     r7, r11                        \n"
+    "PUSH    {r4-r7}                        \n"
+    "LDR     r4, =0xFEF5EDA5                \n" /* clear r4-r11 */
+    "MOV     r5, r4                         \n"
+    "MOV     r6, r4                         \n"
+    "MOV     r7, r4                         \n"
+    "MOV     r8, r4                         \n"
+    "MOV     r9, r4                         \n"
+    "MOV     r10, r4                        \n"
+    "MOV     r11, r4                        \n"
+    "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
+    "BX      lr                             \n"
+    "from_flih_func:                        \n"
+    "ADD     sp, #24                        \n"
+    "POP     {r4-r7}                        \n"
+    "MOV     r8, r4                         \n"
+    "MOV     r9, r5                         \n"
+    "MOV     r10, r6                        \n"
+    "MOV     r11, r7                        \n"
+    "POP     {r4-r7}                        \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
     );
 }
 
diff --git a/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h
index acbe3735f9db2f00671334e4db43447d160c5a2e..166890a69fed0835a569bce4984f357ab0142307 100644
--- a/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h
+++ b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.h
@@ -273,9 +273,9 @@ void tfm_spm_psa_panic(void);
  * \retval void
  * \retval "Does not return"  The call is invalid, if one or more of the
  *                            following are true:
- *                            - irq_signal does not belong to the calling
- *                              partition.
- *                            - irq_signal indicates more than one signal.
+ *  \arg                      irq_signal does not belong to the calling
+ *                            partition.
+ *  \arg                      irq_signal indicates more than one signal.
  */
 void tfm_spm_irq_enable(uint32_t *args);
 
@@ -288,10 +288,25 @@ void tfm_spm_irq_enable(uint32_t *args);
  *         1                  The interrupt was enabled prior to this call
  * \retval "Does not return"  The call is invalid, if one or more of the
  *                            following are true:
- *                            - irq_signal does not belong to the calling
- *                              partition.
- *                            - irq_signal indicates more than one signal.
+ * \arg                       irq_signal does not belong to the calling
+ *                            partition.
+ * \arg                       irq_signal indicates more than one signal.
  */
 psa_irq_status_t tfm_spm_irq_disable(uint32_t *args);
 
+/**
+ * \brief SVC handler for \ref psa_reset_signal.
+ *
+ * \param[in] args           Include all input arguments: irq_signal.
+ *
+ * \retval void
+ * \retval "Does not return" if one or more of the following are true:
+ * \arg                      irq_signal is not a signal for an interrupt
+ *                           that is specified with FLIH handling in the Secure
+ *                           Partition manifest.
+ * \arg                      irq_signal indicates more than one signal.
+ * \arg                      irq_signal is not currently asserted.
+ */
+void tfm_spm_psa_reset_signal(uint32_t *args);
+
 #endif /* __PSA_CLIENT_SERVICE_APIS_H__ */
diff --git a/lib/tf-m/secure_fw/partitions/lib/sprt/service_api.c b/lib/tf-m/secure_fw/partitions/lib/sprt/service_api.c
index 72bd536b0939e75066a8de37b445f77983513eb9..f374f9c9bedb9513893be2fde187416170fa1a05 100644
--- a/lib/tf-m/secure_fw/partitions/lib/sprt/service_api.c
+++ b/lib/tf-m/secure_fw/partitions/lib/sprt/service_api.c
@@ -8,6 +8,7 @@
 #include "cmsis_compiler.h"
 #include "service_api.h"
 #ifdef TFM_PSA_API
+#include "psa/service.h"
 #include "svc_num.h"
 #else
 #include "tfm_core_svc.h"
@@ -23,3 +24,14 @@ int32_t tfm_core_get_boot_data(uint8_t major_type,
         "BX     lr\n"
         : : "I" (TFM_SVC_GET_BOOT_DATA));
 }
+
+#ifdef TFM_PSA_API
+/* Entry point when Partition FLIH functions return */
+__attribute__((naked))
+void tfm_flih_func_return(psa_flih_result_t result)
+{
+    __ASM volatile("SVC %0           \n"
+                   "BX  r0           \n"
+                   : : "I" (TFM_SVC_FLIH_FUNC_RETURN));
+}
+#endif /* TFM_PSA_API */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
index 431868751ab1debbec0ba8857389481701aed38b..4a18c1c82f79eef6c983b3887bc101275dceeb9a 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/device_definition.c
@@ -230,18 +230,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_S = {
     &PPC_SSE300_MAIN0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN0_DEV_NS = {
-    &PPC_SSE300_MAIN0_CFG_NS,
-    &PPC_SSE300_MAIN0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -258,18 +246,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_S = {
     &PPC_SSE300_MAIN_EXP0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP0_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP0_CFG_NS,
-    &PPC_SSE300_MAIN_EXP0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -286,18 +262,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_S = {
     &PPC_SSE300_MAIN_EXP1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP1_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP1_CFG_NS,
-    &PPC_SSE300_MAIN_EXP1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -314,18 +278,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_S = {
     &PPC_SSE300_MAIN_EXP2_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP2_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP2_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP2};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP2_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP2_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP2_CFG_NS,
-    &PPC_SSE300_MAIN_EXP2_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_MAIN_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -342,18 +294,6 @@ struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_S = {
     &PPC_SSE300_MAIN_EXP3_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_MAIN_EXP3_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_MAIN_EXP3_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_MAIN_EXP3};
-static struct ppc_sse300_dev_data_t PPC_SSE300_MAIN_EXP3_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_MAIN_EXP3_DEV_NS = {
-    &PPC_SSE300_MAIN_EXP3_CFG_NS,
-    &PPC_SSE300_MAIN_EXP3_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -370,18 +310,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_S = {
     &PPC_SSE300_PERIPH0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH0_DEV_NS = {
-    &PPC_SSE300_PERIPH0_CFG_NS,
-    &PPC_SSE300_PERIPH0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -398,18 +326,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_S = {
     &PPC_SSE300_PERIPH1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH1_DEV_NS = {
-    &PPC_SSE300_PERIPH1_CFG_NS,
-    &PPC_SSE300_PERIPH1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP0_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -426,18 +342,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_S = {
     &PPC_SSE300_PERIPH_EXP0_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP0_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP0_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP0};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP0_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP0_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP0_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP0_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP1_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -454,18 +358,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_S = {
     &PPC_SSE300_PERIPH_EXP1_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP1_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP1_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP1};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP1_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP1_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP1_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP1_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP2_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -482,18 +374,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_S = {
     &PPC_SSE300_PERIPH_EXP2_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP2_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP2_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP2};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP2_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP2_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP2_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP2_DATA_NS };
-#endif
-
 #ifdef PPC_SSE300_PERIPH_EXP3_S
 static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_S = {
     .sacfg_base  = SSE300_SACFG_BASE_S,
@@ -510,18 +390,6 @@ struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_S = {
     &PPC_SSE300_PERIPH_EXP3_DATA_S };
 #endif
 
-#ifdef PPC_SSE300_PERIPH_EXP3_NS
-static struct ppc_sse300_dev_cfg_t PPC_SSE300_PERIPH_EXP3_CFG_NS = {
-    .nsacfg_base = SSE300_NSACFG_BASE_NS,
-    .ppc_name = PPC_SSE300_PERIPH_EXP3};
-static struct ppc_sse300_dev_data_t PPC_SSE300_PERIPH_EXP3_DATA_NS = {
-    .nsacfg_nsp_ppc = 0,
-    .is_initialized = false };
-struct ppc_sse300_dev_t PPC_SSE300_PERIPH_EXP3_DEV_NS = {
-    &PPC_SSE300_PERIPH_EXP3_CFG_NS,
-    &PPC_SSE300_PERIPH_EXP3_DATA_NS };
-#endif
-
 /* System counters */
 #ifdef SYSCOUNTER_CNTRL_ARMV8_M_S
 
@@ -575,7 +443,7 @@ SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS = {
     .base = SYSCNTR_READ_BASE_NS,
 };
 struct syscounter_armv8_m_read_dev_t SYSCOUNTER_READ_ARMV8_M_DEV_NS = {
-    &(SYSCOUNTER_READ_ARMV8_M_DEV_CFG_NS),
+    &(SYSCOUNTER_CNTRL_ARMV8_M_DEV_CFG_NS),
 };
 #endif
 
@@ -807,171 +675,3 @@ struct arm_mps3_io_dev_t MPS3_IO_DEV_NS = {
     .cfg = &(MPS3_IO_DEV_CFG_NS)
 };
 #endif
-
-#ifdef SMSC9220_ETH_S
-static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_S = {
-    .base = ETHERNET_BASE_S
-};
-static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_S = {
-    .state = 0,
-    .wait_ms = 0,
-    .ongoing_packet_length = 0,
-    .ongoing_packet_length_sent = 0,
-    .current_rx_size_words = 0,
-};
-struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_S = {
-    .cfg = &(SMSC9220_ETH_DEV_CFG_S),
-    .data = &(SMSC9220_ETH_DEV_DATA_S),
-};
-#endif
-
-#ifdef SMSC9220_ETH_NS
-static struct smsc9220_eth_dev_cfg_t SMSC9220_ETH_DEV_CFG_NS = {
-    .base = ETHERNET_BASE_NS
-};
-static struct smsc9220_eth_dev_data_t SMSC9220_ETH_DEV_DATA_NS = {
-    .state = 0,
-    .wait_ms = 0,
-    .ongoing_packet_length = 0,
-    .ongoing_packet_length_sent = 0,
-    .current_rx_size_words = 0,
-};
-struct smsc9220_eth_dev_t SMSC9220_ETH_DEV_NS = {
-    .cfg = &(SMSC9220_ETH_DEV_CFG_NS),
-    .data = &(SMSC9220_ETH_DEV_DATA_NS),
-};
-#endif
-
-/* CMSDK GPIO driver structures */
-#ifdef GPIO0_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_S = {
-    .base = GPIO0_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_S = {&(GPIO0_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO0_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO0_CMSDK_DEV_CFG_NS = {
-    .base = GPIO0_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO0_CMSDK_DEV_NS = {&(GPIO0_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO1_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_S = {
-    .base = GPIO1_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_S = {&(GPIO1_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO1_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO1_CMSDK_DEV_CFG_NS = {
-    .base = GPIO1_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO1_CMSDK_DEV_NS = {&(GPIO1_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO2_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_S = {
-    .base = GPIO2_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_S = {&(GPIO2_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO2_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO2_CMSDK_DEV_CFG_NS = {
-    .base = GPIO2_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO2_CMSDK_DEV_NS = {&(GPIO2_CMSDK_DEV_CFG_NS)};
-#endif
-
-#ifdef GPIO3_CMSDK_S
-static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_S = {
-    .base = GPIO3_CMSDK_BASE_S};
-struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_S = {&(GPIO3_CMSDK_DEV_CFG_S)};
-#endif
-
-#ifdef GPIO3_CMSDK_NS
-static const struct gpio_cmsdk_dev_cfg_t GPIO3_CMSDK_DEV_CFG_NS = {
-    .base = GPIO3_CMSDK_BASE_NS};
-struct gpio_cmsdk_dev_t GPIO3_CMSDK_DEV_NS = {&(GPIO3_CMSDK_DEV_CFG_NS)};
-#endif
-
-/* I2C_SBCon driver structures */
-#ifdef I2C0_SBCON_S
-static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_S = {
-    .base = FPGA_SBCon_I2C_AUDIO_BASE_S,
-    .default_freq_hz = 100000,
-    .sleep_us = &wait_us
-};
-static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_S ={
-    .freq_us = 0,
-    .sys_clk = 0,
-    .state = 0
-};
-struct i2c_sbcon_dev_t I2C0_SBCON_DEV_S = {
-    .cfg = &(I2C0_SBCON_DEV_CFG_S),
-    .data = &(I2C0_SBCON_DEV_DATA_S)
-};
-#endif
-
-#ifdef I2C0_SBCON_NS
-static struct i2c_sbcon_dev_cfg_t I2C0_SBCON_DEV_CFG_NS = {
-    .base = FPGA_SBCon_I2C_AUDIO_BASE_NS,
-    .default_freq_hz = 100000,
-    .sleep_us = &wait_us
-};
-static struct i2c_sbcon_dev_data_t I2C0_SBCON_DEV_DATA_NS ={
-    .freq_us = 0,
-    .sys_clk = 0,
-    .state = 0
-};
-struct i2c_sbcon_dev_t I2C0_SBCON_DEV_NS = {
-    .cfg = &(I2C0_SBCON_DEV_CFG_NS),
-    .data = &(I2C0_SBCON_DEV_DATA_NS)
-};
-#endif
-
-/* I2S driver structures */
-#ifdef MPS3_I2S_S
-static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_S = {
-    .base = FPGA_I2S_BASE_S
-};
-struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_S = {
-    &(MPS3_I2S_DEV_CFG_S),
-};
-#endif
-
-#ifdef MPS3_I2S_NS
-static const struct audio_i2s_mps3_dev_cfg_t MPS3_I2S_DEV_CFG_NS = {
-    .base = FPGA_I2S_BASE_NS
-};
-struct audio_i2s_mps3_dev_t MPS3_I2S_DEV_NS = {
-    &(MPS3_I2S_DEV_CFG_NS),
-};
-#endif
-
-/* TGU driver structures */
-#ifdef TGU_ARMV8_M_ITCM_S
-static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_ITCM_DEV_CFG_S = {
-    .base = ITGU_CTRL_BASE
-};
-static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_ITCM_DEV_DATA_S = {
-    .range_list = 0,
-    .nbr_of_ranges = 0,
-    .is_initialized = false
-};
-struct tgu_armv8_m_dev_t TGU_ARMV8_M_ITCM_DEV_S = {
-&(TGU_ARMV8_M_ITCM_DEV_CFG_S),
-&(TGU_ARMV8_M_ITCM_DEV_DATA_S),
-};
-#endif
-
-#ifdef TGU_ARMV8_M_DTCM_S
-static const struct tgu_armv8_m_dev_cfg_t TGU_ARMV8_M_DTCM_DEV_CFG_S = {
-    .base = DTGU_CTRL_BASE
-};
-static struct tgu_armv8_m_dev_data_t TGU_ARMV8_M_DTCM_DEV_DATA_S = {
-    .range_list = 0,
-    .nbr_of_ranges = 0,
-    .is_initialized = false,
-};
-struct tgu_armv8_m_dev_t TGU_ARMV8_M_DTCM_DEV_S = {
-&(TGU_ARMV8_M_DTCM_DEV_CFG_S),
-&(TGU_ARMV8_M_DTCM_DEV_DATA_S),
-};
-#endif
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
index decf6903aa76fcd09de74d380ee038877a3fe33e..5f40447fe367346e754f593e6aa03281c0c5989a 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.c
@@ -6,6 +6,7 @@
  */
 
 #include "ps_utils.h"
+#include "tfm_memory_utils.h"
 
 psa_status_t ps_utils_check_contained_in(uint32_t superset_size,
                                          uint32_t subset_offset,
@@ -26,3 +27,26 @@ psa_status_t ps_utils_check_contained_in(uint32_t superset_size,
 
     return PSA_SUCCESS;
 }
+
+#ifdef PS_ENCRYPTION
+psa_status_t ps_utils_fill_key_label(psa_storage_uid_t uid,
+                                     int32_t client_id,
+                                     uint8_t *buff,
+                                     size_t buff_len)
+{
+
+    if (buff_len < (sizeof(client_id) + sizeof(uid))) {
+        return PSA_ERROR_BUFFER_TOO_SMALL;
+    }
+
+    if (buff == NULL) {
+        return PSA_ERROR_INVALID_ARGUMENT;
+    }
+
+    tfm_memset(buff, 0x0, buff_len);
+    tfm_memcpy(buff, &client_id, sizeof(client_id));
+    tfm_memcpy(buff + sizeof(client_id), &uid, sizeof(uid));
+
+    return PSA_SUCCESS;
+}
+#endif
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c b/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
index 443ea024d4c9f4064a3bb113bdbd3ff2260d038d..252716e483724b07537c51cf1f48d7569e789778 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/spm_func.c
@@ -8,6 +8,7 @@
 #include <stdint.h>
 #include <stdbool.h>
 #include <arm_cmse.h>
+#include "arch.h"
 #include "bitops.h"
 #include "fih.h"
 #include "tfm_nspm.h"
@@ -789,7 +790,7 @@ void tfm_spm_secure_api_init_done(void)
     tfm_secure_api_initializing = 0;
 }
 
-enum tfm_status_e tfm_spm_sfn_request_handler(
+static enum tfm_status_e tfm_spm_sfn_request_handler(
                              struct tfm_sfn_req_s *desc_ptr, uint32_t excReturn)
 {
     enum tfm_status_e res;
@@ -801,14 +802,11 @@ enum tfm_status_e tfm_spm_sfn_request_handler(
         tfm_secure_api_error_handler();
     }
 
-    __disable_irq();
-
     desc_ptr->caller_part_idx = tfm_spm_partition_get_running_partition_idx();
 
     res = tfm_core_check_sfn_parameters(desc_ptr, &iovecs);
     if (res != TFM_SUCCESS) {
         /* The sanity check of iovecs failed. */
-        __enable_irq();
         tfm_secure_api_error_handler();
     }
 
@@ -817,7 +815,6 @@ enum tfm_status_e tfm_spm_sfn_request_handler(
         /* FixMe: error compartmentalization TBD */
         tfm_spm_partition_set_state(
             desc_ptr->caller_part_idx, SPM_PARTITION_STATE_CLOSED);
-        __enable_irq();
         SPMLOG_ERRMSG("Unauthorized service request!\r\n");
         tfm_secure_api_error_handler();
     }
@@ -825,13 +822,10 @@ enum tfm_status_e tfm_spm_sfn_request_handler(
     res = tfm_start_partition(desc_ptr, &iovecs, excReturn);
     if (res != TFM_SUCCESS) {
         /* FixMe: consider possible fault scenarios */
-        __enable_irq();
         SPMLOG_ERRMSG("Failed to process service request!\r\n");
         tfm_secure_api_error_handler();
     }
 
-    __enable_irq();
-
     return res;
 }
 
@@ -900,13 +894,30 @@ int32_t tfm_spm_check_buffer_access(uint32_t  partition_idx,
     return TFM_ERROR_INVALID_PARAMETER;
 }
 
-/* This SVC handler is called if veneer is running in thread mode */
-uint32_t tfm_spm_partition_request_svc_handler(
-        const uint32_t *svc_ctx, uint32_t excReturn)
+static void tfm_spm_partition_requests_thread(struct tfm_sfn_req_s *desc_ptr,
+                                              uint32_t exc_return,
+                                              uint32_t is_return,
+                                              uintptr_t msp)
 {
-    struct tfm_sfn_req_s *desc_ptr;
+    enum tfm_status_e res;
+    uint32_t exc_ret;
 
-    if (!(excReturn & EXC_RETURN_STACK_PROCESS)) {
+    if (!is_return) {
+        res = tfm_spm_sfn_request_handler(desc_ptr, exc_return);
+        exc_ret = EXC_RETURN_SECURE_FUNCTION;
+    } else {
+        res = tfm_return_from_partition(&exc_return);
+        exc_ret = exc_return;
+    }
+    /* Reset MSP at top of stack and do TFM_SVC_SFN_COMPLETION */
+    tfm_sfn_completion(res, exc_ret, msp);
+}
+
+/* This SVC handler is called if veneer is running in thread mode */
+void tfm_spm_partition_request_return_handler(
+        const uint32_t *svc_ctx, uint32_t exc_return, uint32_t *msp)
+{
+    if (!(exc_return & EXC_RETURN_STACK_PROCESS)) {
         /* Service request SVC called with MSP active.
          * Either invalid configuration for Thread mode or SVC called
          * from Handler mode, which is not supported.
@@ -916,13 +927,37 @@ uint32_t tfm_spm_partition_request_svc_handler(
         tfm_secure_api_error_handler();
     }
 
-    desc_ptr = (struct tfm_sfn_req_s *)svc_ctx[0];
+    /* Setup a context on the stack to trigger exception return */
+    struct tfm_state_context_t ctx = {0};
+
+    ctx.r0 = svc_ctx ? svc_ctx[0] : (uintptr_t) NULL;
+    ctx.r1 = exc_return;
+    ctx.r2 = svc_ctx ? 0 : 1;
+    ctx.r3 = (uintptr_t) msp;
+    ctx.xpsr = XPSR_T32;
+    ctx.ra = (uint32_t) tfm_spm_partition_requests_thread & ~0x1UL;
+
+    __set_MSP((uint32_t)&ctx);
+
+    tfm_arch_trigger_exc_return(EXC_RETURN_THREAD_S_MSP);
+}
 
-    if (tfm_spm_sfn_request_handler(desc_ptr, excReturn) != TFM_SUCCESS) {
+void tfm_spm_partition_completion_handler(enum tfm_status_e res, uint32_t exc_return, uint32_t *msp)
+{
+    if (res != TFM_SUCCESS) {
         tfm_secure_api_error_handler();
     }
 
-    return EXC_RETURN_SECURE_FUNCTION;
+    uint32_t msp_stack_val = (uint32_t)msp + sizeof(struct tfm_state_context_t);
+
+    /* Equivalent to a call to __set_MSP() and then tfm_arch_trigger_exc_return
+     * with the exc_return value received as parameter in the handler
+     */
+    __ASM volatile (
+        "MSR msp, %0\n"
+        "MOV R0, %1\n"
+        "BX R0"
+        : : "r" (msp_stack_val), "r" (exc_return) : );
 }
 
 /* This SVC handler is called, if a thread mode execution environment is to
@@ -955,31 +990,6 @@ uint32_t tfm_spm_depriv_req_handler(uint32_t *svc_args, uint32_t excReturn)
     return EXC_RETURN_SECURE_FUNCTION;
 }
 
-/* This SVC handler is called when sfn returns */
-uint32_t tfm_spm_partition_return_handler(uint32_t lr)
-{
-    enum tfm_status_e res;
-
-    if (!(lr & EXC_RETURN_STACK_PROCESS)) {
-        /* Partition return SVC called with MSP active.
-         * This should not happen!
-         */
-        ERROR_MSG("Partition return SVC called with MSP active!");
-        tfm_secure_api_error_handler();
-    }
-
-    res = tfm_return_from_partition(&lr);
-    if (res != TFM_SUCCESS) {
-        /* Unlock errors indicate ctx database corruption or unknown anomalies
-         * Halt execution
-         */
-        ERROR_MSG("Secure API error during unlock!");
-        tfm_secure_api_error_handler();
-    }
-
-    return lr;
-}
-
 /* This SVC handler is called if a deprivileged IRQ handler was executed, and
  * the execution environment is to be set back for the privileged handler mode
  */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/stm32l5xx_hal/Src/stm32l5xx_hal_gtzc.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/stm32l5xx_hal/Src/stm32l5xx_hal_gtzc.c
index 54c00d6bb98e73b16aa6c4bd1bee62e8594935e1..9cdbb1cf5a2363ae8f770c2ac8bbdd37c7fe1642 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/stm32l5xx_hal/Src/stm32l5xx_hal_gtzc.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/stm32l5xx_hal/Src/stm32l5xx_hal_gtzc.c
@@ -474,7 +474,7 @@ HAL_StatusTypeDef HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes(
       || (   (MemBaseAddress == FMC_BANK3)
           && (pMPCWM_Desc->AreaId == GTZC_TZSC_MPCWM_ID2))
       || ((   pMPCWM_Desc->Offset % GTZC_TZSC_MPCWM_GRANULARITY) != 0U)
-      || ((   pMPCWM_Desc->Length % GTZC_TZSC_MPCWM_GRANULARITY) != 0U))
+      || ((   pMPCWM_Desc->size % GTZC_TZSC_MPCWM_GRANULARITY) != 0U))
   {
     return HAL_ERROR;
   }
@@ -544,7 +544,7 @@ HAL_StatusTypeDef HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes(
 
   if (   (pMPCWM_Desc->Offset > size)
       || (   (   pMPCWM_Desc->Offset
-               + pMPCWM_Desc->Length)
+               + pMPCWM_Desc->size)
            > size))
   {
     return HAL_ERROR;
@@ -552,7 +552,7 @@ HAL_StatusTypeDef HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes(
 
   /* write descriptor value */
   reg_value = ((pMPCWM_Desc->Offset / GTZC_TZSC_MPCWM_GRANULARITY) << start_pos) & start_msk;
-  reg_value |= ((pMPCWM_Desc->Length / GTZC_TZSC_MPCWM_GRANULARITY) << length_pos) & length_msk;
+  reg_value |= ((pMPCWM_Desc->size / GTZC_TZSC_MPCWM_GRANULARITY) << length_pos) & length_msk;
   MODIFY_REG(*(__IO uint32_t *)register_address, start_msk | length_msk, reg_value);
 
   return HAL_OK;
diff --git a/lib/tf-m/secure_fw/spm/include/lists.h b/lib/tf-m/secure_fw/spm/include/lists.h
index 41c540a0e11532db880deb366cc6bd5273f9458f..c0962c56212b22b2dc519b7027d0905474032caa 100644
--- a/lib/tf-m/secure_fw/spm/include/lists.h
+++ b/lib/tf-m/secure_fw/spm/include/lists.h
@@ -7,48 +7,76 @@
 #ifndef __LISTS_H__
 #define __LISTS_H__
 
+/********* Bi-directional list operations ********/
 /* Bi-directional list structure */
 struct bi_list_node_t {
-    struct bi_list_node_t *prev;
-    struct bi_list_node_t *next;
+    struct bi_list_node_t *bprev;
+    struct bi_list_node_t *bnext;
 };
 
 /* Init an empty node. */
 #define BI_LIST_INIT_NODE(node) do {              \
-    (node)->next = node;                          \
-    (node)->prev = node;                          \
-} while(0)
+    (node)->bnext = node;                         \
+    (node)->bprev = node;                         \
+} while (0)
 
-/* Insert a new node after (next) current. */
+/* Insert a new node after current node: (bnext) of current. */
 #define BI_LIST_INSERT_AFTER(curr, node) do {     \
-    (node)->next = (curr)->next;                  \
-    (node)->prev = curr;                          \
-    (curr)->next->prev = node;                    \
-    (curr)->next = node;                          \
-} while(0)
+    (node)->bnext = (curr)->bnext;                \
+    (node)->bprev = curr;                         \
+    (curr)->bnext->bprev = node;                  \
+    (curr)->bnext = node;                         \
+} while (0)
 
-/* Add one node into list as the tail (prev) of head. */
+/* Add one node into list as the tail: (bprev) of head. */
 #define BI_LIST_INSERT_BEFORE(curr, node) do {    \
-    (curr)->prev->next = node;                    \
-    (node)->prev = (curr)->prev;                  \
-    (curr)->prev = node;                          \
-    (node)->next = curr;                          \
-} while(0)
+    (curr)->bprev->bnext = node;                  \
+    (node)->bprev = (curr)->bprev;                \
+    (curr)->bprev = node;                         \
+    (node)->bnext = curr;                         \
+} while (0)
 
 /* Remove one node from the list. */
-#define BI_LIST_REMOVE_NODE(node) do       {      \
-    (node)->prev->next = (node)->next;            \
-    (node)->next->prev = (node)->prev;            \
-} while(0)
+#define BI_LIST_REMOVE_NODE(node) do {            \
+    (node)->bprev->bnext = (node)->bnext;         \
+    (node)->bnext->bprev = (node)->bprev;         \
+} while (0)
 
 /* Is the head empty? */
-#define BI_LIST_IS_EMPTY(head)      ((head)->next == (head))
+#define BI_LIST_IS_EMPTY(head)      ((head)->bnext == (head))
 
 /* The node's next node */
-#define BI_LIST_NEXT_NODE(node)     ((node)->next)
+#define BI_LIST_NEXT_NODE(node)     ((node)->bnext)
 
 /* Go through each node of a list */
 #define BI_LIST_FOR_EACH(node, head)              \
-    for (node = (head)->next; node != head; node = (node)->next)
+    for (node = (head)->bnext; node != head; node = (node)->bnext)
+
+/********* Uni-directional list operations ********/
+/*
+ * To use these single linked list operations, a head node must have been
+ * defined already, and the "next" pointer initialized to "NULL". Like:
+ * struct head_t {
+ *      uint32_t data;
+ *      User_Type *next;
+ * } head;
+ */
+
+/* Initialize the head node */
+#define UNI_LISI_INIT_HEAD(head) do {             \
+    if ((head) != NULL) {                         \
+        (head)->next = NULL;                      \
+    }                                             \
+} while (0)
+
+/* Insert a node after current node */
+#define UNI_LIST_INSERT_AFTER(curr, node) do {    \
+    (node)->next = (curr)->next;                  \
+    (curr)->next = node;                          \
+} while (0)
+
+/* Go through each node of a list */
+#define UNI_LIST_FOR_EACH(node, head)             \
+    for (node = (head)->next; node != NULL; node = (node)->next)
 
 #endif /* __LISTS_H__ */
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c
index a8f11faec1c43431c56ecbf5126f40067b80714e..561174b7afe2d3b16d5cf7bad4bfe8383123c171 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_wait.c
@@ -14,6 +14,7 @@ void tfm_event_wait(struct tfm_event_t *pevnt)
 
     pevnt->owner = tfm_core_thrd_get_curr();
     tfm_core_thrd_set_state(pevnt->owner, THRD_STATE_BLOCK);
+    tfm_arch_get_ctx(&(pevnt->owner->arch_ctx));
     tfm_core_thrd_activate_schedule();
 }
 
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecdsa_alt.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecdsa_alt.c
index f1afb6826f4694930525bc36715579753327a3f3..65af72920015e9f401b12f97173047ff20a2f2e1 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecdsa_alt.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/ecdsa_alt.c
@@ -1,7 +1,7 @@
 /*
  *  Elliptic curve DSA sign and verify functions
  *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  Copyright (C) 2006-2021, ARM Limited, All Rights Reserved
  *  Copyright (C) 2019, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -22,6 +22,7 @@
 
 /* Includes ------------------------------------------------------------------*/
 #include "mbedtls/ecdsa.h"
+#include "mbedtls/error.h"
 
 #if defined(MBEDTLS_ECDSA_C)
 #include "mbedtls/platform.h"
@@ -73,7 +74,7 @@ int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
     ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );
 
     /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
-    if( grp->G.Y.p == NULL )
+    if( grp->G.MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p) == NULL )
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
     /* Make sure d is in range 1..n-1 */
@@ -211,7 +212,7 @@ int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
     ECDSA_VALIDATE_RET( buf != NULL || blen == 0 );
 
     /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
-    if( grp->G.Y.p == NULL )
+    if( grp->G.MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p) == NULL )
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
     /* Make sure r and s are in range 1..n-1 */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/spm_hal.c
index ff26d6fc752da8e835e993d49d41c7f070546eeb..e7c4ca6a819100ae625d1d46efdf0ab6094fd66d 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/fvp_sse300/spm_hal.c
@@ -111,11 +111,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
index bcb336e352526113df1d6abcb58df8c2873f276d..6dd7bf28e0271022c8094a4193e3cc9aa848620c 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_init.c
@@ -276,12 +276,8 @@ static uint8_t mbedtls_mem_buf[TFM_CRYPTO_ENGINE_BUF_SIZE] = {0};
 
 static psa_status_t tfm_crypto_engine_init(void)
 {
-    /* Log unsafe entropy source */
-#if defined (MBEDTLS_TEST_NULL_ENTROPY)
-    LOG_INFFMT("\033[1;34m[Crypto] MBEDTLS_TEST_NULL_ENTROPY is not suitable for production!\033[0m\r\n");
-#endif
-
 #ifdef PLATFORM_DUMMY_NV_SEED
+    LOG_INFFMT("\033[1;34m[Crypto] Dummy Entropy NV Seed is not suitable for production!\033[0m\r\n");
     if (tfm_plat_crypto_create_entropy_seed() != TFM_CRYPTO_NV_SEED_SUCCESS) {
         return PSA_ERROR_GENERIC_ERROR;
     }
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
index 7f4bc2f8517f5a7f252c3e4f3934e7064e1f0a3c..2db3dce6b1b49aa56a2ae5847e37cb4f4dcb1e5f 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/spm_ipc.c
@@ -36,16 +36,19 @@
 #include "load/spm_load_api.h"
 #include "load/irq_defs.h"
 
-extern struct spm_partition_db_t g_spm_partition_db;
-static struct service_t *connection_services_listhead;
+/* Partition and service runtime data list head/runtime data table */
+static struct partition_head_t partitions_listhead;
+static struct service_head_t services_listhead;
 struct service_t *stateless_services_ref_tbl[STATIC_HANDLE_NUM_LIMIT];
 
 /* Pools */
 TFM_POOL_DECLARE(conn_handle_pool, sizeof(struct tfm_conn_handle_t),
                  TFM_CONN_HANDLE_MAX_NUM);
 
-void tfm_set_irq_signal(uint32_t partition_id, psa_signal_t signal,
-                        uint32_t irq_line);
+void spm_interrupt_handler(struct partition_load_info_t *p_ldinf,
+                           psa_signal_t signal,
+                           uint32_t irq_line,
+                           psa_flih_func flih_func);
 
 #include "tfm_secure_irq_handlers_ipc.inc"
 
@@ -259,30 +262,6 @@ struct tfm_msg_body_t *tfm_spm_get_msg_by_signal(struct partition_t *partition,
     return msg;
 }
 
-/**
- * \brief Returns the index of the partition with the given partition ID.
- *
- * \param[in] partition_id     Partition id
- *
- * \return the partition idx if partition_id is valid,
- *         \ref SPM_INVALID_PARTITION_IDX othervise
- */
-static uint32_t get_partition_idx(uint32_t partition_id)
-{
-    uint32_t i;
-
-    if (partition_id == INVALID_PARTITION_ID) {
-        return SPM_INVALID_PARTITION_IDX;
-    }
-
-    for (i = 0; i < g_spm_partition_db.partition_count; ++i) {
-        if (g_spm_partition_db.partitions[i].p_ldinf->pid == partition_id) {
-            return i;
-        }
-    }
-    return SPM_INVALID_PARTITION_IDX;
-}
-
 #if TFM_LVL != 1
 /**
  * \brief Change the privilege mode for partition thread mode.
@@ -326,25 +305,15 @@ uint32_t tfm_spm_partition_get_privileged_mode(uint32_t partition_flags)
 
 struct service_t *tfm_spm_get_service_by_sid(uint32_t sid)
 {
-    uint32_t i = 0;
-    struct service_t *p_serv = connection_services_listhead;
+    struct service_t *p_serv;
 
-    for (i = 0; i < STATIC_HANDLE_NUM_LIMIT; i++) {
-        if (stateless_services_ref_tbl[i]) {
-            if (stateless_services_ref_tbl[i]->p_ldinf->sid == sid) {
-                return stateless_services_ref_tbl[i];
-            }
+    UNI_LIST_FOR_EACH(p_serv, &services_listhead) {
+        if (p_serv->p_ldinf->sid == sid) {
+            return p_serv;
         }
     }
 
-    while (p_serv && p_serv->p_ldinf->sid != sid) {
-        p_serv = TO_CONTAINER(BI_LIST_NEXT_NODE(&p_serv->list),
-                              struct service_t, list);
-        if (p_serv == connection_services_listhead)
-            return NULL;
-    }
-
-    return p_serv;
+    return NULL;
 }
 
 /**
@@ -356,13 +325,16 @@ struct service_t *tfm_spm_get_service_by_sid(uint32_t sid)
  * \retval "Not NULL"       Target partition context pointer,
  *                          \ref partition_t structures
  */
-static struct partition_t *tfm_spm_get_partition_by_id(int32_t partition_id)
+struct partition_t *tfm_spm_get_partition_by_id(int32_t partition_id)
 {
-    uint32_t idx = get_partition_idx(partition_id);
+    struct partition_t *p_part;
 
-    if (idx != SPM_INVALID_PARTITION_IDX) {
-        return &(g_spm_partition_db.partitions[idx]);
+    UNI_LIST_FOR_EACH(p_part, &partitions_listhead) {
+        if (p_part->p_ldinf->pid == partition_id) {
+            return p_part;
+        }
     }
+
     return NULL;
 }
 
@@ -650,8 +622,11 @@ uint32_t tfm_spm_init(void)
                   sizeof(struct tfm_conn_handle_t),
                   TFM_CONN_HANDLE_MAX_NUM);
 
+    UNI_LISI_INIT_HEAD(&partitions_listhead);
+    UNI_LISI_INIT_HEAD(&services_listhead);
+
     while (1) {
-        partition = load_a_partition_assuredly();
+        partition = load_a_partition_assuredly(&partitions_listhead);
         if (partition == NULL) {
             break;
         }
@@ -659,7 +634,7 @@ uint32_t tfm_spm_init(void)
         p_ldinf = partition->p_ldinf;
 
         if (p_ldinf->nservices) {
-            load_services_assuredly(partition, &connection_services_listhead,
+            load_services_assuredly(partition, &services_listhead,
                                     stateless_services_ref_tbl,
                                     sizeof(stateless_services_ref_tbl));
         }
@@ -763,66 +738,80 @@ uint32_t tfm_spm_init(void)
     return p_ns_entry_thread->arch_ctx.lr;
 }
 
-void tfm_pendsv_do_schedule(struct tfm_arch_ctx_t *p_actx)
-{
 #if TFM_LVL != 1
-    struct partition_t *p_next_partition;
-    const struct partition_load_info_t *p_part_static;
-    uint32_t is_privileged;
-#endif
-    struct tfm_core_thread_t *pth_next = tfm_core_thrd_get_next();
-    struct tfm_core_thread_t *pth_curr = tfm_core_thrd_get_curr();
+static void set_up_boundary(const struct partition_load_info_t *p_ldinf)
+{
+#if TFM_LVL == 3
 #if defined(TFM_FIH_PROFILE_ON) && (TFM_LVL == 3)
     fih_int fih_rc = FIH_FAILURE;
 #endif
-
-    if (pth_next != NULL && pth_curr != pth_next) {
-#if TFM_LVL != 1
-        p_next_partition = TO_CONTAINER(pth_next,
-                                        struct partition_t,
-                                        sp_thread);
-        p_part_static = p_next_partition->p_ldinf;
-        if (p_part_static->flags & SPM_PART_FLAG_PSA_ROT) {
-            is_privileged = TFM_PARTITION_PRIVILEGED_MODE;
-        } else {
-            is_privileged = TFM_PARTITION_UNPRIVILEGED_MODE;
+    /*
+     * FIXME: To implement isolations among partitions in isolation level 3,
+     * each partition needs to run in unprivileged mode. Currently some
+     * PRoTs cannot work in unprivileged mode, make them privileged now.
+     */
+    if (!(p_ldinf->flags & SPM_PART_FLAG_PSA_ROT)) {
+        struct asset_desc_t *p_asset =
+            (struct asset_desc_t *)LOAD_INFO_ASSET(p_ldinf);
+        /* Partition must have private data as the first asset in LVL3 */
+        if (p_ldinf->nassets == 0) {
+            tfm_core_panic();
         }
-
-        tfm_spm_partition_change_privilege(is_privileged);
-#if TFM_LVL == 3
-        /*
-         * FIXME: To implement isolations among partitions in isolation level 3,
-         * each partition needs to run in unprivileged mode. Currently some
-         * PRoTs cannot work in unprivileged mode, make them privileged now.
-         */
-        if (is_privileged == TFM_PARTITION_UNPRIVILEGED_MODE) {
-            struct asset_desc_t *p_asset =
-                (struct asset_desc_t *)LOAD_INFO_ASSET(p_part_static);
-            /* Partition must have private data as the first asset in LVL3 */
-            if (p_part_static->nassets == 0) {
-                tfm_core_panic();
-            }
-            if (p_asset->attr & ASSET_DEV_REF_BIT) {
-                tfm_core_panic();
-            }
-            /* FIXME: only MPU-based implementations are supported currently */
+        if (p_asset->attr & ASSET_DEV_REF_BIT) {
+            tfm_core_panic();
+        }
+        /* FIXME: only MPU-based implementations are supported currently */
 #ifdef TFM_FIH_PROFILE_ON
-            FIH_CALL(tfm_hal_mpu_update_partition_boundary, fih_rc,
-                     p_asset->mem.addr_x, p_asset->mem.addr_y);
-            if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
-                tfm_core_panic();
-            }
+        FIH_CALL(tfm_hal_mpu_update_partition_boundary, fih_rc,
+                    p_asset->mem.addr_x, p_asset->mem.addr_y);
+        if (fih_not_eq(fih_rc, fih_int_encode(TFM_HAL_SUCCESS))) {
+            tfm_core_panic();
+        }
 #else /* TFM_FIH_PROFILE_ON */
-            if (tfm_hal_mpu_update_partition_boundary(p_asset->mem.addr_x,
-                                                      p_asset->mem.addr_y)
+        if (tfm_hal_mpu_update_partition_boundary(p_asset->mem.addr_x,
+                                                  p_asset->mem.addr_y)
                                                            != TFM_HAL_SUCCESS) {
-                tfm_core_panic();
-            }
-#endif /* TFM_FIH_PROFILE_ON */
+            tfm_core_panic();
         }
+#endif /* TFM_FIH_PROFILE_ON */
+    }
+#else /* TFM_LVL == 3 */
+    (void)p_ldinf;
 #endif /* TFM_LVL == 3 */
+}
 #endif /* TFM_LVL != 1 */
 
+void tfm_set_up_isolation_boundary(const struct partition_t *partition)
+{
+#if TFM_LVL != 1
+    const struct partition_load_info_t *p_ldinf;
+    uint32_t is_privileged;
+
+    p_ldinf = partition->p_ldinf;
+    is_privileged = p_ldinf->flags & SPM_PART_FLAG_PSA_ROT ?
+                                                TFM_PARTITION_PRIVILEGED_MODE :
+                                                TFM_PARTITION_UNPRIVILEGED_MODE;
+
+    tfm_spm_partition_change_privilege(is_privileged);
+
+    set_up_boundary(p_ldinf);
+#else /* TFM_LVL != 1 */
+    (void)partition;
+#endif /* TFM_LVL != 1 */
+}
+
+void tfm_pendsv_do_schedule(struct tfm_arch_ctx_t *p_actx)
+{
+    struct partition_t *p_next_partition;
+    struct tfm_core_thread_t *pth_next = tfm_core_thrd_get_next();
+    struct tfm_core_thread_t *pth_curr = tfm_core_thrd_get_curr();
+
+    if (pth_next != NULL && pth_curr != pth_next) {
+        p_next_partition = TO_CONTAINER(pth_next,
+                                        struct partition_t,
+                                        sp_thread);
+        tfm_set_up_isolation_boundary(p_next_partition);
+
         tfm_core_thrd_switch_context(p_actx, pth_curr, pth_next);
     }
 
@@ -889,25 +878,53 @@ void notify_with_signal(int32_t partition_id, psa_signal_t signal)
     }
 }
 
-/**
- * \brief Sets signal to partition for Second-Level Interrupt Handling mode IRQ
- *
- * \param[in] partition_id      The ID of the partition which handles this IRQ
- * \param[in] signal            The signal associated with this IRQ
- * \param[in] irq_line          The number of the IRQ line
- *
- * \retval void                 Success.
- * \retval "Does not return"    Partition ID is invalid
- */
-void tfm_set_irq_signal(uint32_t partition_id, psa_signal_t signal,
-                        uint32_t irq_line)
+__attribute__((naked))
+static void tfm_flih_deprivileged_handling(uint32_t p_ldinf,
+                                           psa_flih_func flih_func,
+                                           psa_signal_t signal)
 {
-    __disable_irq();
+    __ASM volatile("SVC %0           \n"
+                   "BX LR            \n"
+                   : : "I" (TFM_SVC_PREPARE_DEPRIV_FLIH));
+}
 
-    tfm_spm_hal_disable_irq(irq_line);
-    notify_with_signal(partition_id, signal);
+void spm_interrupt_handler(struct partition_load_info_t *p_ldinf,
+                           psa_signal_t signal,
+                           uint32_t irq_line,
+                           psa_flih_func flih_func)
+{
+    uint32_t pid;
+    psa_flih_result_t flih_result;
+
+    pid = p_ldinf->pid;
+
+    if (flih_func == NULL) {
+        /* SLIH Model Handling */
+        __disable_irq();
+        tfm_spm_hal_disable_irq(irq_line);
+        notify_with_signal(pid, signal);
+        __enable_irq();
+        return;
+    }
 
-    __enable_irq();
+    /* FLIH Model Handling */
+    if (tfm_spm_partition_get_privileged_mode(p_ldinf->flags) ==
+                                                TFM_PARTITION_PRIVILEGED_MODE) {
+        flih_result = flih_func();
+        if (flih_result == PSA_FLIH_SIGNAL) {
+            __disable_irq();
+            notify_with_signal(pid, signal);
+            __enable_irq();
+        } else if (flih_result != PSA_FLIH_NO_SIGNAL) {
+            /*
+             * Nothing needed to do for PSA_FLIH_NO_SIGNAL
+             * But if the flih_result is invalid, should panic.
+             */
+            tfm_core_panic();
+        }
+    } else {
+        tfm_flih_deprivileged_handling((uint32_t)p_ldinf, flih_func, signal);
+    }
 }
 
 struct irq_load_info_t *get_irq_info_for_signal(
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
index 3391a14bdeda692f38a90cfbbcf951912fcde374..b7a609eb55c91b6176ef9880c4bfa4d0600405d9 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/include/platform_regs.h
@@ -254,10 +254,10 @@ struct sse300_nsacfg_t {
 #define GPIO1_MAIN_PPCEXP0_POS_MASK             (1UL << 1)
 #define GPIO2_MAIN_PPCEXP0_POS_MASK             (1UL << 2)
 #define GPIO3_MAIN_PPCEXP0_POS_MASK             (1UL << 3)
+#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 4)
 #define USER_AHB0_MAIN_PPCEXP0_POS_MASK         (1UL << 5)
 #define USER_AHB1_MAIN_PPCEXP0_POS_MASK         (1UL << 6)
 #define USER_AHB2_MAIN_PPCEXP0_POS_MASK         (1UL << 7)
-#define USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK  (1UL << 4)
 /* End MAIN PPCEXP0 peripherals definition */
 
 /* MAIN PPCEXP1 peripherals definition */
@@ -316,6 +316,7 @@ struct sse300_nsacfg_t {
 #define UART5_PERIPH_PPCEXP2_POS_MASK              (1UL << 8)
 #define CLCD_PERIPH_PPCEXP2_POS_MASK               (1UL << 10)
 #define RTC_PERIPH_PPCEXP2_POS_MASK                (1UL << 11)
+#define VSI_PERIPH_PPCEXP2_POS_MASK                (1UL << 12)
 /* End PERIPH PPCEXP2 peripherals definition */
 
 /* PERIPH PPCEXP3 peripherals definition */
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Native_Driver/low_level_rng.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Native_Driver/low_level_rng.c
index 7c1c4b25e57897c4b9c63682ebaa2cdb8d2c85b7..1799d02283d67f3a95c469bd07fb04a13a7b4a87 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Native_Driver/low_level_rng.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/Native_Driver/low_level_rng.c
@@ -20,7 +20,6 @@
   */
 #include "low_level_rng.h"
 #include "stm32l5xx_hal.h"
-extern void Error_Handler(void);
 
 static RNG_HandleTypeDef handle;
 static uint8_t users = 0;
@@ -39,13 +38,13 @@ static uint8_t atomic_incr_u8(__IO uint8_t *valuePtr, uint8_t delta)
   return newValue;
 }
 
-static void RNG_Init(void)
+static int RNG_Init(void)
 {
   uint32_t dummy;
   /*  We're only supporting a single user of RNG */
   if (atomic_incr_u8(&users, 1) > 1)
   {
-    Error_Handler();
+    return -1;
   }
 
   RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
@@ -55,7 +54,8 @@ static void RNG_Init(void)
   PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_MSI;
   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   {
-   Error_Handler();
+    users=0;
+    return -1;
   }
 
   /* RNG Peripheral clock enable */
@@ -70,6 +70,7 @@ static void RNG_Init(void)
 
   /* first random number generated after setting the RNGEN bit should not be used */
   HAL_RNG_GenerateRandomNumber(&handle, &dummy);
+  return 0;
 }
 
 static void RNG_GetBytes(uint8_t *output, size_t length, size_t *output_length)
@@ -116,7 +117,8 @@ static void RNG_DeInit(void)
 /*  interface for mbed-crypto */
 int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen)
 {
-  RNG_Init();
+  if (RNG_Init())
+    return -1;
   RNG_GetBytes(output, len, olen);
   RNG_DeInit();
   if (*olen != len)
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cc_ecp_internal.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cc_ecp_internal.c
index 8e4f3ac6377042eaf5473604c00f234333dec345..195b63c6ca51436379eb1fe519d10ea6f6314f2f 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cc_ecp_internal.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/cc_ecp_internal.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -102,7 +102,7 @@ static int ecc_conv_scalar_to_mpi( uint8_t * scalar, size_t scalarSize, mbedtls_
         return ret;
     }
 
-    X->s = 1; /*unsigned*/
+    X->MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
     mbedtls_free(outArr);
 
@@ -136,7 +136,7 @@ static int ecc_conv_mpi_to_scalar( const mbedtls_mpi * X, uint8_t *scalar, size_
         CC_PAL_LOG_ERR("Error - failed to reverse memcpy, status = %d\n",status);
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
     }
-    *scalarSize = (X->n * sizeof(mbedtls_mpi_uint));
+    *scalarSize = (X->MBEDTLS_PRIVATE(n) * sizeof(mbedtls_mpi_uint));
 
     mbedtls_free(outArr);
 
@@ -167,7 +167,7 @@ static int ecp_mont_mul( mbedtls_ecp_point *R,
     }
 
     mbedtls_zeroize_internal(px, CC_EC_MONT_MOD_SIZE_IN_BYTES);
-    ret = ecc_conv_mpi_to_scalar(&P->X, px, &pxSize);
+    ret = ecc_conv_mpi_to_scalar(&P->MBEDTLS_PRIVATE(X), px, &pxSize);
     if (ret != 0)
     {
         return ret;
@@ -193,14 +193,14 @@ static int ecp_mont_mul( mbedtls_ecp_point *R,
     }
     /* prepare the output point R*/
     /* Y is not used in the result, and Z is 1*/
-    ret =  mbedtls_mpi_lset( &R->Z, 1 );
+    ret =  mbedtls_mpi_lset( &R->MBEDTLS_PRIVATE(Z), 1 );
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - could not set R.z\n");
         return MBEDTLS_ERR_ECP_ALLOC_FAILED;
     }
-    mbedtls_mpi_free(&R->Y);
-    ret = ecc_conv_scalar_to_mpi(resPoint, resPointSize, &R->X);
+    mbedtls_mpi_free(&R->MBEDTLS_PRIVATE(Y));
+    ret = ecc_conv_scalar_to_mpi(resPoint, resPointSize, &R->MBEDTLS_PRIVATE(X));
     if (ret != 0)
     {
         return ret;
@@ -241,7 +241,7 @@ static int ecp_wrst_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
         CC_PAL_LOG_ERR("Error - failed to allocate memory for temporary buffer\n");
         return MBEDTLS_ERR_ECP_ALLOC_FAILED;
     }
-    ret = mbedtls_mpi_grow(&R->X, CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
+    ret = mbedtls_mpi_grow(&R->MBEDTLS_PRIVATE(X), CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R\n");
@@ -249,16 +249,16 @@ static int ecp_wrst_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
         return MBEDTLS_ERR_ECP_ALLOC_FAILED;
     }
 
-    ret = mbedtls_mpi_grow(&R->Y, CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
+    ret = mbedtls_mpi_grow(&R->MBEDTLS_PRIVATE(Y), CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R.x\n");
         mbedtls_free(tmpBuf);
-        mbedtls_mpi_free(&R->X);
+        mbedtls_mpi_free(&R->MBEDTLS_PRIVATE(X));
         return MBEDTLS_ERR_ECP_ALLOC_FAILED;
     }
 
-    rc = PkaEcWrstScalarMult(pDomain, m->p, m->n, P->X.p, P->Y.p, R->X.p, R->Y.p, tmpBuf);
+    rc = PkaEcWrstScalarMult(pDomain, m->MBEDTLS_PRIVATE(p), m->MBEDTLS_PRIVATE(n), P->MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p), P->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p), R->MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p), R->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p), tmpBuf);
     mbedtls_free(tmpBuf);
     if (rc != CC_SUCCESS)
     {
@@ -266,12 +266,12 @@ static int ecp_wrst_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
         return error_mapping_cc_to_mbedtls_ecc(rc);
     }
 
-    ret = mbedtls_mpi_lset( &R->Z, 1 );
+    ret = mbedtls_mpi_lset( &R->MBEDTLS_PRIVATE(Z), 1 );
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R\n");
-        mbedtls_mpi_free(&R->X);
-        mbedtls_mpi_free(&R->Y);
+        mbedtls_mpi_free(&R->MBEDTLS_PRIVATE(X));
+        mbedtls_mpi_free(&R->MBEDTLS_PRIVATE(Y));
         return MBEDTLS_ERR_ECP_ALLOC_FAILED;
     }
     return (0);
@@ -298,7 +298,7 @@ int cc_ecp_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
 
     }
     /* Common sanity checks */
-    if( mbedtls_mpi_cmp_int( &P->Z, 1 ) != 0 )
+    if( mbedtls_mpi_cmp_int( &P->MBEDTLS_PRIVATE(Z), 1 ) != 0 )
     {
         CC_PAL_LOG_ERR("Error - trying to multiply the infinity point\n");
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
@@ -357,7 +357,7 @@ static int ecp_mont_gen_keypair_base(
     if (G != NULL) /* Base point was supplied by application*/
     {
         mbedtls_zeroize_internal(px, CC_EC_MONT_MOD_SIZE_IN_BYTES);
-        ret = ecc_conv_mpi_to_scalar(&G->X, px, &pxSize);
+        ret = ecc_conv_mpi_to_scalar(&G->MBEDTLS_PRIVATE(X), px, &pxSize);
         if (ret != 0)
         {
             return ret;
@@ -401,14 +401,14 @@ static int ecp_mont_gen_keypair_base(
     }
     /* prepare the output point Q*/
     /* Y is not used in the result, and Z is 1*/
-    ret =  mbedtls_mpi_lset( &Q->Z, 1 );
+    ret =  mbedtls_mpi_lset( &Q->MBEDTLS_PRIVATE(Z), 1 );
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - could not set Q.z\n");
         goto END;
     }
-    mbedtls_mpi_free(&Q->Y);
-    ret = ecc_conv_scalar_to_mpi(resPoint, resPointSize, &Q->X);
+    mbedtls_mpi_free(&Q->MBEDTLS_PRIVATE(Y));
+    ret = ecc_conv_scalar_to_mpi(resPoint, resPointSize, &Q->MBEDTLS_PRIVATE(X));
     if (ret != 0)
     {
         goto END;
@@ -497,21 +497,21 @@ static int ecp_wrst_gen_keypair_base( mbedtls_ecp_group *grp,
     pRndContext->rndGenerateVectFunc = (CCRndGenerateVectWorkFunc_t)f_rng;
     pRndContext->rndState = p_rng;
 
-    ret = mbedtls_mpi_grow(&Q->X, CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
+    ret = mbedtls_mpi_grow(&Q->MBEDTLS_PRIVATE(X), CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R\n");
         goto END;
     }
-    Q->X.s = 1; /*unsigned*/
+    Q->MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
-    ret = mbedtls_mpi_grow(&Q->Y, CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
+    ret = mbedtls_mpi_grow(&Q->MBEDTLS_PRIVATE(Y), CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R.x\n");
         goto END;
     }
-    Q->Y.s = 1; /*unsigned*/
+    Q->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
     ret = mbedtls_mpi_grow(d, CALC_FULL_32BIT_WORDS(pDomain->modSizeInBits));
     if (ret != 0)
@@ -520,11 +520,11 @@ static int ecp_wrst_gen_keypair_base( mbedtls_ecp_group *grp,
         goto END;
     }
 
-    d->s = 1; /*unsigned*/
+    d->MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
     if (G != NULL) /* Base point was supplied by the application*/
     {
-        rc = CC_EcpkiKeyPairGenerateBase(pRndContext, pDomain, G->X.p, G->Y.p, pUserPrivKey, pUserPublKey, pTempBuff, NULL);
+        rc = CC_EcpkiKeyPairGenerateBase(pRndContext, pDomain, G->MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p), G->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p), pUserPrivKey, pUserPublKey, pTempBuff, NULL);
     }
     else
     {
@@ -539,11 +539,11 @@ static int ecp_wrst_gen_keypair_base( mbedtls_ecp_group *grp,
 
     pPrivKey = (CCEcpkiPrivKey_t *)pUserPrivKey->PrivKeyDbBuff;
     pPublicKey = (CCEcpkiPublKey_t *)pUserPublKey->PublKeyDbBuff;
-    CC_PalMemCopy(d->p, pPrivKey->PrivKey, CALC_FULL_BYTES(pDomain->modSizeInBits));
-    CC_PalMemCopy(Q->X.p, pPublicKey->x, CALC_FULL_BYTES(pDomain->modSizeInBits));
-    CC_PalMemCopy(Q->Y.p, pPublicKey->y, CALC_FULL_BYTES(pDomain->modSizeInBits));
+    CC_PalMemCopy(d->MBEDTLS_PRIVATE(p), pPrivKey->PrivKey, CALC_FULL_BYTES(pDomain->modSizeInBits));
+    CC_PalMemCopy(Q->MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p), pPublicKey->x, CALC_FULL_BYTES(pDomain->modSizeInBits));
+    CC_PalMemCopy(Q->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p), pPublicKey->y, CALC_FULL_BYTES(pDomain->modSizeInBits));
 
-    ret = mbedtls_mpi_lset( &Q->Z, 1 );
+    ret = mbedtls_mpi_lset( &Q->MBEDTLS_PRIVATE(Z), 1 );
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for R\n");
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
index bbdc060ce241e9c785bf9814888085778299c65e..d787c65337430b66dc02521f80857024bdc05059 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_small.h
@@ -491,23 +491,6 @@
 //#define MBEDTLS_ECP_RANDOMIZE_MXZ_ALT
 //#define MBEDTLS_ECP_NORMALIZE_MXZ_ALT
 
-/**
- * \def MBEDTLS_TEST_NULL_ENTROPY
- *
- * Enables testing and use of mbed TLS without any configured entropy sources.
- * This permits use of the library on platforms before an entropy source has
- * been integrated (see for example the MBEDTLS_ENTROPY_HARDWARE_ALT or the
- * MBEDTLS_ENTROPY_NV_SEED switches).
- *
- * WARNING! This switch MUST be disabled in production builds, and is suitable
- * only for development.
- * Enabling the switch negates any security provided by the library.
- *
- * Requires MBEDTLS_ENTROPY_C, MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
- *
- */
-#define MBEDTLS_TEST_NULL_ENTROPY
-
 /**
  * \def MBEDTLS_ENTROPY_HARDWARE_ALT
  *
@@ -793,7 +776,7 @@
  *
  * Uncomment this macro to prevent loading of default entropy functions.
  */
-#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 /**
  * \def MBEDTLS_NO_PLATFORM_ENTROPY
@@ -848,7 +831,7 @@
  * \note The entropy collector will write to the seed file before entropy is
  *       given to an external source, to update it.
  */
-//#define MBEDTLS_ENTROPY_NV_SEED
+#define MBEDTLS_ENTROPY_NV_SEED
 
 /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
  *
@@ -1778,6 +1761,22 @@
  */
 //#define MBEDTLS_SHA1_C
 
+/**
+ * \def MBEDTLS_SHA224_C
+ *
+ * Enable the SHA-224 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA256_C. The library does not currently support enabling
+ *           SHA-224 without SHA-256.
+ *
+ * Module:  library/sha256.c
+ * Caller:  library/md.c
+ *          library/ssl_cookie.c
+ *
+ * This module adds support for SHA-224.
+ */
+#define MBEDTLS_SHA224_C
+
 /**
  * \def MBEDTLS_SHA256_C
  *
@@ -1792,6 +1791,22 @@
  */
 #define MBEDTLS_SHA256_C
 
+/**
+ * \def MBEDTLS_SHA384_C
+ *
+ * Enable the SHA-384 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA512_C
+ *
+ * Module:  library/sha512.c
+ * Caller:  library/md.c
+ *          library/ssl_cli.c
+ *          library/ssl_srv.c
+ *
+ * Comment to disable SHA-384
+ */
+//#define MBEDTLS_SHA384_C
+
 /**
  * \def MBEDTLS_SHA512_C
  *
@@ -1993,6 +2008,8 @@
 
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
+#else
+#include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
 /* Target and application specific configurations
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
index c305b0c18d129d3dbfebdd3c0f1665e44a70270a..f596b736c800dd03b0183aa8211f88ffc5ac5a27 100755
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2018 Arm Limited
- * Copyright (c) 2019-2020, Cypress Semiconductor Corporation. All rights reserved.
+ * Copyright (c) 2019-2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,6 +56,40 @@ const struct memory_region_limits memory_regions = {
 REGION_DECLARE(Load$$LR$$, LR_SECONDARY_PARTITION, $$Base);
 #endif /* BL2 */
 
+/* UART RX and TX pins */
+const cy_stc_gpio_pin_config_t CYBSP_UART_RX_config =
+{
+    .outVal = 1,
+    .driveMode = CY_GPIO_DM_HIGHZ,
+    .hsiom = CYBSP_UART_RX_HSIOM,
+    .intEdge = CY_GPIO_INTR_DISABLE,
+    .intMask = 0UL,
+    .vtrip = CY_GPIO_VTRIP_CMOS,
+    .slewRate = CY_GPIO_SLEW_FAST,
+    .driveSel = CY_GPIO_DRIVE_1_2,
+    .vregEn = 0UL,
+    .ibufMode = 0UL,
+    .vtripSel = 0UL,
+    .vrefSel = 0UL,
+    .vohSel = 0UL,
+};
+const cy_stc_gpio_pin_config_t CYBSP_UART_TX_config =
+{
+    .outVal = 1,
+    .driveMode = CY_GPIO_DM_STRONG_IN_OFF,
+    .hsiom = CYBSP_UART_TX_HSIOM,
+    .intEdge = CY_GPIO_INTR_DISABLE,
+    .intMask = 0UL,
+    .vtrip = CY_GPIO_VTRIP_CMOS,
+    .slewRate = CY_GPIO_SLEW_FAST,
+    .driveSel = CY_GPIO_DRIVE_1_2,
+    .vregEn = 0UL,
+    .ibufMode = 0UL,
+    .vtripSel = 0UL,
+    .vrefSel = 0UL,
+    .vohSel = 0UL,
+};
+
 /* To write into AIRCR register, 0x5FA value must be write to the VECTKEY field,
  * otherwise the processor ignores the write.
  */
@@ -133,6 +167,9 @@ void platform_init(void)
         SPMLOG_INFMSG("WARNING: Failed to configure timer1 clock\r\n");
     }
 
+    Cy_GPIO_Pin_Init(CYBSP_UART_RX_PORT, CYBSP_UART_RX_PIN, &CYBSP_UART_RX_config);
+    Cy_GPIO_Pin_Init(CYBSP_UART_TX_PORT, CYBSP_UART_TX_PIN, &CYBSP_UART_TX_config);
+
     Cy_Platform_Init();
 
 #ifdef TFM_ENABLE_SLIH_TEST
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
index d081ca913d032672e21fe0c056f3494fd9aea63e..67ef44275fa19be8179d88bb908c3cc5e191c700 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_object_system.c
@@ -188,6 +188,13 @@ psa_status_t ps_object_read(psa_storage_uid_t uid, int32_t client_id,
 
     /* Read object */
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
     /* Read object header */
@@ -243,6 +250,14 @@ psa_status_t ps_object_create(psa_storage_uid_t uid, int32_t client_id,
     if (err == PSA_SUCCESS) {
 #ifdef PS_ENCRYPTION
         /* Read the object */
+        err = ps_utils_fill_key_label(uid,
+                                      client_id,
+                                      g_ps_object.header.crypto.ref.key_label,
+                                      sizeof(g_ps_object.header.crypto.ref.key_label));
+        if (err != PSA_SUCCESS) {
+            goto clear_data_and_return;
+        }
+
         err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
         /* Read the object header */
@@ -294,6 +309,14 @@ psa_status_t ps_object_create(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
+
     err = ps_encrypted_object_write(g_obj_tbl_info.fid, &g_ps_object);
 #else
     wrt_size = PS_OBJECT_SIZE(g_ps_object.header.info.current_size);
@@ -354,6 +377,14 @@ psa_status_t ps_object_write(psa_storage_uid_t uid, int32_t client_id,
 
     /* Read the object */
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
+
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
     err = ps_read_object(READ_ALL_OBJECT);
@@ -404,6 +435,14 @@ psa_status_t ps_object_write(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
+
     err = ps_encrypted_object_write(g_obj_tbl_info.fid, &g_ps_object);
 #else
     wrt_size = PS_OBJECT_SIZE(g_ps_object.header.info.current_size);
@@ -453,6 +492,14 @@ psa_status_t ps_object_get_info(psa_storage_uid_t uid, int32_t client_id,
     }
 
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
+
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
     err = ps_read_object(READ_HEADER_ONLY);
@@ -486,6 +533,14 @@ psa_status_t ps_object_delete(psa_storage_uid_t uid, int32_t client_id)
     }
 
 #ifdef PS_ENCRYPTION
+    err = ps_utils_fill_key_label(uid,
+                                  client_id,
+                                  g_ps_object.header.crypto.ref.key_label,
+                                  sizeof(g_ps_object.header.crypto.ref.key_label));
+    if (err != PSA_SUCCESS) {
+        goto clear_data_and_return;
+    }
+
     err = ps_encrypted_object_read(g_obj_tbl_info.fid, &g_ps_object);
 #else
     err = ps_read_object(READ_HEADER_ONLY);
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
index 4b24631f79eea18309de090640a1c78063e31297..2a6b8b2478d2f7d3083678823d6c09dda6e1b1ba 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/Driver_AN547_MPC.c
@@ -624,26 +624,73 @@ ARM_DRIVER_MPC Driver_QSPI_MPC = {
 #endif /* RTE_QSPI_MPC */
 
 #if (RTE_DDR4_MPC)
-/* Ranges controlled by this DDR4_MPC */
-static const struct mpc_sie_memory_range_t MPC_DDR4_RANGE_S = {
-    .base         = MPC_DDR4_RANGE_BASE_S,
-    .limit        = MPC_DDR4_RANGE_LIMIT_S,
-    .range_offset = 0,
+#define MPC_DDR4_RANGE_LIST_LEN  8u
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK0_RANGE_NS = {
+    .base         = MPC_DDR4_BLK0_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK0_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK0_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK1_RANGE_S = {
+    .base         = MPC_DDR4_BLK1_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK1_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK1_RANGE_OFFSET_S,
     .attr         = MPC_SIE_SEC_ATTR_SECURE
 };
 
-static const struct mpc_sie_memory_range_t MPC_DDR4_RANGE_NS = {
-    .base         = MPC_DDR4_RANGE_BASE_NS,
-    .limit        = MPC_DDR4_RANGE_LIMIT_NS,
-    .range_offset = 0,
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK2_RANGE_NS = {
+    .base         = MPC_DDR4_BLK2_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK2_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK2_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK3_RANGE_S = {
+    .base         = MPC_DDR4_BLK3_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK3_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK3_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK4_RANGE_NS = {
+    .base         = MPC_DDR4_BLK4_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK4_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK4_RANGE_OFFSET_NS,
+    .attr         = MPC_SIE_SEC_ATTR_NONSECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK5_RANGE_S = {
+    .base         = MPC_DDR4_BLK5_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK5_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK5_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK6_RANGE_NS = {
+    .base         = MPC_DDR4_BLK6_RANGE_BASE_NS,
+    .limit        = MPC_DDR4_BLK6_RANGE_LIMIT_NS,
+    .range_offset = MPC_DDR4_BLK6_RANGE_OFFSET_NS,
     .attr         = MPC_SIE_SEC_ATTR_NONSECURE
 };
 
-#define MPC_DDR4_RANGE_LIST_LEN  2u
+static const struct mpc_sie_memory_range_t MPC_DDR4_BLK7_RANGE_S = {
+    .base         = MPC_DDR4_BLK7_RANGE_BASE_S,
+    .limit        = MPC_DDR4_BLK7_RANGE_LIMIT_S,
+    .range_offset = MPC_DDR4_BLK7_RANGE_OFFSET_S,
+    .attr         = MPC_SIE_SEC_ATTR_SECURE
+};
+
 static const struct mpc_sie_memory_range_t*
     MPC_DDR4_RANGE_LIST[MPC_DDR4_RANGE_LIST_LEN] = {
-        &MPC_DDR4_RANGE_S,
-        &MPC_DDR4_RANGE_NS
+        &MPC_DDR4_BLK0_RANGE_NS,
+        &MPC_DDR4_BLK1_RANGE_S,
+        &MPC_DDR4_BLK2_RANGE_NS,
+        &MPC_DDR4_BLK3_RANGE_S,
+        &MPC_DDR4_BLK4_RANGE_NS,
+        &MPC_DDR4_BLK5_RANGE_S,
+        &MPC_DDR4_BLK6_RANGE_NS,
+        &MPC_DDR4_BLK7_RANGE_S,
     };
 
 /* DDR4_MPC Driver wrapper functions */
diff --git a/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash.c b/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash.c
index f2c9e4ede3d8ed2b88d6b94a16c94c7a2dbacba9..178e6e0608a6cbb86c816ab53b186c3cd98655bb 100755
--- a/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/CMSIS_Driver/Driver_Flash.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2013-2018 ARM Limited. All rights reserved.
+ * Copyright 2019-2020 NXP. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -26,6 +27,7 @@
 #include "platform_base_address.h"
 #include "flash_layout.h"
 #include "fsl_iap.h"
+#include "log/tfm_log.h"
 
 #ifndef ARG_UNUSED
 #define ARG_UNUSED(arg)  ((void)arg)
@@ -318,7 +320,7 @@ static status_t FLASH_ReadData(flash_config_t *config, uint32_t start, uint8_t *
     uint32_t readbackData[FLASH_DATAW_IDX_MAX + 1];
     while (lengthInBytes)
     {
-        uint32_t alignedStart = ALIGN_DOWN(start, kFLASH_AlignementUnitSingleWordRead);
+        uint32_t alignedStart = ALIGN_DOWN(start, (uint32_t)kFLASH_AlignementUnitSingleWordRead);
         status = FLASH_ReadSingleWord(config, alignedStart, readbackData);
         if (status != kStatus_FLASH_Success)
         {
@@ -343,7 +345,6 @@ static status_t FLASH_ReadData(flash_config_t *config, uint32_t start, uint8_t *
 static status_t FLASH_ReadSingleWord(flash_config_t *config, uint32_t start, uint32_t *readbackData)
 {
     status_t status = kStatus_Fail;
-    /* uint32_t byteSizes = sizeof(uint32_t) * (FLASH_DATAW_IDX_MAX + 1); */
 
     if (readbackData == NULL)
     {
@@ -436,4 +437,4 @@ static bool is_write_aligned(struct arm_flash_dev_t *flash_dev,
                              uint32_t param)
 {
     return ((param % flash_dev->data->program_unit) != 0) ? (kStatus_Fail) : (kStatus_Success);
-}
+}
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.c b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.c
index 2c41e8e46cb7b9b35e982d114bf0e4468081f030..f30aeb0c227588dc5315c49345f5347c232546a1 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/platform_multicore.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2019-2021 Arm Limited. All rights reserved.
- * Copyright (c) 2019 Cypress Semiconductor Corporation. All rights reserved.
+ * Copyright (c) 2019, 2021 Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -102,7 +102,7 @@ void platform_mailbox_wait_for_notify(void)
                               0, IPC_RX_INT_MASK);
 }
 
-int platform_ns_ipc_init(void)
+static int platform_ns_ipc_init(void)
 {
     Cy_IPC_Drv_SetInterruptMask(Cy_IPC_Drv_GetIntrBaseAddr(IPC_RX_INTR_STRUCT),
                                 0, IPC_RX_INT_MASK);
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/mbedtls/rsa_alt.h b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/mbedtls/rsa_alt.h
index 2eef06935a4835f652cb6974833dd4fc10a651d2..c2f5b687bcbed23aca020ae5dccd46c83612a4af 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/mbedtls/rsa_alt.h
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/shared/include/mbedtls/rsa_alt.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -29,40 +29,40 @@ extern "C" {
  */
 typedef struct
 {
-    int ver;                    /*!<  always 0          */
-    size_t len;                 /*!<  size(N) in chars  */
+    int MBEDTLS_PRIVATE(ver);                    /*!<  always 0          */
+    size_t MBEDTLS_PRIVATE(len);                 /*!<  size(N) in chars  */
 
-    mbedtls_mpi N;                      /*!<  public modulus    */
-    mbedtls_mpi E;                      /*!<  public exponent   */
+    mbedtls_mpi MBEDTLS_PRIVATE(N);                      /*!<  public modulus    */
+    mbedtls_mpi MBEDTLS_PRIVATE(E);                      /*!<  public exponent   */
 
-    mbedtls_mpi D;                      /*!<  private exponent  */
-    mbedtls_mpi P;                      /*!<  1st prime factor  */
-    mbedtls_mpi Q;                      /*!<  2nd prime factor  */
+    mbedtls_mpi MBEDTLS_PRIVATE(D);                      /*!<  private exponent  */
+    mbedtls_mpi MBEDTLS_PRIVATE(P);                      /*!<  1st prime factor  */
+    mbedtls_mpi MBEDTLS_PRIVATE(Q);                      /*!<  2nd prime factor  */
 
-    mbedtls_mpi DP;                     /*!<  D % (P - 1)       */
-    mbedtls_mpi DQ;                     /*!<  D % (Q - 1)       */
-    mbedtls_mpi QP;                     /*!<  1 / (Q % P)       */
+    mbedtls_mpi MBEDTLS_PRIVATE(DP);                     /*!<  D % (P - 1)       */
+    mbedtls_mpi MBEDTLS_PRIVATE(DQ);                     /*!<  D % (Q - 1)       */
+    mbedtls_mpi MBEDTLS_PRIVATE(QP);                     /*!<  1 / (Q % P)       */
 
-    mbedtls_mpi RN;                     /*!<  cached R^2 mod N  */
+    mbedtls_mpi MBEDTLS_PRIVATE(RN);                     /*!<  cached R^2 mod N  */
 
-    mbedtls_mpi RP;                     /*!<  cached R^2 mod P  */
-    mbedtls_mpi RQ;                     /*!<  cached R^2 mod Q  */
+    mbedtls_mpi MBEDTLS_PRIVATE(RP);                     /*!<  cached R^2 mod P  */
+    mbedtls_mpi MBEDTLS_PRIVATE(RQ);                     /*!<  cached R^2 mod Q  */
 
-    mbedtls_mpi Vi;                     /*!<  cached blinding value     */
-    mbedtls_mpi Vf;                     /*!<  cached un-blinding value  */
+    mbedtls_mpi MBEDTLS_PRIVATE(Vi);                     /*!<  cached blinding value     */
+    mbedtls_mpi MBEDTLS_PRIVATE(Vf);                     /*!<  cached un-blinding value  */
 
-    mbedtls_mpi NP;                     /*!< Barrett mod N tag NP for N-modulus */
-    mbedtls_mpi BQP;                    /*!< Barrett mod Q tag QP for Q-factor  */
-    mbedtls_mpi BPP;                    /*!< Barrett mod P tag PP for P-factor  */
+    mbedtls_mpi MBEDTLS_PRIVATE(NP);                     /*!< Barrett mod N tag NP for N-modulus */
+    mbedtls_mpi MBEDTLS_PRIVATE(BQP);                    /*!< Barrett mod Q tag QP for Q-factor  */
+    mbedtls_mpi MBEDTLS_PRIVATE(BPP);                    /*!< Barrett mod P tag PP for P-factor  */
 
-    int padding;                /*!<  MBEDTLS_RSA_PKCS_V15 for 1.5 padding and
+    int MBEDTLS_PRIVATE(padding);                /*!<  MBEDTLS_RSA_PKCS_V15 for 1.5 padding and
                                       MBEDTLS_RSA_PKCS_v21 for OAEP/PSS         */
-    int hash_id;                /*!<  Hash identifier of mbedtls_md_type_t as
+    int MBEDTLS_PRIVATE(hash_id);                /*!<  Hash identifier of mbedtls_md_type_t as
                                       specified in the mbedtls_md.h header file
                                       for the EME-OAEP and EMSA-PSS
                                       encoding                          */
 #if defined(MBEDTLS_THREADING_C)
-    mbedtls_threading_mutex_t mutex;    /*!<  Thread-safety mutex       */
+    mbedtls_threading_mutex_t MBEDTLS_PRIVATE(mutex);    /*!<  Thread-safety mutex       */
 #endif
 }
 mbedtls_rsa_context;
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
index 2fda956285905e1152b33dccb7c38299f321dcb0..d9fe96f96074ea0a0473b4bc6d82cd6e6da4d376 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.h
@@ -20,6 +20,10 @@ extern "C" {
 #define PS_KEY_LEN_BYTES  16
 #define PS_TAG_LEN_BYTES  16
 #define PS_IV_LEN_BYTES   12
+/* The key label consists of the uid + client_id, thus the length of it is:
+ * sizeof(psa_storage_uid_t) + sizeof(int32_t).
+ */
+#define PS_KEY_LABEL_LEN_BYTES 12
 
 /* Union containing crypto policy implementations. The ref member provides the
  * reference implementation. Further members can be added to the union to
@@ -27,6 +31,7 @@ extern "C" {
  */
 union ps_crypto_t {
     struct {
+        uint8_t key_label[PS_KEY_LABEL_LEN_BYTES]; /*!< Key label value */
         uint8_t tag[PS_TAG_LEN_BYTES]; /*!< MAC value of AEAD object */
         uint8_t iv[PS_IV_LEN_BYTES];   /*!< IV value of AEAD object */
     } ref;
@@ -42,9 +47,12 @@ psa_status_t ps_crypto_init(void);
 /**
  * \brief Sets the key to use for crypto operations for the current client.
  *
+ * \param[in]     key_label       Pointer to the key label
+ * \param[in]     key_label_len   Length of the key label
+ *
  * \return Returns values as described in \ref psa_status_t
  */
-psa_status_t ps_crypto_setkey(void);
+psa_status_t ps_crypto_setkey(const uint8_t *key_label, size_t key_label_len);
 
 /**
  * \brief Destroys the transient key used for crypto operations.
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
index a571b07adbc3fdc94a040fdcb37afc9a451a5110..21f49bb24f6ac89e4ee919bb896ba57899fddaff 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/flash_layout.h
@@ -19,13 +19,14 @@
 
 #include "platform_base_address.h"
 
+/* WARNING: Layout below has been moved to QSPI_SRAM and addresses so different now */
 /* Flash layout on AN547 with BL2 (multiple image boot):
  *
  * 0x0000_0000 Secure image     primary slot (384 KB)
- * 0x0006_0000 Non-secure image primary slot (384 KB)
+ * 0x0006_0000 Non-secure image primary slot (2 MB)
  * 0x000C_0000 Secure image     secondary slot (384 KB)
- * 0x0012_0000 Non-secure image secondary slot (384 KB)
- * 0x0018_0000 Scratch area (384 KB)
+ * 0x0012_0000 Non-secure image secondary slot (2 MB)
+ * 0x0018_0000 Scratch area (2 MB)
  * 0x001E_0000 Protected Storage Area (20 KB)
  * 0x001E_5000 Internal Trusted Storage Area (16 KB)
  * 0x001E_9000 NV counters area (4 KB)
@@ -57,7 +58,7 @@
 
 /* Size of a Secure and of a Non-secure image */
 #define FLASH_S_PARTITION_SIZE          (0x60000) /* S  partition: 384 KB */
-#define FLASH_NS_PARTITION_SIZE         (0x60000) /* NS partition: 384 KB */
+#define FLASH_NS_PARTITION_SIZE         (0x200000) /* NS partition: 1MB */
 #define FLASH_MAX_PARTITION_SIZE        ((FLASH_S_PARTITION_SIZE >   \
                                           FLASH_NS_PARTITION_SIZE) ? \
                                          FLASH_S_PARTITION_SIZE :    \
@@ -66,11 +67,11 @@
 /* Sector size of the flash hardware; same as FLASH0_SECTOR_SIZE */
 #define FLASH_AREA_IMAGE_SECTOR_SIZE    (0x1000)     /* 4 KB */
 /* Same as FLASH0_SIZE */
-#define FLASH_TOTAL_SIZE                (SRAM_SIZE)  /* 2 MB */
+#define FLASH_TOTAL_SIZE                (QSPI_SRAM_SIZE)  /* 2 MB */
 
 /* Flash layout info for BL2 bootloader */
 /* Same as FLASH0_BASE_S */
-#define FLASH_BASE_ADDRESS              (SRAM_BASE_S)
+#define FLASH_BASE_ADDRESS              (QSPI_SRAM_BASE_S)
 
 /* Offset and size definitions of the flash partitions that are handled by the
  * bootloader. The image swapping is done between IMAGE_PRIMARY and
@@ -83,7 +84,7 @@
 #if !defined(MCUBOOT_IMAGE_NUMBER) || (MCUBOOT_IMAGE_NUMBER == 1)
 /* Secure + Non-secure image primary slot */
 #define FLASH_AREA_0_ID            (1)
-#define FLASH_AREA_0_OFFSET        (0)
+#define FLASH_AREA_0_OFFSET        (0)//(FLASH_AREA_BL2_OFFSET + FLASH_AREA_BL2_SIZE)//
 #define FLASH_AREA_0_SIZE          (FLASH_S_PARTITION_SIZE + \
                                     FLASH_NS_PARTITION_SIZE)
 /* Secure + Non-secure secondary slot */
@@ -106,7 +107,7 @@
 #elif (MCUBOOT_IMAGE_NUMBER == 2)
 /* Secure image primary slot */
 #define FLASH_AREA_0_ID            (1)
-#define FLASH_AREA_0_OFFSET        (0)
+#define FLASH_AREA_0_OFFSET        (0)//(FLASH_AREA_BL2_OFFSET + FLASH_AREA_BL2_SIZE)//
 #define FLASH_AREA_0_SIZE          (FLASH_S_PARTITION_SIZE)
 /* Non-secure image primary slot */
 #define FLASH_AREA_1_ID            (FLASH_AREA_0_ID + 1)
@@ -136,7 +137,7 @@
 
 /* mpc_init_cfg function in target_cfg.c expects that all the images can fit
  * in SRAM area. */
-#if ( FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE > SRAM_SIZE)
+#if ( FLASH_AREA_SCRATCH_OFFSET + FLASH_AREA_SCRATCH_SIZE > QSPI_SRAM_SIZE)
 #error "Out of SRAM memory!"
 #endif
 
diff --git a/lib/tf-m/secure_fw/partitions/idle_partition/idle_partition.c b/lib/tf-m/secure_fw/partitions/idle_partition/idle_partition.c
new file mode 100644
index 0000000000000000000000000000000000000000..90cd4da3a45204c5a0d245e3f283136a6104be2d
--- /dev/null
+++ b/lib/tf-m/secure_fw/partitions/idle_partition/idle_partition.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include "cmsis.h"
+#include "fih.h"
+#include "psa/service.h"
+
+void tfm_idle_thread(void)
+{
+    while (1) {
+        /*
+         * There could be other Partitions becoming RUNABLE after wake up.
+         * This is a dummy psa_wait to let SPM check possible scheduling.
+         * It does not expect any signals.
+         */
+        if (psa_wait(PSA_WAIT_ANY, PSA_POLL) == 0) {
+            __WFI();
+        }
+    }
+
+#ifdef TFM_FIH_PROFILE_ON
+    fih_delay();
+
+    while (1) {
+        /*
+         * There could be other Partitions becoming RUNABLE after wake up.
+         * This is a dummy psa_wait to let SPM check possible scheduling.
+         * It does not expect any signals.
+         */
+        if (psa_wait(PSA_WAIT_ANY, PSA_POLL) == 0) {
+            __WFI();
+        }
+    }
+#endif
+}
diff --git a/lib/tf-m/platform/ext/cmsis/core_cm33.h b/lib/tf-m/platform/ext/cmsis/core_cm33.h
index 7fed59a88e31707a7fc126bd96f5b9cb84d8b1fd..47ba42d99b02bf66dbbd8a84456257f9bd1df8a5 100644
--- a/lib/tf-m/platform/ext/cmsis/core_cm33.h
+++ b/lib/tf-m/platform/ext/cmsis/core_cm33.h
@@ -938,6 +938,19 @@ typedef struct
 #define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
 #define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
 
+/* Coprocessor Power Control Register Definitions */
+#define SCnSCB_CPPWR_SUS11_Pos              23U                                        /*!< CPPWR: SUS11 Position */
+#define SCnSCB_CPPWR_SUS11_Msk              (1UL << SCnSCB_CPPWR_SUS11_Pos)            /*!< CPPWR: SUS11 Mask */
+
+#define SCnSCB_CPPWR_SU11_Pos               22U                                        /*!< CPPWR: SU11 Position */
+#define SCnSCB_CPPWR_SU11_Msk               (1UL << SCnSCB_CPPWR_SU11_Pos)             /*!< CPPWR: SU11 Mask */
+
+#define SCnSCB_CPPWR_SUS10_Pos              21U                                        /*!< CPPWR: SUS10 Position */
+#define SCnSCB_CPPWR_SUS10_Msk              (1UL << SCnSCB_CPPWR_SUS10_Pos)            /*!< CPPWR: SUS10 Mask */
+
+#define SCnSCB_CPPWR_SU10_Pos               20U                                        /*!< CPPWR: SU10 Position */
+#define SCnSCB_CPPWR_SU10_Msk               (1UL << SCnSCB_CPPWR_SU10_Pos)             /*!< CPPWR: SU10 Mask */
+
 /*@} end of group CMSIS_SCnotSCB */
 
 
diff --git a/lib/tf-m/interface/src/tfm_crypto_func_api.c b/lib/tf-m/interface/src/tfm_crypto_func_api.c
index 6ff25a1e73f1ce094dcb13239c40eee1d16940ad..6e6c419fe2e485789fb87c513f259259324d2757 100644
--- a/lib/tf-m/interface/src/tfm_crypto_func_api.c
+++ b/lib/tf-m/interface/src/tfm_crypto_func_api.c
@@ -861,16 +861,63 @@ psa_status_t psa_aead_decrypt(psa_key_id_t key,
     return status;
 }
 
-psa_status_t psa_asymmetric_sign(psa_key_id_t key,
-                                 psa_algorithm_t alg,
-                                 const uint8_t *hash,
-                                 size_t hash_length,
-                                 uint8_t *signature,
-                                 size_t signature_size,
-                                 size_t *signature_length)
+psa_status_t psa_sign_message(psa_key_id_t key,
+                              psa_algorithm_t alg,
+                              const uint8_t *input,
+                              size_t input_length,
+                              uint8_t *signature,
+                              size_t signature_size,
+                              size_t *signature_length)
+{
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_SIGN_MESSAGE_SID,
+        .key_id = key,
+        .alg = alg,
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = signature, .len = signature_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_sign_message,
+                          TFM_CRYPTO_SIGN_MESSAGE);
+
+    if (status == PSA_SUCCESS) {
+        *signature_length = out_vec[0].len;
+    }
+
+    return status;
+}
+
+psa_status_t psa_verify_message(psa_key_id_t key,
+                                psa_algorithm_t alg,
+                                const uint8_t *input,
+                                size_t input_length,
+                                const uint8_t *signature,
+                                size_t signature_length)
 {
-    return psa_sign_hash(key, alg, hash, hash_length, signature,
-                         signature_size, signature_length);
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_VERIFY_MESSAGE_SID,
+        .key_id = key,
+        .alg = alg
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = signature, .len = signature_length}
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_message,
+                                    TFM_CRYPTO_VERIFY_MESSAGE);
+
+    return status;
 }
 
 psa_status_t psa_sign_hash(psa_key_id_t key,
@@ -904,17 +951,6 @@ psa_status_t psa_sign_hash(psa_key_id_t key,
     return status;
 }
 
-psa_status_t psa_asymmetric_verify(psa_key_id_t key,
-                                   psa_algorithm_t alg,
-                                   const uint8_t *hash,
-                                   size_t hash_length,
-                                   const uint8_t *signature,
-                                   size_t signature_length)
-{
-    return psa_verify_hash(key, alg, hash, hash_length,
-                           signature, signature_length);
-}
-
 psa_status_t psa_verify_hash(psa_key_id_t key,
                              psa_algorithm_t alg,
                              const uint8_t *hash,
@@ -1248,8 +1284,26 @@ psa_status_t psa_mac_compute(psa_key_id_t key,
                              size_t *mac_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_COMPUTE_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = mac, .len = mac_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_mac_compute,
+                          TFM_CRYPTO_MAC_COMPUTE);
+
+    if (status == PSA_SUCCESS) {
+        *mac_length = out_vec[0].len;
+    }
 
     return status;
 }
@@ -1262,8 +1316,20 @@ psa_status_t psa_mac_verify(psa_key_id_t key,
                             const size_t mac_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_VERIFY_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = mac, .len = mac_length},
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_mac_verify,
+                                    TFM_CRYPTO_MAC_VERIFY);
 
     return status;
 }
@@ -1277,8 +1343,26 @@ psa_status_t psa_cipher_encrypt(psa_key_id_t key,
                                 size_t *output_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_ENCRYPT_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_encrypt,
+                          TFM_CRYPTO_CIPHER_ENCRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
 }
@@ -1292,8 +1376,26 @@ psa_status_t psa_cipher_decrypt(psa_key_id_t key,
                                 size_t *output_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_DECRYPT_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_decrypt,
+                          TFM_CRYPTO_CIPHER_DECRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
 }
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/sha256_alt.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/sha256_alt.c
index 4b9c29e9a30a546176380a7caca1a956402a4b88..70ed813346d233c9ea0568fc41ef5f424283c4c6 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/sha256_alt.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/sha256_alt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -47,7 +47,7 @@ void mbedtls_sha256_clone( mbedtls_sha256_context *dst,
 /*
  * SHA-256 context setup
  */
-int mbedtls_sha256_starts_ret( mbedtls_sha256_context *ctx, int is224 )
+int mbedtls_sha256_starts( mbedtls_sha256_context *ctx, int is224 )
 {
     int ret;
 
@@ -84,7 +84,7 @@ int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx, const unsigned
 }
 
 
-int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen )
+int mbedtls_sha256_update( mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen )
 {
     int ret;
 
@@ -101,7 +101,7 @@ int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx, const unsigned char
 /*
  * SHA-256 final digest
  */
-int mbedtls_sha256_finish_ret( mbedtls_sha256_context *ctx, unsigned char output[32] )
+int mbedtls_sha256_finish( mbedtls_sha256_context *ctx, unsigned char output[32] )
 {
     int ret;
     HashContext_t *pHashCtx = NULL;
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/mailbox_ipc_intr.c b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/mailbox_ipc_intr.c
index 89bdc3787dafe74e0729d25bff5219f158b51518..55084a0b56e449a8194913aa94e6d25baf6f34bc 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/mailbox_ipc_intr.c
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/mailbox/mailbox_ipc_intr.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2019, Arm Limited. All rights reserved.
+ * Copyright (c) 2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -19,7 +20,7 @@ __STATIC_INLINE void tfm_trigger_pendsv(void)
     SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
 }
 
-void mailbox_clear_intr(void)
+static void mailbox_clear_intr(void)
 {
     uint32_t status;
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
index b96c8cc2592b9b1b9ad687b682088c091309e977..9ae72a9814b1a4422716775a8014a34e50c66c0f 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/arch/tfm_arch_v8m_main.c
@@ -61,6 +61,23 @@ __attribute__((naked)) void PendSV_Handler(void)
         "bxeq    lr                         \n" /* Yes, do not schedule */
         "mrs     r0, psp                    \n"
         "mrs     r1, psplim                 \n"
+#if (TFM_SYSTEM_FP >= 1)
+        "tst     lr, #0x10                  \n" /* Current thread uses FPU? */
+        "bne     non_fp                     \n"
+        "ldr     r2, =0xE000EF34            \n"
+        "ldr     r3, [r2]                   \n"
+        "tst     r3, #0x40000000            \n" /* Lazy stacking enabled? */
+        "beq     non_fp                     \n"
+        "tst     r3, #0x1                   \n" /* Lazy stacking active? */
+        "beq     non_fp                     \n"
+        "vmov    s0, s0                     \n" /* Trigger lazy stacking */
+#if (TFM_LVL != 1)
+        "ldr     r3, =0xE000EF38            \n"
+        "mov     r1, 0                      \n"
+        "str     r1, [r3]                   \n" /* Clear FP context address */
+#endif /* TFM_LVL != 1 */
+        "non_fp:                            \n"
+#endif /* TFM_SYSTEM_FP >= 1 */        
         "push    {r0, r1, r2, lr}           \n"
         "push    {r4-r11}                   \n"
         "mov     r0, sp                     \n"
@@ -97,7 +114,8 @@ __attribute__((naked)) void SecureFault_Handler(void)
 }
 
 #if defined(__ICCARM__)
-uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return);
+uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
+                              uint32_t *psp);
 #pragma required = tfm_core_svc_handler
 #endif
 
@@ -105,10 +123,37 @@ __attribute__((naked)) void SVC_Handler(void)
 {
     __ASM volatile(
     "MRS     r0, MSP                        \n"
-    "MRS     r1, PSP                        \n"
-    "MOV     r2, lr                         \n"
-    "BL      tfm_core_svc_handler           \n"
-    "BX      r0                             \n"
+    "MOV     r1, lr                         \n"
+    "MRS     r2, PSP                        \n"
+    "SUB     sp, #8                         \n" /* For FLIH PID and signal */
+    "PUSH    {r1, r2}                       \n" /* Orig_exc_return, PSP */
+    "BL      tfm_core_svc_handler           \n" /* New EXC_RET returned */
+    "MOV     lr, r0                         \n"
+    "LDR     r1, [sp]                       \n" /* Original EXC_RETURN */
+    "AND     r0, #8                         \n" /* Mode bit */
+    "AND     r1, #8                         \n"
+    "SUBS    r0, r1                         \n" /* Compare EXC_RETURN values */
+    "BGT     to_flih_func                   \n"
+    "BLT     from_flih_func                 \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
+    "to_flih_func:                          \n"
+    "PUSH    {r4-r11}                       \n"
+    "LDR     r4, =0xFEF5EDA5                \n" /* clear r4-r11 */
+    "MOV     r5, r4                         \n"
+    "MOV     r6, r4                         \n"
+    "MOV     r7, r4                         \n"
+    "MOV     r8, r4                         \n"
+    "MOV     r9, r4                         \n"
+    "MOV     r10, r4                        \n"
+    "MOV     r11, r4                        \n"
+    "PUSH    {r4, r5}                       \n" /* Seal stack before EXC_RET */
+    "BX      lr                             \n"
+    "from_flih_func:                        \n"
+    "ADD     sp, #24                        \n"
+    "POP     {r4-r11}                       \n"
+    "ADD     sp, #16                        \n"
+    "BX      lr                             \n"
     );
 }
 
@@ -205,10 +250,19 @@ void tfm_arch_config_extensions(void)
      * latency when the FPU is not used by the SPE.
      */
 #if defined(__FPU_USED) && (__FPU_USED == 1U)
+/* For secure uses FPU only */
+#if (TFM_SYSTEM_FP >= 1)
     /* Enable Secure privileged and unprivilged access to the FP Extension */
     SCB->CPACR |= (3U << 10U*2U)     /* enable CP10 full access */
                   | (3U << 11U*2U);  /* enable CP11 full access */
 
+#ifdef TFM_LAZY_FP
+    /* Enable lazy stacking */
+    FPU->FPCCR |= FPU_FPCCR_LSPEN_Msk;
+#else
+    /* Disable lazy stacking */
+    FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk;
+#endif
     /* If the SPE will ever use the floating-point registers for sensitive data,
      * then FPCCR.TS, FPCCR.CLRONRET and FPCCR.CLRONRETS must be set at
      * initialisation and not changed again afterwards.
@@ -216,7 +270,18 @@ void tfm_arch_config_extensions(void)
     FPU->FPCCR |= FPU_FPCCR_TS_Msk
                   | FPU_FPCCR_CLRONRET_Msk
                   | FPU_FPCCR_CLRONRETS_Msk;
+#if (TFM_SYSTEM_FP_NS == 0)
+    /* If FPU is used by secure only, prevent non-secure from modifying FPUs
+     * power setting.
+     */
+    SCnSCB->CPPWR |= SCnSCB_CPPWR_SUS11_Msk | SCnSCB_CPPWR_SUS10_Msk;
 #endif
+#endif /* TFM_SYSTEM_FP >= 1 */
+
+#endif /* __FPU_USED */
+#endif /* __FPU_PRESENT */
+
+#if (TFM_SYSTEM_FP_NS >= 1)
 
     /* Permit Non-secure access to the Floating-point Extension.
      * Note: It is still necessary to set CPACR_NS to enable the FP Extension in
@@ -224,10 +289,18 @@ void tfm_arch_config_extensions(void)
      */
     SCB->NSACR |= SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk;
 
+#if (TFM_SYSTEM_FP == 0) && (TFM_LAZY_FP_NS == 0)
+    /* If only non-secure uses FPU with lazy stacking disabled, enable FPU on
+     * secure side as well.
+     */
+    SCB->CPACR |= (3U << 10U*2U)     /* enable CP10 full access */
+                  | (3U << 11U*2U);  /* enable CP11 full access */
+#endif
+#endif /* TFM_SYSTEM_FP_NS >= 1 */
+
 #if defined(__ARM_ARCH_8_1M_MAIN__)
     SCB->CCR |= SCB_CCR_TRD_Msk;
 #endif
-#endif
 }
 
 __attribute__((naked, noinline)) void tfm_arch_clear_fp_status(void)
diff --git a/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c b/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
index fee91a905bf2f8a7779984774dd98009a39ac49a..9844bb4a8b44ca83b66f224c41ad353daf72d950 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/spm_hal.c
@@ -100,11 +100,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/lib/ext/t_cose/crypto_adapters/t_cose_psa_crypto.c b/lib/tf-m/lib/ext/t_cose/crypto_adapters/t_cose_psa_crypto.c
index 22203dd5e35f93cbaf877c36558931330c9ecc62..20ab764e3131a320ab5d21d7dc825ea735d6dc43 100644
--- a/lib/tf-m/lib/ext/t_cose/crypto_adapters/t_cose_psa_crypto.c
+++ b/lib/tf-m/lib/ext/t_cose/crypto_adapters/t_cose_psa_crypto.c
@@ -2,7 +2,7 @@
  * t_cose_psa_crypto.c
  *
  * Copyright 2019, Laurence Lundblade
- * Copyright (c) 2020, Arm Limited. All rights reserved
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -100,7 +100,7 @@ static enum t_cose_err_t psa_status_to_t_cose_error_signing(psa_status_t err)
            err == PSA_ERROR_INVALID_SIGNATURE   ? T_COSE_ERR_SIG_VERIFY :
            err == PSA_ERROR_NOT_SUPPORTED       ? T_COSE_ERR_UNSUPPORTED_SIGNING_ALG:
            err == PSA_ERROR_INSUFFICIENT_MEMORY ? T_COSE_ERR_INSUFFICIENT_MEMORY :
-           err == PSA_ERROR_TAMPERING_DETECTED  ? T_COSE_ERR_TAMPERING_DETECTED :
+           err == PSA_ERROR_CORRUPTION_DETECTED ? T_COSE_ERR_TAMPERING_DETECTED :
                                                   T_COSE_ERR_SIG_FAIL;
 }
 
@@ -134,7 +134,7 @@ t_cose_crypto_pub_key_verify(int32_t               cose_algorithm_id,
      * signing_key passed in, not the cose_algorithm_id This check
      * looks for ECDSA signing as indicated by COSE and rejects what
      * is not. (Perhaps this check can be removed to save object code
-     * if it is the case that psa_asymmetric_verify() does the right
+     * if it is the case that psa_verify_hash() does the right
      * checks).
      */
     if(!PSA_ALG_IS_ECDSA(psa_alg_id)) {
@@ -183,7 +183,7 @@ t_cose_crypto_pub_key_sign(int32_t                cose_algorithm_id,
      * signing_key passed in, not the cose_algorithm_id This check
      * looks for ECDSA signing as indicated by COSE and rejects what
      * is not. (Perhaps this check can be removed to save object code
-     * if it is the case that psa_asymmetric_verify() does the right
+     * if it is the case that psa_verify_hash() does the right
      * checks).
      */
     if(!PSA_ALG_IS_ECDSA(psa_alg_id)) {
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/spm_hal.c
index f9ecd8c7ea2daba49abd958e3ed568c8b2bb8d1c..dbdd20e33bc34224795ddfa9aa5263631841c97b 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/spm_hal.c
@@ -113,11 +113,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c b/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
index 46f0de0d24c7bfac47c58a9babcb53421756ddcf..47898aeba3ae2eb7d4f4bb59e359efaa3084429e 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_s1/spm_hal.c
@@ -91,11 +91,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/secure_fw/spm/include/interface/svc_num.h b/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
index 23b9e04b8c5133b8cd27798ae8feb171a67f7542..7a3c3c521cb1dbc5fa2c7d2614f4f1f0319cc6e4 100644
--- a/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
+++ b/lib/tf-m/secure_fw/spm/include/interface/svc_num.h
@@ -37,10 +37,12 @@
 #define TFM_SVC_PSA_LIFECYCLE           (0x10)
 #define TFM_SVC_PSA_IRQ_ENABLE          (0x11)
 #define TFM_SVC_PSA_IRQ_DISABLE         (0x12)
+#define TFM_SVC_PSA_RESET_SIGNAL        (0x13)
 /* TF-M specific, starts from 0x40 */
 #define TFM_SVC_SPM_REQUEST             (0x40)
 #define TFM_SVC_GET_BOOT_DATA           (0x41)
 #define TFM_SVC_SPM_INIT                (0x42)
+#define TFM_SVC_FLIH_FUNC_RETURN        (0x43)
 #define TFM_SVC_THREAD_NUMBER_END       (0x7F)
 #if (TFM_SPM_LOG_LEVEL > TFM_SPM_LOG_LEVEL_SILENCE)
 #define TFM_SVC_OUTPUT_UNPRIV_STRING    (TFM_SVC_THREAD_NUMBER_END)
@@ -49,5 +51,6 @@
 #define TFM_SVC_HANDLER_NUMBER_START    (0x80)
 
 /********************* SVC for interrupt handling *****************************/
+#define TFM_SVC_PREPARE_DEPRIV_FLIH     (0x80)
 
 #endif /* __SVC_NUM_H__ */
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
index 33a2b90a70ada1ae2c36e0b46769b5cd2479b217..f8e5307e74087b7fe8803a5e11bb17b8937982a1 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/config/device_cfg.h
@@ -29,6 +29,9 @@
 #define MPC_ISRAM1_S
 #define MPC_SRAM_S
 #define MPC_QSPI_S
+#define MPC_DDR4_S
+
+#define MPC_DDR4_DEV MPC_DDR4_DEV_S
 
 /* ARM Peripheral Protection Controllers (PPC) */
 #define PPC_SSE300_MAIN0_S
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecp_common.h b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecp_common.h
index a232d537c79566f93b57a6410e0af2708a1c7b76..a87b530ea6df77dd8f83962b7bad14d361a86faf 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecp_common.h
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecp_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -38,10 +38,10 @@ int error_mapping_cc_to_mbedtls_ecc (CCError_t cc_error);
  */
 static inline ecp_curve_type ecp_get_type(const mbedtls_ecp_group *grp)
 {
-    if (grp->G.X.p == NULL)
+    if (grp->G.MBEDTLS_PRIVATE(X).MBEDTLS_PRIVATE(p) == NULL)
         return (ECP_TYPE_NONE);
 
-    if (grp->G.Y.p == NULL)
+    if (grp->G.MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(p) == NULL)
         return (ECP_TYPE_25519);
     else
         return (ECP_TYPE_SHORT_WEIERSTRASS);
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
index 38fda1b19c7400c8ef238e2b89b5d51cfeee3cc9..33996834c2d0c17881fe29454c1fd67bd3e794b2 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_key_derivation.c
@@ -29,7 +29,7 @@ static psa_status_t tfm_crypto_huk_derivation_setup(
                                       psa_key_derivation_operation_t *operation,
                                       psa_algorithm_t alg)
 {
-    operation->alg = TFM_CRYPTO_ALG_HUK_DERIVATION;
+    operation->MBEDTLS_PRIVATE(alg) = TFM_CRYPTO_ALG_HUK_DERIVATION;
     return PSA_SUCCESS;
 }
 
@@ -41,6 +41,7 @@ static psa_status_t tfm_crypto_huk_derivation_input_bytes(
 {
     psa_status_t status;
     int32_t partition_id;
+    psa_tls12_prf_key_derivation_t *tls12_prf;
 
     if (step != PSA_KEY_DERIVATION_INPUT_LABEL) {
         return PSA_ERROR_INVALID_ARGUMENT;
@@ -66,16 +67,18 @@ static psa_status_t tfm_crypto_huk_derivation_input_bytes(
     /* Put the label in the tls12_prf ctx to make it available in the output key
      * step.
      */
-    operation->ctx.tls12_prf.label = mbedtls_calloc(1, sizeof(partition_id)
-                                                       + data_length);
-    if (operation->ctx.tls12_prf.label == NULL) {
+    tls12_prf = &(operation->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(tls12_prf));
+    tls12_prf->MBEDTLS_PRIVATE(label) =
+                 mbedtls_calloc(1, sizeof(partition_id) + data_length);
+    if (tls12_prf->MBEDTLS_PRIVATE(label) == NULL) {
         return PSA_ERROR_INSUFFICIENT_MEMORY;
     }
-    (void)tfm_memcpy(operation->ctx.tls12_prf.label, &partition_id,
+    (void)tfm_memcpy(tls12_prf->MBEDTLS_PRIVATE(label), &partition_id,
                      sizeof(partition_id));
-    (void)tfm_memcpy(operation->ctx.tls12_prf.label + sizeof(partition_id),
+    (void)tfm_memcpy(tls12_prf->MBEDTLS_PRIVATE(label) + sizeof(partition_id),
                      data, data_length);
-    operation->ctx.tls12_prf.label_length = sizeof(partition_id) + data_length;
+    tls12_prf->MBEDTLS_PRIVATE(label_length) = sizeof(partition_id) +
+                                               data_length;
 
     return PSA_SUCCESS;
 }
@@ -87,32 +90,37 @@ static psa_status_t tfm_crypto_huk_derivation_output_key(
 {
     enum tfm_plat_err_t err;
     size_t bytes = PSA_BITS_TO_BYTES(psa_get_key_bits(attributes));
+    psa_tls12_prf_key_derivation_t *tls12_prf =
+                &(operation->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(tls12_prf));
 
-    if (sizeof(operation->ctx.tls12_prf.output_block) < bytes) {
+    if (sizeof(tls12_prf->MBEDTLS_PRIVATE(output_block)) < bytes) {
         return PSA_ERROR_INSUFFICIENT_MEMORY;
     }
 
     /* Derive key material from the HUK and output it to the operation buffer */
-    err = tfm_plat_get_huk_derived_key(operation->ctx.tls12_prf.label,
-                                       operation->ctx.tls12_prf.label_length,
+    err = tfm_plat_get_huk_derived_key(tls12_prf->MBEDTLS_PRIVATE(label),
+                                       tls12_prf->MBEDTLS_PRIVATE(label_length),
                                        NULL, 0,
-                                       operation->ctx.tls12_prf.output_block,
+                                       tls12_prf->MBEDTLS_PRIVATE(output_block),
                                        bytes);
     if (err != TFM_PLAT_ERR_SUCCESS) {
         return PSA_ERROR_HARDWARE_FAILURE;
     }
 
-    return psa_import_key(attributes, operation->ctx.tls12_prf.output_block,
+    return psa_import_key(attributes, tls12_prf->MBEDTLS_PRIVATE(output_block),
                           bytes, key_id);
 }
 
 static psa_status_t tfm_crypto_huk_derivation_abort(
                                       psa_key_derivation_operation_t *operation)
 {
-    if (operation->ctx.tls12_prf.label != NULL) {
-        (void)tfm_memset(operation->ctx.tls12_prf.label, 0,
-                         operation->ctx.tls12_prf.label_length);
-        mbedtls_free(operation->ctx.tls12_prf.label);
+    psa_tls12_prf_key_derivation_t *tls12_prf =
+                &(operation->MBEDTLS_PRIVATE(ctx).MBEDTLS_PRIVATE(tls12_prf));
+
+    if (tls12_prf->MBEDTLS_PRIVATE(label) != NULL) {
+        (void)tfm_memset(tls12_prf->MBEDTLS_PRIVATE(label), 0,
+                         tls12_prf->MBEDTLS_PRIVATE(label_length));
+        mbedtls_free(tls12_prf->MBEDTLS_PRIVATE(label));
     }
 
     (void)tfm_memset(operation, 0, sizeof(*operation));
@@ -273,7 +281,7 @@ psa_status_t tfm_crypto_key_derivation_input_bytes(psa_invec in_vec[],
         return status;
     }
 
-    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
+    if (operation->MBEDTLS_PRIVATE(alg) == TFM_CRYPTO_ALG_HUK_DERIVATION) {
         return tfm_crypto_huk_derivation_input_bytes(operation, step, data,
                                                      data_length);
     } else {
@@ -414,7 +422,7 @@ psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
         return status;
     }
 
-    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
+    if (operation->MBEDTLS_PRIVATE(alg) == TFM_CRYPTO_ALG_HUK_DERIVATION) {
         status = tfm_crypto_huk_derivation_output_key(&key_attributes,
                                                       operation, &encoded_key);
     } else {
@@ -422,7 +430,7 @@ psa_status_t tfm_crypto_key_derivation_output_key(psa_invec in_vec[],
                                                &encoded_key);
     }
 #ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    *key_handle = encoded_key.key_id;
+    *key_handle = encoded_key.MBEDTLS_PRIVATE(key_id);
 #else
     *key_handle = (psa_key_id_t)encoded_key;
 #endif
@@ -471,7 +479,7 @@ psa_status_t tfm_crypto_key_derivation_abort(psa_invec in_vec[],
 
     *handle_out = handle;
 
-    if (operation->alg == TFM_CRYPTO_ALG_HUK_DERIVATION) {
+    if (operation->MBEDTLS_PRIVATE(alg) == TFM_CRYPTO_ALG_HUK_DERIVATION) {
         status = tfm_crypto_huk_derivation_abort(operation);
     } else {
         status = psa_key_derivation_abort(operation);
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_edwards.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_edwards.c
index 039b37e49eb2519d136e9fb06f2a942959bed366..12a547c246d10c5a24ff6b16a8a393bf51a4f162 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_edwards.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/mbedtls_api/ecdsa_edwards.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2019, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -95,9 +95,9 @@ int mbedtls_ecdsa_genkey_edwards( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
     }
 
-    grp = &ctx->grp;
-    d = &ctx->d;
-    Q = &ctx->Q;
+    grp = &ctx->MBEDTLS_PRIVATE(grp);
+    d = &ctx->MBEDTLS_PRIVATE(d);
+    Q = &ctx->MBEDTLS_PRIVATE(Q);
 
     pDomain = EcEdwGetDomain25519();
     if (NULL == pDomain)
@@ -139,13 +139,13 @@ int mbedtls_ecdsa_genkey_edwards( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_
         ret =  error_mapping_cc_to_mbedtls_ecc(rc);
         goto END;
     }
-     ret = mbedtls_mpi_read_binary(&Q->Y, pPublicKey, CALC_FULL_BYTES(pDomain->ecModSizeInBits));
+     ret = mbedtls_mpi_read_binary(&Q->MBEDTLS_PRIVATE(Y), pPublicKey, CALC_FULL_BYTES(pDomain->ecModSizeInBits));
     if (ret != 0)
     {
          CC_PAL_LOG_ERR("Error - failed to allocate memory for Q->Y\n");
         goto END;
     }
-    Q->Y.s = 1; /*unsigned*/
+    Q->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
     ret = mbedtls_mpi_read_binary(d, pPrivKey, CALC_FULL_BYTES(2*pDomain->ecModSizeInBits));
     if (ret != 0)
@@ -153,7 +153,7 @@ int mbedtls_ecdsa_genkey_edwards( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_
          CC_PAL_LOG_ERR("Error - failed to allocate memory for Q->Y\n");
         goto END;
     }
-    d->s = 1; /*unsigned*/
+    d->MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
 
     /* Set the group curve order used by sign & verify functions */
@@ -299,7 +299,7 @@ int mbedtls_ecdsa_verify_edwards(mbedtls_ecp_group *grp, const unsigned char *bu
 
     /* Only the Y coordinate is required */
     pub_key_size = order_size;
-    ret = ecdsa_export_mpi_to_buff( &Q->Y, &pub_key_size, pub_key_buf, order_size );
+    ret = ecdsa_export_mpi_to_buff( &Q->MBEDTLS_PRIVATE(Y), &pub_key_size, pub_key_buf, order_size );
     if ((ret != 0) ||
         (pub_key_size != order_size))
     {
@@ -375,13 +375,13 @@ int mbedtls_ecdsa_public_key_read_edwards( mbedtls_ecp_point *Q,
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
     }
 
-    ret = mbedtls_mpi_read_binary(&Q->Y, buf, blen);
+    ret = mbedtls_mpi_read_binary(&Q->MBEDTLS_PRIVATE(Y), buf, blen);
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for Q->Y\n");
         return ret;
     }
-    Q->Y.s = 1; /*unsigned*/
+    Q->MBEDTLS_PRIVATE(Y).MBEDTLS_PRIVATE(s) = 1; /*unsigned*/
 
     return CC_OK;
 
@@ -411,7 +411,7 @@ int mbedtls_ecdsa_public_key_write_edwards( const mbedtls_ecp_point *Q,
     {
         return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
     }
-    ret = ecdsa_export_mpi_to_buff(&Q->Y, olen, buf, keySize);
+    ret = ecdsa_export_mpi_to_buff(&Q->MBEDTLS_PRIVATE(Y), olen, buf, keySize);
     if (ret != 0)
     {
         CC_PAL_LOG_ERR("Error - failed to allocate memory for Q->Y\n");
diff --git a/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.c b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.c
index 6cc823b611fdc942272a11a5fd5c2017a3e043d9..b83d0bed581b231e4eacbee68a856796fe967cc9 100644
--- a/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.c
+++ b/lib/tf-m/secure_fw/spm/ffm/psa_client_service_apis.c
@@ -145,6 +145,9 @@ psa_signal_t tfm_spm_psa_wait(uint32_t *args)
         (partition->signals_asserted & signal_mask) == 0) {
         partition->signals_waiting = signal_mask;
         tfm_event_wait(&partition->event);
+    } else if ((partition->signals_asserted & signal_mask) == 0) {
+        /* Activate scheduler to check if any higher priority thread to run */
+        tfm_core_thrd_activate_schedule();
     }
 
     return partition->signals_asserted & signal_mask;
@@ -592,6 +595,11 @@ void tfm_spm_psa_eoi(uint32_t *args)
         tfm_core_panic();
     }
 
+    if (irq_info->flih_func) {
+        /* This API is for SLIH IRQs only */
+        psa_panic();
+    }
+
     /* It is a fatal error if passed signal is not currently asserted */
     if ((partition->signals_asserted & irq_signal) == 0) {
         tfm_core_panic();
@@ -655,3 +663,38 @@ psa_irq_status_t tfm_spm_irq_disable(uint32_t *args)
 
     return 1;
 }
+
+void tfm_spm_psa_reset_signal(uint32_t *args)
+{
+    psa_signal_t irq_signal;
+    struct irq_load_info_t *irq_info;
+    struct partition_t *partition;
+
+    if (!args) {
+        tfm_core_panic();
+    }
+
+    irq_signal = (psa_signal_t)args[0];
+
+    partition = tfm_spm_get_running_partition();
+    if (!partition) {
+        tfm_core_panic();
+    }
+
+    irq_info = get_irq_info_for_signal(partition->p_ldinf, irq_signal);
+    if (!irq_info) {
+        tfm_core_panic();
+    }
+
+    if (!irq_info->flih_func) {
+        /* This API is for FLIH IRQs only */
+        tfm_core_panic();
+    }
+
+    if ((partition->signals_asserted & irq_signal) == 0) {
+        /* The signal is not asserted */
+        tfm_core_panic();
+    }
+
+    partition->signals_asserted &= ~irq_signal;
+}
diff --git a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/spm_hal.c b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/spm_hal.c
index 207db15c15aaa3640df10ccc7e05a1682f24a868..a609802463b87ccf15dc5b15556047118a1e1589 100644
--- a/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/musca_b1/secure_enclave/spm_hal.c
@@ -54,11 +54,9 @@ void tfm_spm_hal_wait_for_ns_cpu_ready(void)
     }
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
 
     return TFM_PLAT_ERR_SUCCESS;
 }
diff --git a/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct b/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
index 872b52b06a250ce3678d059f036f28a29c5c2889..c68fd6292dda72b8b0e5f711153a3b840ec0fb54 100644
--- a/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
+++ b/lib/tf-m/platform/ext/common/armclang/tfm_common_s.sct
@@ -196,6 +196,14 @@ LR_CODE S_CODE_START S_CODE_SIZE {
         * (+RW +ZI)
     }
 
+    ER_PART_RT_POOL +0 ALIGN 4 {
+        *(.bss.part_runtime)
+    }
+
+    ER_SERV_RT_POOL +0 ALIGN 4 {
+        *(.bss.serv_runtime)
+    }
+
     /**** PSA RoT DATA start here */
     /*
      * This empty, zero long execution region is here to mark the start address
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
index d28c2bb5bf2fc8c095513ba89a1016ad1cd57481..fa071dba0542b6f06c9550e159df1f30bcac8acc 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/retarget/platform_retarget_dev.c
@@ -304,17 +304,23 @@ struct ppc_sse200_dev_t APB_PPCEXP3_DEV_S = {
 static const struct cmsdk_timer_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.base = CMSDK_TIMER0_BASE_S};
 static struct cmsdk_timer_dev_data_t CMSDK_TIMER0_DEV_DATA_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.is_initialized = 0};
 
 struct cmsdk_timer_dev_t CMSDK_TIMER0_DEV_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
        = {&(CMSDK_TIMER0_DEV_CFG_S), &(CMSDK_TIMER0_DEV_DATA_S)};
 #endif
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
index c9a3d801b587266f3769d9941b91d0584cd1085d..3364478864b165c3cdf9e0d6c46b7e3093df6c82 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/ps_utils.h
@@ -62,6 +62,27 @@ psa_status_t ps_utils_check_contained_in(uint32_t superset_size,
                                          uint32_t subset_offset,
                                          uint32_t subset_size);
 
+
+#ifdef PS_ENCRYPTION
+/**
+ * \brief Fills the uint8_t buffer with the client_id and the uid
+ *
+ * \param[in]  uid            The data identifier
+ * \param[in]  client_id      Client id of the partition
+ * \param[out] buff           The output buffer
+ * \param[in]  buff_len       Length of the output buffer in bytes
+ *
+ * \retval PSA_SUCCESS                  Buffer filled successfully
+ * \retval PSA_ERROR_INVALID_ARGUMENT   The buffer pointer is NULL
+ * \retval PSA_ERROR_BUFFER_TOO_SMALL   The buffer cannot fit the client_id + uid
+ *
+ */
+psa_status_t ps_utils_fill_key_label(psa_storage_uid_t uid,
+                                     int32_t client_id,
+                                     uint8_t *buff,
+                                     size_t buff_len);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
index 7f30bca43906a73db6af617f4d1ba1f7fff8697e..a28afe1a4c068948a0be9d683512af100d2b9b11 100644
--- a/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
+++ b/lib/tf-m/secure_fw/partitions/psa_proxy/psa_proxy.c
@@ -43,16 +43,25 @@ static inline void deallocate_forward_handle(psa_handle_t *h)
     tfm_pool_free(forward_handle_pool, h);
 }
 
-static psa_status_t forward_psa_call_to_secure_enclave(const psa_msg_t *msg)
+static psa_status_t forward_psa_call_to_secure_enclave(psa_signal_t signal,
+                                                       const psa_msg_t *msg)
 {
     psa_status_t status;
-    psa_handle_t *forward_handle_ptr = (psa_handle_t *)msg->rhandle;
     struct psa_client_params_t params;
     int32_t ret;
 
-    params.psa_call_params.handle = *forward_handle_ptr;
     params.psa_call_params.type = PSA_IPC_CALL;
 
+    if (signal == TFM_CRYPTO_SIGNAL) {
+        /*
+         * The TF-M crypto service has been changed to stateless service, set
+         * the params with the stateless handle.
+         */
+        params.psa_call_params.handle = TFM_CRYPTO_HANDLE;
+    } else {
+        params.psa_call_params.handle = *((psa_handle_t *)msg->rhandle);
+    }
+
     status = psa_proxy_put_msg_into_shared_mem(msg, &params);
 
     if (status != PSA_SUCCESS) {
@@ -202,7 +211,7 @@ static void handle_signal(psa_signal_t signal)
         psa_reply(msg.handle, status);
         break;
     case PSA_IPC_CALL:
-        status = forward_psa_call_to_secure_enclave(&msg);
+        status = forward_psa_call_to_secure_enclave(signal, &msg);
         psa_reply(msg.handle, status);
         break;
     case PSA_IPC_DISCONNECT:
diff --git a/lib/tf-m/platform/include/mbedtls_entropy_nv_seed_config.h b/lib/tf-m/platform/include/mbedtls_entropy_nv_seed_config.h
new file mode 100644
index 0000000000000000000000000000000000000000..ba37aff9eb406a5a8f47dbd9efcc6fd8aee27adb
--- /dev/null
+++ b/lib/tf-m/platform/include/mbedtls_entropy_nv_seed_config.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef __MBEDTLS_AN521_CONF_H__
+#define __MBEDTLS_AN521_CONF_H__
+
+#include "tfm_plat_crypto_nv_seed.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#undef MBEDTLS_TEST_NULL_ENTROPY
+#undef MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
+#undef MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+
+#define MBEDTLS_ENTROPY_NV_SEED
+#ifndef MBEDTLS_PLATFORM_NV_SEED_READ_MACRO
+#define MBEDTLS_PLATFORM_NV_SEED_READ_MACRO  tfm_plat_crypto_nv_seed_read
+#endif
+#ifndef MBEDTLS_PLATFORM_NV_SEED_WRITE_MACRO
+#define MBEDTLS_PLATFORM_NV_SEED_WRITE_MACRO tfm_plat_crypto_nv_seed_write
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __MBEDTLS_AN521_CONF_H__ */
diff --git a/lib/tf-m/platform/ext/target/nxp/common/plat_attestation_key.c b/lib/tf-m/platform/ext/target/nxp/common/plat_attestation_key.c
index 643cb2e04e5ecd1ce4f5170a2ee5b55955f30278..976e5cdffa354ea5c1058d5149304027d57a0b5a 100644
--- a/lib/tf-m/platform/ext/target/nxp/common/plat_attestation_key.c
+++ b/lib/tf-m/platform/ext/target/nxp/common/plat_attestation_key.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017-2020 Arm Limited. All rights reserved.
+ * Copyright (c) 2017-2021 Arm Limited. All rights reserved.
  * Copyright 2020 NXP. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -54,7 +54,7 @@ const uint8_t initial_attestation_private_key[] =
 
 /* Type of the EC curve which the key belongs to, in PSA curve ID form */
 #ifndef TFM_ATTESTATION_KEY_TYPE
-#define TFM_ATTESTATION_KEY_TYPE PSA_ECC_CURVE_SECP256R1 
+#define TFM_ATTESTATION_KEY_TYPE PSA_ECC_FAMILY_SECP_R1
 #endif
 
 /**
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.c
index c9f4b8a50a6d1a690e120106977bd8d6b05749a7..2f457f26fe66ff0e52d3a41685dc2d4c1c397aee 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/accelerator/rsa_alt.c
@@ -1,7 +1,7 @@
 /*
  *  The RSA public-key cryptosystem
  *
- *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
+ *  Copyright (C) 2006-2021, ARM Limited, All Rights Reserved
  *  Copyright (C) 2020, STMicroelectronics, All Rights Reserved
  *  SPDX-License-Identifier: Apache-2.0
  *
@@ -49,8 +49,9 @@
 
 #if defined(MBEDTLS_RSA_C)
 
+#include "mbedtls/error.h"
 #include "mbedtls/rsa.h"
-#include "mbedtls/rsa_internal.h"
+#include "../library/rsa_alt_helpers.h"
 #include "mbedtls/oid.h"
 #include "mbedtls/platform_util.h"
 
@@ -276,9 +277,9 @@ static int rsa_pka_modexp( mbedtls_rsa_context *ctx,
     RSA_VALIDATE_RET( output != NULL );
 
     if ( is_private )
-        elen = mbedtls_mpi_size( &ctx->D );
+        elen = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(D) );
     else
-        elen = mbedtls_mpi_size( &ctx->E );
+        elen = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(E) );
 
     /* exponent aligned on 4 bytes */
     elen = ((elen + 3)/4)*4;
@@ -287,14 +288,14 @@ static int rsa_pka_modexp( mbedtls_rsa_context *ctx,
     MBEDTLS_MPI_CHK( ( e_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 
     if ( is_private )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->D, e_binary, elen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(D), e_binary, elen ) );
     else
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->E, e_binary, elen ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(E), e_binary, elen ) );
 
-    nlen = ctx->len;
+    nlen = ctx->MBEDTLS_PRIVATE(len);
     n_binary = mbedtls_calloc( 1, nlen );
     MBEDTLS_MPI_CHK( ( n_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->N, n_binary, nlen ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(N), n_binary, nlen ) );
 
     in.expSize = elen;           /* Exponent length */
     in.OpSize  = nlen;           /* modulus length */
@@ -495,17 +496,17 @@ int mbedtls_rsa_import( mbedtls_rsa_context *ctx,
     int ret;
     RSA_VALIDATE_RET( ctx != NULL );
 
-    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
-        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
-        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
-        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
-        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
+    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(N), N ) ) != 0 ) ||
+        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(P), P ) ) != 0 ) ||
+        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(Q), Q ) ) != 0 ) ||
+        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(D), D ) ) != 0 ) ||
+        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->MBEDTLS_PRIVATE(E), E ) ) != 0 ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
 
     if( N != NULL )
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
 
     return( 0 );
 }
@@ -522,21 +523,21 @@ int mbedtls_rsa_import_raw( mbedtls_rsa_context *ctx,
 
     if( N != NULL )
     {
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->N, N, N_len ) );
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(N), N, N_len ) );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
     }
 
     if( P != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->P, P, P_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(P), P, P_len ) );
 
     if( Q != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->Q, Q, Q_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(Q), Q, Q_len ) );
 
     if( D != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->D, D, D_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(D), D, D_len ) );
 
     if( E != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->E, E, E_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->MBEDTLS_PRIVATE(E), E, E_len ) );
 
 cleanup:
 
@@ -560,8 +561,8 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
     ((void) blinding_needed);
 #endif
 
-    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
-        ctx->len > MBEDTLS_MPI_MAX_SIZE )
+    if( ctx->MBEDTLS_PRIVATE(len) != mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) ) ||
+        ctx->MBEDTLS_PRIVATE(len) > MBEDTLS_MPI_MAX_SIZE )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -572,8 +573,8 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 
     /* Modular exponentiation wrt. N is always used for
      * RSA public key operations. */
-    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
-        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
+    if( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) <= 0 ||
+        mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(N), 0 ) == 0  )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -583,10 +584,10 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
      * used for private key operations and if CRT
      * is used. */
     if( is_priv &&
-        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
-          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
-          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
-          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
+        ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) <= 0 ||
+          mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(P), 0 ) == 0 ||
+          mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) <= 0 ||
+          mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(Q), 0 ) == 0  ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -597,18 +598,18 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
      */
 
     /* Always need E for public key operations */
-    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
+    if( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) <= 0 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
 #if defined(MBEDTLS_RSA_NO_CRT)
     /* For private key operations, use D or DP & DQ
      * as (unblinded) exponents. */
-    if( is_priv && mbedtls_mpi_cmp_int( &ctx->D, 0 ) <= 0 )
+    if( is_priv && mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) <= 0 )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 #else
     if( is_priv &&
-        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
-          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
+        ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DP), 0 ) <= 0 ||
+          mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(DQ), 0 ) <= 0  ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -619,8 +620,8 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
      * done as part of 1. */
 #if defined(MBEDTLS_RSA_NO_CRT)
     if( is_priv && blinding_needed &&
-        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
-          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ) )
+        ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) <= 0 ||
+          mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) <= 0 ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -630,7 +631,7 @@ static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
      * but check for QP >= 1 nonetheless. */
 #if !defined(MBEDTLS_RSA_NO_CRT)
     if( is_priv &&
-        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(QP), 0 ) <= 0 )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
     }
@@ -647,11 +648,11 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 
     RSA_VALIDATE_RET( ctx != NULL );
 
-    have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
-    have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
-    have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
-    have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
-    have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
+    have_N = ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 );
+    have_P = ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 );
+    have_Q = ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 );
+    have_D = ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 );
+    have_E = ( mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0 );
 
     /*
      * Check whether provided parameters are enough
@@ -680,13 +681,13 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 
     if( !have_N && have_P && have_Q )
     {
-        if( ( ret = rsa_mpi2pka_mul( &ctx->N, &ctx->P,
-                                     &ctx->Q ) ) != 0 )
+        if( ( ret = rsa_mpi2pka_mul( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(P),
+                                     &ctx->MBEDTLS_PRIVATE(Q) ) ) != 0 )
         {
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
         }
 
-        ctx->len = mbedtls_mpi_size( &ctx->N );
+        ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
     }
 
     /*
@@ -695,18 +696,18 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 
     if( pq_missing )
     {
-        ret = mbedtls_rsa_deduce_primes( &ctx->N, &ctx->E, &ctx->D,
-                                         &ctx->P, &ctx->Q );
+        ret = mbedtls_rsa_deduce_primes( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(E), &ctx->MBEDTLS_PRIVATE(D),
+                                         &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) );
         if( ret != 0 )
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 
     }
     else if( d_missing )
     {
-        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
-                                                         &ctx->Q,
-                                                         &ctx->E,
-                                                         &ctx->D ) ) != 0 )
+        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->MBEDTLS_PRIVATE(P),
+                                                         &ctx->MBEDTLS_PRIVATE(Q),
+                                                         &ctx->MBEDTLS_PRIVATE(E),
+                                                         &ctx->MBEDTLS_PRIVATE(D) ) ) != 0 )
         {
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
         }
@@ -719,8 +720,8 @@ int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
 #if !defined(MBEDTLS_RSA_NO_CRT)
     if( is_priv )
     {
-        ret = mbedtls_rsa_deduce_crt( &ctx->P,  &ctx->Q,  &ctx->D,
-                                      &ctx->DP, &ctx->DQ, &ctx->QP );
+        ret = mbedtls_rsa_deduce_crt( &ctx->MBEDTLS_PRIVATE(P),  &ctx->MBEDTLS_PRIVATE(Q),  &ctx->MBEDTLS_PRIVATE(D),
+                                      &ctx->MBEDTLS_PRIVATE(DP), &ctx->MBEDTLS_PRIVATE(DQ), &ctx->MBEDTLS_PRIVATE(QP) );
         if( ret != 0 )
             return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
@@ -746,11 +747,11 @@ int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
     if( !is_priv )
     {
@@ -762,19 +763,19 @@ int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
     }
 
     if( N != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->N, N, N_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(N), N, N_len ) );
 
     if( P != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->P, P, P_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(P), P, P_len ) );
 
     if( Q != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->Q, Q, Q_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(Q), Q, Q_len ) );
 
     if( D != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->D, D, D_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(D), D, D_len ) );
 
     if( E != NULL )
-        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->E, E, E_len ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->MBEDTLS_PRIVATE(E), E, E_len ) );
 
 cleanup:
 
@@ -791,11 +792,11 @@ int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
     if( !is_priv )
     {
@@ -808,11 +809,11 @@ int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,
 
     /* Export all requested core parameters. */
 
-    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->N ) ) != 0 ) ||
-        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->P ) ) != 0 ) ||
-        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->Q ) ) != 0 ) ||
-        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->D ) ) != 0 ) ||
-        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->E ) ) != 0 ) )
+    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->MBEDTLS_PRIVATE(N) ) ) != 0 ) ||
+        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->MBEDTLS_PRIVATE(P) ) ) != 0 ) ||
+        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->MBEDTLS_PRIVATE(Q) ) ) != 0 ) ||
+        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->MBEDTLS_PRIVATE(D) ) ) != 0 ) ||
+        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->MBEDTLS_PRIVATE(E) ) ) != 0 ) )
     {
         return( ret );
     }
@@ -835,25 +836,25 @@ int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,
 
     /* Check if key is private or public */
     is_priv =
-        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
-        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(N), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(P), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(Q), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(D), 0 ) != 0 &&
+        mbedtls_mpi_cmp_int( &ctx->MBEDTLS_PRIVATE(E), 0 ) != 0;
 
     if( !is_priv )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
     /* Export all requested blinding parameters. */
-    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->DP ) ) != 0 ) ||
-        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->DQ ) ) != 0 ) ||
-        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->QP ) ) != 0 ) )
+    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->MBEDTLS_PRIVATE(DP) ) ) != 0 ) ||
+        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->MBEDTLS_PRIVATE(DQ) ) ) != 0 ) ||
+        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->MBEDTLS_PRIVATE(QP) ) ) != 0 ) )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
     }
 #else
-    if( ( ret = mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
+    if( ( ret = mbedtls_rsa_deduce_crt( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(D),
                                         DP, DQ, QP ) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
@@ -866,35 +867,31 @@ int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,
 /*
  * Initialize an RSA context
  */
-void mbedtls_rsa_init( mbedtls_rsa_context *ctx,
-               int padding,
-               int hash_id )
+void mbedtls_rsa_init( mbedtls_rsa_context *ctx )
 {
     RSA_VALIDATE( ctx != NULL );
-    RSA_VALIDATE( padding == MBEDTLS_RSA_PKCS_V15 ||
-                  padding == MBEDTLS_RSA_PKCS_V21 );
 
     memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 
-    mbedtls_rsa_set_padding( ctx, padding, hash_id );
-
 #if defined(MBEDTLS_THREADING_C)
-    mbedtls_mutex_init( &ctx->mutex );
+    mbedtls_mutex_init( &ctx->MBEDTLS_PRIVATE(mutex) );
 #endif
 }
 
 /*
  * Set padding for an existing RSA context
  */
-void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding,
-                              int hash_id )
+int mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding,
+                              mbedtls_md_type_t hash_id )
 {
     RSA_VALIDATE( ctx != NULL );
     RSA_VALIDATE( padding == MBEDTLS_RSA_PKCS_V15 ||
                   padding == MBEDTLS_RSA_PKCS_V21 );
 
-    ctx->padding = padding;
-    ctx->hash_id = hash_id;
+    ctx->MBEDTLS_PRIVATE(padding) = padding;
+    ctx->MBEDTLS_PRIVATE(hash_id) = hash_id;
+
+    return ( 0 );
 }
 
 /*
@@ -903,7 +900,7 @@ void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding,
 
 size_t mbedtls_rsa_get_len( const mbedtls_rsa_context *ctx )
 {
-    return( ctx->len );
+    return( ctx->MBEDTLS_PRIVATE(len) );
 }
 
 
@@ -947,41 +944,41 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
      * 2.  GCD( E, (P-1)*(Q-1) ) == 1
      * 3.  E^-1 mod LCM(P-1, Q-1) > 2^( nbits / 2 )
      */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &ctx->E, exponent ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &ctx->MBEDTLS_PRIVATE(E), exponent ) );
 
     do
     {
-        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, nbits >> 1,
+        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->MBEDTLS_PRIVATE(P), nbits >> 1,
                                                 prime_quality, f_rng, p_rng ) );
 
-        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, nbits >> 1,
+        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->MBEDTLS_PRIVATE(Q), nbits >> 1,
                                                 prime_quality, f_rng, p_rng ) );
 
         /* make sure the difference between p and q is not too small (FIPS 186-4 B.3.3 step 5.4) */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &H, &ctx->P, &ctx->Q ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &H, &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) ) );
         if( mbedtls_mpi_bitlen( &H ) <= ( ( nbits >= 200 ) ? ( ( nbits >> 1 ) - 99 ) : 0 ) )
             continue;
 
         /* not required by any standards, but some users rely on the fact that P > Q */
-        if( H.s < 0 )
-            mbedtls_mpi_swap( &ctx->P, &ctx->Q );
+        if( H.MBEDTLS_PRIVATE(s) < 0 )
+            mbedtls_mpi_swap( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) );
 
         /* Temporarily replace P,Q by P-1, Q-1 */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->P, &ctx->P, 1 ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->Q, &ctx->Q, 1 ) );
-        MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &H, &ctx->P, &ctx->Q ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(P), 1 ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(Q), 1 ) );
+        MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &H, &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) ) );
 
         /* check GCD( E, (P-1)*(Q-1) ) == 1 (FIPS 186-4 B.3.1 criterion 2(a)) */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->E, &H  ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->MBEDTLS_PRIVATE(E), &H  ) );
         if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
             continue;
 
         /* compute smallest possible D = E^-1 mod LCM(P-1, Q-1) (FIPS 186-4 B.3.1 criterion 3(b)) */
-        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->P, &ctx->Q ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) ) );
         MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &L, NULL, &H, &G ) );
-        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->D, &ctx->E, &L ) );
+        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->MBEDTLS_PRIVATE(D), &ctx->MBEDTLS_PRIVATE(E), &L ) );
 
-        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 B.3.1 criterion 3(a))
+        if( mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(D) ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 B.3.1 criterion 3(a))
             continue;
 
         break;
@@ -989,12 +986,12 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
     while( 1 );
 
     /* Restore P,Q */
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->P,  &ctx->P, 1 ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->Q,  &ctx->Q, 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->MBEDTLS_PRIVATE(P),  &ctx->MBEDTLS_PRIVATE(P), 1 ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->MBEDTLS_PRIVATE(Q),  &ctx->MBEDTLS_PRIVATE(Q), 1 ) );
 
-    MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &ctx->N, &ctx->P, &ctx->Q ) );
+    MBEDTLS_MPI_CHK( rsa_mpi2pka_mul( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q) ) );
 
-    ctx->len = mbedtls_mpi_size( &ctx->N );
+    ctx->MBEDTLS_PRIVATE(len) = mbedtls_mpi_size( &ctx->MBEDTLS_PRIVATE(N) );
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
     /*
@@ -1002,8 +999,8 @@ int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
      * DQ = D mod (Q - 1)
      * QP = Q^-1 mod P
      */
-    MBEDTLS_MPI_CHK( mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
-                                             &ctx->DP, &ctx->DQ, &ctx->QP ) );
+    MBEDTLS_MPI_CHK( mbedtls_rsa_deduce_crt( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(D),
+                                             &ctx->MBEDTLS_PRIVATE(DP), &ctx->MBEDTLS_PRIVATE(DQ), &ctx->MBEDTLS_PRIVATE(QP) ) );
 #endif /* MBEDTLS_RSA_NO_CRT */
 
     /* Double-check */
@@ -1036,14 +1033,14 @@ int mbedtls_rsa_check_pubkey( const mbedtls_rsa_context *ctx )
     if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 
-    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
+    if( mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) < 128 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
-    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
-        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
-        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
+    if( mbedtls_mpi_get_bit( &ctx->MBEDTLS_PRIVATE(E), 0 ) == 0 ||
+        mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(E) )     < 2  ||
+        mbedtls_mpi_cmp_mpi( &ctx->MBEDTLS_PRIVATE(E), &ctx->MBEDTLS_PRIVATE(N) ) >= 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
@@ -1064,15 +1061,15 @@ int mbedtls_rsa_check_privkey( const mbedtls_rsa_context *ctx )
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
-    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
-                                     &ctx->D, &ctx->E, NULL, NULL ) != 0 )
+    if( mbedtls_rsa_validate_params( &ctx->MBEDTLS_PRIVATE(N), &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q),
+                                     &ctx->MBEDTLS_PRIVATE(D), &ctx->MBEDTLS_PRIVATE(E), NULL, NULL ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
-    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
-                                       &ctx->DP, &ctx->DQ, &ctx->QP ) != 0 )
+    else if( mbedtls_rsa_validate_crt( &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(D),
+                                       &ctx->MBEDTLS_PRIVATE(DP), &ctx->MBEDTLS_PRIVATE(DQ), &ctx->MBEDTLS_PRIVATE(QP) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
@@ -1096,8 +1093,8 @@ int mbedtls_rsa_check_pub_priv( const mbedtls_rsa_context *pub,
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
 
-    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
-        mbedtls_mpi_cmp_mpi( &pub->E, &prv->E ) != 0 )
+    if( mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(N), &prv->MBEDTLS_PRIVATE(N) ) != 0 ||
+        mbedtls_mpi_cmp_mpi( &pub->MBEDTLS_PRIVATE(E), &prv->MBEDTLS_PRIVATE(E) ) != 0 )
     {
         return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
     }
@@ -1125,13 +1122,13 @@ int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
     mbedtls_mpi_init( &T );
 
 #if defined(MBEDTLS_THREADING_C)
-    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
+    if( ( ret = mbedtls_mutex_lock( &ctx->MBEDTLS_PRIVATE(mutex) ) ) != 0 )
         return( ret );
 #endif
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->MBEDTLS_PRIVATE(len) ) );
 
-    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
+    if( mbedtls_mpi_cmp_mpi( &T, &ctx->MBEDTLS_PRIVATE(N) ) >= 0 )
     {
         ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
         goto cleanup;
@@ -1144,7 +1141,7 @@ int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
 cleanup:
 
 #if defined(MBEDTLS_THREADING_C)
-    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
+    if( mbedtls_mutex_unlock( &ctx->MBEDTLS_PRIVATE(mutex) ) != 0 )
         return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
 #endif
 
@@ -1194,8 +1191,8 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
 #if !defined(MBEDTLS_RSA_NO_CRT)
     /* Pointers to actual exponents to be used - either the unblinded
      * or the blinded ones, depending on the presence of a PRNG. */
-    mbedtls_mpi *DP = &ctx->DP;
-    mbedtls_mpi *DQ = &ctx->DQ;
+    mbedtls_mpi *DP = &ctx->MBEDTLS_PRIVATE(DP);
+    mbedtls_mpi *DQ = &ctx->MBEDTLS_PRIVATE(DQ);
 #endif /* MBEDTLS_RSA_NO_CRT */
 
     /* Temporaries holding the initial input and the double
@@ -1213,7 +1210,7 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
     }
 
 #if defined(MBEDTLS_THREADING_C)
-    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
+    if( ( ret = mbedtls_mutex_lock( &ctx->MBEDTLS_PRIVATE(mutex) ) ) != 0 )
         return( ret );
 #endif
 
@@ -1224,8 +1221,8 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
 
     /* End of MPI initialization */
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
-    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
+    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->MBEDTLS_PRIVATE(len) ) );
+    if( mbedtls_mpi_cmp_mpi( &T, &ctx->MBEDTLS_PRIVATE(N) ) >= 0 )
     {
         ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
         goto cleanup;
@@ -1240,12 +1237,12 @@ int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
     /*
      * Faster decryption using the CRT
      */
-    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
+    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->MBEDTLS_PRIVATE(P), &ctx->MBEDTLS_PRIVATE(Q), &ctx->MBEDTLS_PRIVATE(QP), input, ctx->MBEDTLS_PRIVATE(len), output) );
 #endif /* MBEDTLS_RSA_NO_CRT */
 
 cleanup:
 #if defined(MBEDTLS_THREADING_C)
-    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
+    if( mbedtls_mutex_unlock( &ctx->MBEDTLS_PRIVATE(mutex) ) != 0 )
         return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
 #endif
 
@@ -1282,7 +1279,7 @@ static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
     memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
     memset( counter, 0, 4 );
 
-    hlen = mbedtls_md_get_size( md_ctx->md_info );
+    hlen = mbedtls_md_get_size( md_ctx->MBEDTLS_PRIVATE(md_info) );
 
     /* Generate and apply dbMask */
     p = dst;
@@ -1324,7 +1321,6 @@ exit:
 int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng,
-                            int mode,
                             const unsigned char *label, size_t label_len,
                             size_t ilen,
                             const unsigned char *input,
@@ -1344,17 +1340,14 @@ int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
     RSA_VALIDATE_RET( ilen == 0 || input != NULL );
     RSA_VALIDATE_RET( label_len == 0 || label != NULL );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
     if( f_rng == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
+    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id) );
     if( md_info == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    olen = ctx->len;
+    olen = ctx->MBEDTLS_PRIVATE(len);
     hlen = mbedtls_md_get_size( md_info );
 
     /* first comparison checks for overflow */
@@ -1400,9 +1393,7 @@ exit:
     if( ret != 0 )
         return( ret );
 
-    return( ( mode == MBEDTLS_RSA_PUBLIC )
-            ? mbedtls_rsa_public(  ctx, output, output )
-            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
+    return( mbedtls_rsa_public(  ctx, output, output ) );
 }
 #endif /* MBEDTLS_PKCS1_V21 */
 
@@ -1413,7 +1404,7 @@ exit:
 int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
                                  int (*f_rng)(void *, unsigned char *, size_t),
                                  void *p_rng,
-                                 int mode, size_t ilen,
+                                 size_t ilen,
                                  const unsigned char *input,
                                  unsigned char *output )
 {
@@ -1427,10 +1418,7 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
     RSA_VALIDATE_RET( output != NULL );
     RSA_VALIDATE_RET( ilen == 0 || input != NULL );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-    olen = ctx->len;
+    olen = ctx->MBEDTLS_PRIVATE(len);
 
     /* first comparison checks for overflow */
     if( ilen + 11 < ilen || olen < ilen + 11 )
@@ -1438,44 +1426,31 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
 
     nb_pad = olen - 3 - ilen;
 
-    *p++ = 0;
-    if( mode == MBEDTLS_RSA_PUBLIC )
-    {
-        if( f_rng == NULL )
-            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    if( f_rng == NULL )
+        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-        *p++ = MBEDTLS_RSA_CRYPT;
+    *p++ = MBEDTLS_RSA_CRYPT;
 
-        while( nb_pad-- > 0 )
-        {
-            int rng_dl = 100;
+    while( nb_pad-- > 0 )
+    {
+        int rng_dl = 100;
 
-            do {
-                ret = f_rng( p_rng, p, 1 );
-            } while( *p == 0 && --rng_dl && ret == 0 );
+        do {
+            ret = f_rng( p_rng, p, 1 );
+        } while( *p == 0 && --rng_dl && ret == 0 );
 
-            /* Check if RNG failed to generate data */
-            if( rng_dl == 0 || ret != 0 )
-                return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
+        /* Check if RNG failed to generate data */
+        if( rng_dl == 0 || ret != 0 )
+            return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 
-            p++;
-        }
-    }
-    else
-    {
-        *p++ = MBEDTLS_RSA_SIGN;
-
-        while( nb_pad-- > 0 )
-            *p++ = 0xFF;
+        p++;
     }
 
     *p++ = 0;
     if( ilen != 0 )
         memcpy( p, input, ilen );
 
-    return( ( mode == MBEDTLS_RSA_PUBLIC )
-            ? mbedtls_rsa_public(  ctx, output, output )
-            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
+    return( mbedtls_rsa_public(  ctx, output, output ) );
 }
 #endif /* MBEDTLS_PKCS1_V15 */
 
@@ -1485,27 +1460,25 @@ int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
 int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
                        int (*f_rng)(void *, unsigned char *, size_t),
                        void *p_rng,
-                       int mode, size_t ilen,
+                       size_t ilen,
                        const unsigned char *input,
                        unsigned char *output )
 {
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( output != NULL );
     RSA_VALIDATE_RET( ilen == 0 || input != NULL );
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
+            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, ilen,
                                                 input, output );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
+            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, NULL, 0,
                                            ilen, input, output );
 #endif
 
@@ -1521,7 +1494,6 @@ int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
 int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng,
-                            int mode,
                             const unsigned char *label, size_t label_len,
                             size_t *olen,
                             const unsigned char *input,
@@ -1538,8 +1510,6 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     mbedtls_md_context_t md_ctx;
 
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( output_max_len == 0 || output != NULL );
     RSA_VALIDATE_RET( label_len == 0 || label != NULL );
     RSA_VALIDATE_RET( input != NULL );
@@ -1548,15 +1518,12 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     /*
      * Parameters sanity checks
      */
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-    ilen = ctx->len;
+    ilen = ctx->MBEDTLS_PRIVATE(len);
 
     if( ilen < 16 || ilen > sizeof( buf ) )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
+    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id) );
     if( md_info == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
@@ -1569,9 +1536,7 @@ int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
     /*
      * RSA operation
      */
-    ret = ( mode == MBEDTLS_RSA_PUBLIC )
-          ? mbedtls_rsa_public(  ctx, input, buf )
-          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
+    ret = mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 
     if( ret != 0 )
         goto cleanup;
@@ -1759,7 +1724,7 @@ static void mem_move_to_left( void *start,
 int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
                                  int (*f_rng)(void *, unsigned char *, size_t),
                                  void *p_rng,
-                                 int mode, size_t *olen,
+                                 size_t *olen,
                                  const unsigned char *input,
                                  unsigned char *output,
                                  size_t output_max_len )
@@ -1784,26 +1749,19 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
     unsigned output_too_large;
 
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( output_max_len == 0 || output != NULL );
     RSA_VALIDATE_RET( input != NULL );
     RSA_VALIDATE_RET( olen != NULL );
 
-    ilen = ctx->len;
+    ilen = ctx->MBEDTLS_PRIVATE(len);
     plaintext_max_size = ( output_max_len > ilen - 11 ?
                            ilen - 11 :
                            output_max_len );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
     if( ilen < 16 || ilen > sizeof( buf ) )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    ret = ( mode == MBEDTLS_RSA_PUBLIC )
-          ? mbedtls_rsa_public(  ctx, input, buf )
-          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
+    ret = mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 
     if( ret != 0 )
         goto cleanup;
@@ -1812,35 +1770,16 @@ int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
      * memory trace. The first byte must be 0. */
     bad |= buf[0];
 
-    if( mode == MBEDTLS_RSA_PRIVATE )
-    {
-        /* Decode EME-PKCS1-v1_5 padding: 0x00 || 0x02 || PS || 0x00
-         * where PS must be at least 8 nonzero bytes. */
-        bad |= buf[1] ^ MBEDTLS_RSA_CRYPT;
+    /* Decode EME-PKCS1-v1_5 padding: 0x00 || 0x02 || PS || 0x00
+     * where PS must be at least 8 nonzero bytes. */
+    bad |= buf[1] ^ MBEDTLS_RSA_CRYPT;
 
-        /* Read the whole buffer. Set pad_done to nonzero if we find
-         * the 0x00 byte and remember the padding length in pad_count. */
-        for( i = 2; i < ilen; i++ )
-        {
-            pad_done  |= ((buf[i] | (unsigned char)-buf[i]) >> 7) ^ 1;
-            pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
-        }
-    }
-    else
+    /* Read the whole buffer. Set pad_done to nonzero if we find
+     * the 0x00 byte and remember the padding length in pad_count. */
+    for( i = 2; i < ilen; i++ )
     {
-        /* Decode EMSA-PKCS1-v1_5 padding: 0x00 || 0x01 || PS || 0x00
-         * where PS must be at least 8 bytes with the value 0xFF. */
-        bad |= buf[1] ^ MBEDTLS_RSA_SIGN;
-
-        /* Read the whole buffer. Set pad_done to nonzero if we find
-         * the 0x00 byte and remember the padding length in pad_count.
-         * If there's a non-0xff byte in the padding, the padding is bad. */
-        for( i = 2; i < ilen; i++ )
-        {
-            pad_done |= if_int( buf[i], 0, 1 );
-            pad_count += if_int( pad_done, 0, 1 );
-            bad |= if_int( pad_done, 0, buf[i] ^ 0xFF );
-        }
+        pad_done  |= ((buf[i] | (unsigned char)-buf[i]) >> 7) ^ 1;
+        pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
     }
 
     /* If pad_done is still zero, there's no data, only unfinished padding. */
@@ -1931,29 +1870,27 @@ cleanup:
 int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
                        int (*f_rng)(void *, unsigned char *, size_t),
                        void *p_rng,
-                       int mode, size_t *olen,
+                       size_t *olen,
                        const unsigned char *input,
                        unsigned char *output,
-                       size_t output_max_len)
+                       size_t output_max_len )
 {
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( output_max_len == 0 || output != NULL );
     RSA_VALIDATE_RET( input != NULL );
     RSA_VALIDATE_RET( olen != NULL );
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
+            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, olen,
                                                 input, output, output_max_len );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
+            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, NULL, 0,
                                            olen, input, output,
                                            output_max_len );
 #endif
@@ -1970,7 +1907,6 @@ int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
 int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
                          int (*f_rng)(void *, unsigned char *, size_t),
                          void *p_rng,
-                         int mode,
                          mbedtls_md_type_t md_alg,
                          unsigned int hashlen,
                          const unsigned char *hash,
@@ -1985,20 +1921,15 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
     const mbedtls_md_info_t *md_info;
     mbedtls_md_context_t md_ctx;
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
     RSA_VALIDATE_RET( sig != NULL );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
     if( f_rng == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    olen = ctx->len;
+    olen = ctx->MBEDTLS_PRIVATE(len);
 
     if( md_alg != MBEDTLS_MD_NONE )
     {
@@ -2010,7 +1941,7 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         hashlen = mbedtls_md_get_size( md_info );
     }
 
-    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
+    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id) );
     if( md_info == NULL )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
@@ -2037,7 +1968,7 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
         return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
 
     /* Note: EMSA-PSS encoding is over the length of N - 1 bits */
-    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
+    msb = mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) - 1;
     p += olen - hlen - slen - 2;
     *p++ = 0x01;
     memcpy( p, salt, slen );
@@ -2068,7 +1999,7 @@ int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
                           &md_ctx ) ) != 0 )
         goto exit;
 
-    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
+    msb = mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) - 1;
     sig[0] &= 0xFF >> ( olen * 8 - msb );
 
     p += hlen;
@@ -2082,9 +2013,7 @@ exit:
     if( ret != 0 )
         return( ret );
 
-    return( ( mode == MBEDTLS_RSA_PUBLIC )
-            ? mbedtls_rsa_public(  ctx, sig, sig )
-            : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
+    return( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
 }
 #endif /* MBEDTLS_PKCS1_V21 */
 
@@ -2229,7 +2158,6 @@ static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
 int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
                                int (*f_rng)(void *, unsigned char *, size_t),
                                void *p_rng,
-                               int mode,
                                mbedtls_md_type_t md_alg,
                                unsigned int hashlen,
                                const unsigned char *hash,
@@ -2239,45 +2167,34 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
     unsigned char *sig_try = NULL, *verif = NULL;
 
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
     RSA_VALIDATE_RET( sig != NULL );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
     /*
      * Prepare PKCS1-v1.5 encoding (padding and hash identifier)
      */
 
     if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,
-                                             ctx->len, sig ) ) != 0 )
+                                             ctx->MBEDTLS_PRIVATE(len), sig ) ) != 0 )
         return( ret );
 
     /*
      * Call respective RSA primitive
      */
 
-    if( mode == MBEDTLS_RSA_PUBLIC )
-    {
-        /* Skip verification on a public key operation */
-        return( mbedtls_rsa_public( ctx, sig, sig ) );
-    }
-
     /* Private key operation
      *
      * In order to prevent Lenstra's attack, make the signature in a
      * temporary buffer and check it before returning it.
      */
 
-    sig_try = mbedtls_calloc( 1, ctx->len );
+    sig_try = mbedtls_calloc( 1, ctx->MBEDTLS_PRIVATE(len) );
     if( sig_try == NULL )
         return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 
-    verif = mbedtls_calloc( 1, ctx->len );
+    verif = mbedtls_calloc( 1, ctx->MBEDTLS_PRIVATE(len) );
     if( verif == NULL )
     {
         mbedtls_free( sig_try );
@@ -2287,13 +2204,13 @@ int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
     MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
     MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );
 
-    if( mbedtls_safer_memcmp( verif, sig, ctx->len ) != 0 )
+    if( mbedtls_safer_memcmp( verif, sig, ctx->MBEDTLS_PRIVATE(len) ) != 0 )
     {
         ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;
         goto cleanup;
     }
 
-    memcpy( sig, sig_try, ctx->len );
+    memcpy( sig, sig_try, ctx->MBEDTLS_PRIVATE(len) );
 
 cleanup:
     mbedtls_free( sig_try );
@@ -2309,31 +2226,28 @@ cleanup:
 int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
                     int (*f_rng)(void *, unsigned char *, size_t),
                     void *p_rng,
-                    int mode,
                     mbedtls_md_type_t md_alg,
                     unsigned int hashlen,
                     const unsigned char *hash,
                     unsigned char *sig )
 {
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
     RSA_VALIDATE_RET( sig != NULL );
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, md_alg,
                                               hashlen, hash, sig );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, md_alg,
                                         hashlen, hash, sig );
 #endif
 
@@ -2347,9 +2261,6 @@ int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
  * Implementation of the PKCS#1 v2.1 RSASSA-PSS-VERIFY function
  */
 int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
-                               int (*f_rng)(void *, unsigned char *, size_t),
-                               void *p_rng,
-                               int mode,
                                mbedtls_md_type_t md_alg,
                                unsigned int hashlen,
                                const unsigned char *hash,
@@ -2370,24 +2281,17 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
 
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( sig != NULL );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
 
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
-
-    siglen = ctx->len;
+    siglen = ctx->MBEDTLS_PRIVATE(len);
 
     if( siglen < 16 || siglen > sizeof( buf ) )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 
-    ret = ( mode == MBEDTLS_RSA_PUBLIC )
-          ? mbedtls_rsa_public(  ctx, sig, buf )
-          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
+    ret = mbedtls_rsa_public(  ctx, sig, buf );
 
     if( ret != 0 )
         return( ret );
@@ -2418,7 +2322,7 @@ int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
     /*
      * Note: EMSA-PSS verification is over the length of N - 1 bits
      */
-    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
+    msb = mbedtls_mpi_bitlen( &ctx->MBEDTLS_PRIVATE(N) ) - 1;
 
     if( buf[0] >> ( 8 - siglen * 8 + msb ) )
         return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
@@ -2497,9 +2401,6 @@ exit:
  * Simplified PKCS#1 v2.1 RSASSA-PSS-VERIFY function
  */
 int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
-                           int (*f_rng)(void *, unsigned char *, size_t),
-                           void *p_rng,
-                           int mode,
                            mbedtls_md_type_t md_alg,
                            unsigned int hashlen,
                            const unsigned char *hash,
@@ -2507,19 +2408,16 @@ int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
 {
     mbedtls_md_type_t mgf1_hash_id;
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( sig != NULL );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
 
-    mgf1_hash_id = ( ctx->hash_id != MBEDTLS_MD_NONE )
-                             ? (mbedtls_md_type_t) ctx->hash_id
+    mgf1_hash_id = ( ctx->MBEDTLS_PRIVATE(hash_id) != MBEDTLS_MD_NONE )
+                             ? (mbedtls_md_type_t) ctx->MBEDTLS_PRIVATE(hash_id)
                              : md_alg;
 
-    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, f_rng, p_rng, mode,
-                                       md_alg, hashlen, hash,
+    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, md_alg, hashlen, hash,
                                        mgf1_hash_id, MBEDTLS_RSA_SALT_LEN_ANY,
                                        sig ) );
 
@@ -2531,9 +2429,6 @@ int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
  * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-v1_5-VERIFY function
  */
 int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
-                                 int (*f_rng)(void *, unsigned char *, size_t),
-                                 void *p_rng,
-                                 int mode,
                                  mbedtls_md_type_t md_alg,
                                  unsigned int hashlen,
                                  const unsigned char *hash,
@@ -2544,17 +2439,12 @@ int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
     unsigned char *encoded = NULL, *encoded_expected = NULL;
 
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( sig != NULL );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
 
-    sig_len = ctx->len;
-
-    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
-        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
+    sig_len = ctx->MBEDTLS_PRIVATE(len);
 
     /*
      * Prepare expected PKCS1 v1.5 encoding of hash.
@@ -2575,9 +2465,7 @@ int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
      * Apply RSA primitive to get what should be PKCS1 encoded hash.
      */
 
-    ret = ( mode == MBEDTLS_RSA_PUBLIC )
-          ? mbedtls_rsa_public(  ctx, sig, encoded )
-          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
+    ret = mbedtls_rsa_public( ctx, sig, encoded );
     if( ret != 0 )
         goto cleanup;
 
@@ -2614,33 +2502,28 @@ cleanup:
  * Do an RSA operation and check the message digest
  */
 int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx,
-                      int (*f_rng)(void *, unsigned char *, size_t),
-                      void *p_rng,
-                      int mode,
                       mbedtls_md_type_t md_alg,
                       unsigned int hashlen,
                       const unsigned char *hash,
                       const unsigned char *sig )
 {
     RSA_VALIDATE_RET( ctx != NULL );
-    RSA_VALIDATE_RET( mode == MBEDTLS_RSA_PRIVATE ||
-                      mode == MBEDTLS_RSA_PUBLIC );
     RSA_VALIDATE_RET( sig != NULL );
     RSA_VALIDATE_RET( ( md_alg  == MBEDTLS_MD_NONE &&
                         hashlen == 0 ) ||
                       hash != NULL );
 
-    switch( ctx->padding )
+    switch( ctx->MBEDTLS_PRIVATE(padding) )
     {
 #if defined(MBEDTLS_PKCS1_V15)
         case MBEDTLS_RSA_PKCS_V15:
-            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, md_alg,
                                                 hashlen, hash, sig );
 #endif
 
 #if defined(MBEDTLS_PKCS1_V21)
         case MBEDTLS_RSA_PKCS_V21:
-            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
+            return mbedtls_rsa_rsassa_pss_verify( ctx, md_alg,
                                           hashlen, hash, sig );
 #endif
 
@@ -2658,31 +2541,31 @@ int mbedtls_rsa_copy( mbedtls_rsa_context *dst, const mbedtls_rsa_context *src )
     RSA_VALIDATE_RET( dst != NULL );
     RSA_VALIDATE_RET( src != NULL );
 
-    dst->ver = src->ver;
-    dst->len = src->len;
+    dst->MBEDTLS_PRIVATE(ver) = src->MBEDTLS_PRIVATE(ver);
+    dst->MBEDTLS_PRIVATE(len) = src->MBEDTLS_PRIVATE(len);
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->N, &src->N ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->E, &src->E ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(N), &src->MBEDTLS_PRIVATE(N) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(E), &src->MBEDTLS_PRIVATE(E) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->D, &src->D ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->P, &src->P ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Q, &src->Q ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(D), &src->MBEDTLS_PRIVATE(D) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(P), &src->MBEDTLS_PRIVATE(P) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Q), &src->MBEDTLS_PRIVATE(Q) ) );
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DP, &src->DP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DQ, &src->DQ ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->QP, &src->QP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RP, &src->RP ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RQ, &src->RQ ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(DP), &src->MBEDTLS_PRIVATE(DP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(DQ), &src->MBEDTLS_PRIVATE(DQ) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(QP), &src->MBEDTLS_PRIVATE(QP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RP), &src->MBEDTLS_PRIVATE(RP) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RQ), &src->MBEDTLS_PRIVATE(RQ) ) );
 #endif
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RN, &src->RN ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(RN), &src->MBEDTLS_PRIVATE(RN) ) );
 
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vi, &src->Vi ) );
-    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vf, &src->Vf ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Vi), &src->MBEDTLS_PRIVATE(Vi) ) );
+    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->MBEDTLS_PRIVATE(Vf), &src->MBEDTLS_PRIVATE(Vf) ) );
 
-    dst->padding = src->padding;
-    dst->hash_id = src->hash_id;
+    dst->MBEDTLS_PRIVATE(padding) = src->MBEDTLS_PRIVATE(padding);
+    dst->MBEDTLS_PRIVATE(hash_id) = src->MBEDTLS_PRIVATE(hash_id);
 
 cleanup:
     if( ret != 0 )
@@ -2699,25 +2582,25 @@ void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
     if( ctx == NULL )
         return;
 
-    mbedtls_mpi_free( &ctx->Vi );
-    mbedtls_mpi_free( &ctx->Vf );
-    mbedtls_mpi_free( &ctx->RN );
-    mbedtls_mpi_free( &ctx->D  );
-    mbedtls_mpi_free( &ctx->Q  );
-    mbedtls_mpi_free( &ctx->P  );
-    mbedtls_mpi_free( &ctx->E  );
-    mbedtls_mpi_free( &ctx->N  );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Vi) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Vf) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RN) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(D)  );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(Q)  );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(P)  );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(E)  );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(N)  );
 
 #if !defined(MBEDTLS_RSA_NO_CRT)
-    mbedtls_mpi_free( &ctx->RQ );
-    mbedtls_mpi_free( &ctx->RP );
-    mbedtls_mpi_free( &ctx->QP );
-    mbedtls_mpi_free( &ctx->DQ );
-    mbedtls_mpi_free( &ctx->DP );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RQ) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(RP) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(QP) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(DQ) );
+    mbedtls_mpi_free( &ctx->MBEDTLS_PRIVATE(DP) );
 #endif /* MBEDTLS_RSA_NO_CRT */
 
 #if defined(MBEDTLS_THREADING_C)
-    mbedtls_mutex_free( &ctx->mutex );
+    mbedtls_mutex_free( &ctx->MBEDTLS_PRIVATE(mutex) );
 #endif
 }
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/main.c b/lib/tf-m/secure_fw/spm/cmsis_func/main.c
index 047207eaa90a75d5f5d2968435321994f6a8f8d7..db9bea43c45ab7e555d10f71962d0928e6ab6db2 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/main.c
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/main.c
@@ -113,8 +113,7 @@ static fih_int tfm_core_init(void)
 
     for (i = 0; i < tfm_core_irq_signals_count; ++i) {
         plat_err = tfm_spm_hal_set_secure_irq_priority(
-                                          tfm_core_irq_signals[i].irq_line,
-                                          tfm_core_irq_signals[i].irq_priority);
+                                          tfm_core_irq_signals[i].irq_line);
         if (plat_err != TFM_PLAT_ERR_SUCCESS) {
             FIH_RET(fih_int_encode(TFM_ERROR_GENERIC));
         }
@@ -205,6 +204,11 @@ int main(void)
     /* Jumps to non-secure code */
     SPMLOG_DBGMSG("\033[1;34mJumping to non-secure code...\033[0m\r\n");
 #endif
+    
+    /* enable reset from non secure code */
+    struct sse300_sysctrl_t *p = (struct sse300_sysctrl_t*)SSE300_SYSCTRL_BASE_S;
+    p->reset_mask = 0xFFFFFFFF;
+    SCB->AIRCR = 0x05FA4000;
 
     jump_to_ns_code();
 }
diff --git a/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c b/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
index e1db197cfeeac06d7cac0f363a43fe97480d4fd2..0d95ac6988e34609c246aa419082e723ceb3bbce 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/crypto_key.c
@@ -15,7 +15,7 @@
 #include "tfm_crypto_private.h"
 
 #ifndef TFM_CRYPTO_KEY_MODULE_DISABLED
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
 #ifndef TFM_CRYPTO_MAX_KEY_HANDLES
 #define TFM_CRYPTO_MAX_KEY_HANDLES (32)
 #endif
@@ -44,7 +44,7 @@ static void clean_handle_owner(uint8_t idx)
     /* Skip checking idx */
 
     handle_owner[idx].owner = TFM_INVALID_CLIENT_ID;
-    handle_owner[idx].key = NULL;
+    handle_owner[idx].key = (psa_key_id_t)0;
     handle_owner[idx].in_use = TFM_CRYPTO_NOT_IN_USE;
 }
 
@@ -104,7 +104,7 @@ static void encoded_key_id_make(psa_key_id_t key, uint8_t slot_idx,
     /* Skip checking encoded_key */
     *encoded_key = mbedtls_svc_key_id_make(handle_owner[slot_idx].owner, key);
 }
-#else /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER */
+#else /* CRYPTO_KEY_ID_ENCODES_OWNER */
 #define set_handle_owner(idx, client_id, key_handle)        do {} while (0)
 #define clean_handle_owner(idx)                             do {} while (0)
 
@@ -134,7 +134,7 @@ static inline void encoded_key_id_make(psa_key_id_t key, uint8_t slot_idx,
     /* Skip checking encoded_key */
     *encoded_key = mbedtls_svc_key_id_make(TFM_INVALID_CLIENT_ID, key);
 }
-#endif /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER */
+#endif /* CRYPTO_KEY_ID_ENCODES_OWNER */
 #endif /* !TFM_CRYPTO_KEY_MODULE_DISABLED */
 
 /*!
@@ -147,25 +147,30 @@ psa_status_t tfm_crypto_key_attributes_from_client(
                     int32_t client_id,
                     psa_key_attributes_t *key_attributes)
 {
+    psa_core_key_attributes_t *core;
+
     if (client_key_attr == NULL || key_attributes == NULL) {
         return PSA_ERROR_PROGRAMMER_ERROR;
     }
 
     *key_attributes = psa_key_attributes_init();
+    core = &(key_attributes->MBEDTLS_PRIVATE(core));
 
     /* Copy core key attributes from the client core key attributes */
-    key_attributes->core.type = client_key_attr->type;
-    key_attributes->core.lifetime = client_key_attr->lifetime;
-    key_attributes->core.policy.usage = client_key_attr->usage;
-    key_attributes->core.policy.alg = client_key_attr->alg;
-    key_attributes->core.bits = client_key_attr->bits;
+    core->MBEDTLS_PRIVATE(type) = client_key_attr->type;
+    core->MBEDTLS_PRIVATE(lifetime) = client_key_attr->lifetime;
+    core->MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(usage) =
+                                                     client_key_attr->usage;
+    core->MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(alg) =
+                                                     client_key_attr->alg;
+    core->MBEDTLS_PRIVATE(bits) = client_key_attr->bits;
 
     /* Use the client key id as the key_id and its partition id as the owner */
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    key_attributes->core.id.key_id = client_key_attr->id;
-    key_attributes->core.id.owner = client_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    core->MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(key_id) = client_key_attr->id;
+    core->MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(owner) = client_id;
 #else
-    key_attributes->core.id = client_key_attr->id;
+    core->MBEDTLS_PRIVATE(id) = client_key_attr->id;
 #endif
 
     return PSA_SUCCESS;
@@ -181,19 +186,20 @@ psa_status_t tfm_crypto_key_attributes_to_client(
 
     struct psa_client_key_attributes_s v = PSA_CLIENT_KEY_ATTRIBUTES_INIT;
     *client_key_attr = v;
+    psa_core_key_attributes_t core = key_attributes->MBEDTLS_PRIVATE(core);
 
     /* Copy core key attributes from the client core key attributes */
-    client_key_attr->type = key_attributes->core.type;
-    client_key_attr->lifetime = key_attributes->core.lifetime;
-    client_key_attr->usage = key_attributes->core.policy.usage;
-    client_key_attr->alg = key_attributes->core.policy.alg;
-    client_key_attr->bits = key_attributes->core.bits;
+    client_key_attr->type = core.MBEDTLS_PRIVATE(type);
+    client_key_attr->lifetime = core.MBEDTLS_PRIVATE(lifetime);
+    client_key_attr->usage = core.MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(usage);
+    client_key_attr->alg = core.MBEDTLS_PRIVATE(policy).MBEDTLS_PRIVATE(alg);
+    client_key_attr->bits = core.MBEDTLS_PRIVATE(bits);
 
     /* Return the key_id as the client key id, do not return the owner */
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    client_key_attr->id = key_attributes->core.id.key_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    client_key_attr->id = core.MBEDTLS_PRIVATE(id).MBEDTLS_PRIVATE(key_id);
 #else
-    client_key_attr->id = key_attributes->core.id;
+    client_key_attr->id = core.MBEDTLS_PRIVATE(id);
 #endif
 
     return PSA_SUCCESS;
@@ -330,8 +336,8 @@ psa_status_t tfm_crypto_import_key(psa_invec in_vec[],
 
     status = psa_import_key(&key_attributes, data, data_length, &encoded_key);
     /* Update the imported key id */
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    *psa_key = encoded_key.key_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    *psa_key = encoded_key.MBEDTLS_PRIVATE(key_id);
 #else
     *psa_key = (psa_key_id_t)encoded_key;
 #endif
@@ -382,8 +388,8 @@ psa_status_t tfm_crypto_open_key(psa_invec in_vec[],
     encoded_key = mbedtls_svc_key_id_make(partition_id, client_key_id);
 
     status = psa_open_key(encoded_key, &encoded_key);
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    *key = encoded_key.key_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    *key = encoded_key.MBEDTLS_PRIVATE(key_id);
 #else
     *key = (psa_key_id_t)encoded_key;
 #endif
@@ -681,12 +687,12 @@ psa_status_t tfm_crypto_copy_key(psa_invec in_vec[],
     const struct psa_client_key_attributes_s *client_key_attr = in_vec[1].base;
     psa_status_t status;
     psa_key_attributes_t key_attributes = PSA_KEY_ATTRIBUTES_INIT;
-    uint8_t i = 0;
+    uint8_t source_idx = 0, target_idx = 0;
     int32_t partition_id = 0;
     mbedtls_svc_key_id_t target_key;
     mbedtls_svc_key_id_t encoded_key;
 
-    status = find_empty_handle_owner_slot(&i);
+    status = find_empty_handle_owner_slot(&target_idx);
     if (status != PSA_SUCCESS) {
         return status;
     }
@@ -703,21 +709,21 @@ psa_status_t tfm_crypto_copy_key(psa_invec in_vec[],
         return status;
     }
 
-    status = check_handle_owner(source_key_id, NULL);
+    status = check_handle_owner(source_key_id, &source_idx);
     if (status != PSA_SUCCESS) {
         return status;
     }
 
-    encoded_key_id_make(source_key_id, i, &encoded_key);
+    encoded_key_id_make(source_key_id, source_idx, &encoded_key);
 
     status = psa_copy_key(encoded_key, &key_attributes, &target_key);
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    *target_key_id = target_key.key_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    *target_key_id = target_key.MBEDTLS_PRIVATE(key_id);
 #else
     *target_key_id = (psa_key_id_t)target_key;
 #endif
     if (status == PSA_SUCCESS) {
-        set_handle_owner(i, partition_id, *target_key_id);
+        set_handle_owner(target_idx, partition_id, *target_key_id);
     }
 
     return status;
@@ -766,8 +772,8 @@ psa_status_t tfm_crypto_generate_key(psa_invec in_vec[],
     }
 
     status = psa_generate_key(&key_attributes, &encoded_key);
-#ifdef MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
-    *key_handle = encoded_key.key_id;
+#ifdef CRYPTO_KEY_ID_ENCODES_OWNER
+    *key_handle = encoded_key.MBEDTLS_PRIVATE(key_id);
 #else
     *key_handle = (psa_key_id_t)encoded_key;
 #endif
diff --git a/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c b/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c
new file mode 100644
index 0000000000000000000000000000000000000000..0f9dd6f91b28d62c44b84f577b6d76b8eafcf992
--- /dev/null
+++ b/lib/tf-m/secure_fw/partitions/idle_partition/load_info_idle_sp.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2021, Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+#include <stdint.h>
+#include <stddef.h>
+#include "spm_ipc.h"
+#include "spm_partition_defs.h"
+#include "load/partition_defs.h"
+#include "load/service_defs.h"
+#include "load/asset_defs.h"
+
+#define IDLE_SP_STACK_SIZE      (0x60)
+
+struct partition_tfm_sp_idle_load_info_t {
+    /* common length load data */
+    struct partition_load_info_t    load_info;
+    /* per-partition variable length load data */
+    uintptr_t                       stack_addr;
+    uintptr_t                       heap_addr;
+} __attribute__((aligned(4)));
+
+/* Entrypoint function declaration */
+extern void tfm_idle_thread(void);
+/* Stack */
+uint8_t idle_sp_stack[IDLE_SP_STACK_SIZE] __attribute__((aligned(8)));
+
+/* Partition load, deps, service load data. Put to a dedicated section. */
+const struct partition_tfm_sp_idle_load_info_t
+    tfm_sp_idle_load __attribute__((used, section(".part_load"))) = {
+    .load_info = {
+        .psa_ff_ver                 = 0x0101 | PARTITION_INFO_MAGIC,
+        .pid                        = TFM_SP_IDLE_ID,
+        .flags                      = PARTITION_PRI_LOWEST | SPM_PART_FLAG_IPC
+                                      | SPM_PART_FLAG_PSA_ROT,
+        .entry                      = ENTRY_TO_POSITION(tfm_idle_thread),
+        .stack_size                 = IDLE_SP_STACK_SIZE,
+        .heap_size                  = 0,
+        .ndeps                      = 0,
+        .nservices                  = 0,
+        .nassets                    = 0,
+    },
+    .stack_addr                     = (uintptr_t)idle_sp_stack,
+    .heap_addr                      = 0,
+};
+
+/* Placeholder for partition runtime space. Do not reference it. */
+static struct partition_t tfm_idle_partition_runtime_item
+    __attribute__((used, section(".bss.part_runtime")));
diff --git a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.h b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.h
index d2d9c61a5bbed88a6ab7f24ae692c74f2dbe43ce..e0f9b4e613536c84f6fd0512060c4d815bf35c4b 100644
--- a/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.h
+++ b/lib/tf-m/platform/ext/target/cypress/psoc64/target_cfg.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2018-2020 ARM Limited
- * Copyright (c) 2019, Cypress Semiconductor Corporation. All rights reserved.
+ * Copyright (c) 2019-2021, Cypress Semiconductor Corporation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,6 +24,36 @@
 #define TFM_DRIVER_STDIO    Driver_USART5
 #define NS_DRIVER_STDIO     Driver_USART5
 
+/* UART pins HSIOM routing */
+#define ioss_0_port_5_pin_0_HSIOM P5_0_SCB5_UART_RX
+#define ioss_0_port_5_pin_1_HSIOM P5_1_SCB5_UART_TX
+
+/* UART pins configuration */
+#define CYBSP_UART_RX_ENABLED 1U
+#define CYBSP_UART_RX_PORT GPIO_PRT5
+#define CYBSP_UART_RX_PORT_NUM 5U
+#define CYBSP_UART_RX_PIN 0U
+#define CYBSP_UART_RX_NUM 0U
+#define CYBSP_UART_RX_DRIVEMODE CY_GPIO_DM_HIGHZ
+#define CYBSP_UART_RX_INIT_DRIVESTATE 1
+#ifndef ioss_0_port_5_pin_0_HSIOM
+        #define ioss_0_port_5_pin_0_HSIOM HSIOM_SEL_GPIO
+#endif
+#define CYBSP_UART_RX_HSIOM ioss_0_port_5_pin_0_HSIOM
+#define CYBSP_UART_RX_IRQ ioss_interrupts_gpio_5_IRQn
+#define CYBSP_UART_TX_ENABLED 1U
+#define CYBSP_UART_TX_PORT GPIO_PRT5
+#define CYBSP_UART_TX_PORT_NUM 5U
+#define CYBSP_UART_TX_PIN 1U
+#define CYBSP_UART_TX_NUM 1U
+#define CYBSP_UART_TX_DRIVEMODE CY_GPIO_DM_STRONG_IN_OFF
+#define CYBSP_UART_TX_INIT_DRIVESTATE 1
+#ifndef ioss_0_port_5_pin_1_HSIOM
+        #define ioss_0_port_5_pin_1_HSIOM HSIOM_SEL_GPIO
+#endif
+#define CYBSP_UART_TX_HSIOM ioss_0_port_5_pin_1_HSIOM
+#define CYBSP_UART_TX_IRQ ioss_interrupts_gpio_5_IRQn
+
 /**
  * \brief Store the addresses of memory regions
  */
diff --git a/lib/tf-m/secure_fw/partitions/crypto/tfm_mbedcrypto_alt.c b/lib/tf-m/secure_fw/partitions/crypto/tfm_mbedcrypto_alt.c
index 9cf9277c784ece3f69cd3655f794e38d29053a7e..3275766e218268d1e377631470eb76eb09037632 100644
--- a/lib/tf-m/secure_fw/partitions/crypto/tfm_mbedcrypto_alt.c
+++ b/lib/tf-m/secure_fw/partitions/crypto/tfm_mbedcrypto_alt.c
@@ -18,6 +18,7 @@
 #include "tfm_mbedcrypto_include.h"
 #if defined(MBEDTLS_AES_DECRYPT_ALT) || defined(MBEDTLS_AES_SETKEY_DEC_ALT)
 #include "mbedtls/aes.h"
+#include "mbedtls/error.h"
 #endif
 
 #if defined(MBEDTLS_AES_DECRYPT_ALT) && defined(MBEDTLS_CCM_C)
@@ -35,7 +36,7 @@ int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,
     (void)input;
     (void)output;
 
-    return MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE;
+    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
 }
 #endif
 
@@ -53,6 +54,6 @@ int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key,
     (void)key;
     (void)keybits;
 
-    return MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE;
+    return MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED;
 }
 #endif
diff --git a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
index b9738e67f5d6b0d9c6e2848cf4cfe18abcde3742..d1e57bc0fe598dac8aa0129dd853d7a4681b8e9a 100644
--- a/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
+++ b/lib/tf-m/lib/ext/mbedcrypto/mbedcrypto_config/tfm_mbedcrypto_config_profile_large.h
@@ -491,23 +491,6 @@
 //#define MBEDTLS_ECP_RANDOMIZE_MXZ_ALT
 //#define MBEDTLS_ECP_NORMALIZE_MXZ_ALT
 
-/**
- * \def MBEDTLS_TEST_NULL_ENTROPY
- *
- * Enables testing and use of mbed TLS without any configured entropy sources.
- * This permits use of the library on platforms before an entropy source has
- * been integrated (see for example the MBEDTLS_ENTROPY_HARDWARE_ALT or the
- * MBEDTLS_ENTROPY_NV_SEED switches).
- *
- * WARNING! This switch MUST be disabled in production builds, and is suitable
- * only for development.
- * Enabling the switch negates any security provided by the library.
- *
- * Requires MBEDTLS_ENTROPY_C, MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
- *
- */
-#define MBEDTLS_TEST_NULL_ENTROPY
-
 /**
  * \def MBEDTLS_ENTROPY_HARDWARE_ALT
  *
@@ -793,7 +776,7 @@
  *
  * Uncomment this macro to prevent loading of default entropy functions.
  */
-#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
+//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 
 /**
  * \def MBEDTLS_NO_PLATFORM_ENTROPY
@@ -848,7 +831,7 @@
  * \note The entropy collector will write to the seed file before entropy is
  *       given to an external source, to update it.
  */
-//#define MBEDTLS_ENTROPY_NV_SEED
+#define MBEDTLS_ENTROPY_NV_SEED
 
 /* MBEDTLS_PSA_CRYPTO_KEY_ID_ENCODES_OWNER
  *
@@ -1778,6 +1761,22 @@
  */
 //#define MBEDTLS_SHA1_C
 
+/**
+ * \def MBEDTLS_SHA224_C
+ *
+ * Enable the SHA-224 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA256_C. The library does not currently support enabling
+ *           SHA-224 without SHA-256.
+ *
+ * Module:  library/sha256.c
+ * Caller:  library/md.c
+ *          library/ssl_cookie.c
+ *
+ * This module adds support for SHA-224.
+ */
+#define MBEDTLS_SHA224_C
+
 /**
  * \def MBEDTLS_SHA256_C
  *
@@ -1792,6 +1791,22 @@
  */
 #define MBEDTLS_SHA256_C
 
+/**
+ * \def MBEDTLS_SHA384_C
+ *
+ * Enable the SHA-384 cryptographic hash algorithm.
+ *
+ * Requires: MBEDTLS_SHA512_C
+ *
+ * Module:  library/sha512.c
+ * Caller:  library/md.c
+ *          library/ssl_cli.c
+ *          library/ssl_srv.c
+ *
+ * Comment to disable SHA-384
+ */
+#define MBEDTLS_SHA384_C
+
 /**
  * \def MBEDTLS_SHA512_C
  *
@@ -1993,6 +2008,8 @@
 
 #ifdef CRYPTO_HW_ACCELERATOR
 #include "mbedtls_accelerator_config.h"
+#else
+#include "mbedtls_entropy_nv_seed_config.h"
 #endif
 
 /* Target and application specific configurations
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
index 638d0cfdfc8e7a3be5d4e88b8a559ab1dc2b0934..42af56ee77af5f8ab993fca3240da946491b8efc 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/spm_hal.c
@@ -41,11 +41,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
index 1c06a33ded997efbeedaa569be38280360ae9219..ce4eed857465c5661733d45959984551ce1c8fc1 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_func/include/tfm_core_svc.h
@@ -15,6 +15,7 @@
 #define TFM_SVC_PSA_EOI                 (0x1)
 #define TFM_SVC_SFN_REQUEST             (0x2)
 #define TFM_SVC_SFN_RETURN              (0x3)
+#define TFM_SVC_SFN_COMPLETION          (0x4)
 #define TFM_SVC_SPM_REQUEST             (0x5)
 #define TFM_SVC_GET_BOOT_DATA           (0x6)
 #define TFM_SVC_DEPRIV_REQ              (0x7)
diff --git a/lib/tf-m/interface/include/psa/crypto_values.h b/lib/tf-m/interface/include/psa/crypto_values.h
index 25c6662c16eccebd7e7a4d1f3fff7e1e8adbb154..dc8d81a869cee987a9cd73bea08fe1e3767b2be8 100644
--- a/lib/tf-m/interface/include/psa/crypto_values.h
+++ b/lib/tf-m/interface/include/psa/crypto_values.h
@@ -400,12 +400,56 @@
 #define PSA_KEY_TYPE_HMAC                           ((psa_key_type_t)0x1100)
 
 /** A secret for key derivation.
+ *
+ * This key type is for high-entropy secrets only. For low-entropy secrets,
+ * #PSA_KEY_TYPE_PASSWORD should be used instead.
+ *
+ * These keys can be used as the #PSA_KEY_DERIVATION_INPUT_SECRET or
+ * #PSA_KEY_DERIVATION_INPUT_PASSWORD input of key derivation algorithms.
  *
  * The key policy determines which key derivation algorithm the key
  * can be used for.
  */
 #define PSA_KEY_TYPE_DERIVE                         ((psa_key_type_t)0x1200)
 
+/** A low-entropy secret for password hashing or key derivation.
+ *
+ * This key type is suitable for passwords and passphrases which are typically
+ * intended to be memorizable by humans, and have a low entropy relative to
+ * their size. It can be used for randomly generated or derived keys with
+ * maximum or near-maximum entropy, but #PSA_KEY_TYPE_DERIVE is more suitable
+ * for such keys. It is not suitable for passwords with extremely low entropy,
+ * such as numerical PINs.
+ *
+ * These keys can be used as the #PSA_KEY_DERIVATION_INPUT_PASSWORD input of
+ * key derivation algorithms. Algorithms that accept such an input were
+ * designed to accept low-entropy secret and are known as password hashing or
+ * key stretching algorithms.
+ *
+ * These keys cannot be used as the #PSA_KEY_DERIVATION_INPUT_SECRET input of
+ * key derivation algorithms, as the algorithms that take such an input expect
+ * it to be high-entropy.
+ *
+ * The key policy determines which key derivation algorithm the key can be
+ * used for, among the permissible subset defined above.
+ */
+#define PSA_KEY_TYPE_PASSWORD                       ((psa_key_type_t)0x1203)
+
+/** A secret value that can be used to verify a password hash.
+ *
+ * The key policy determines which key derivation algorithm the key
+ * can be used for, among the same permissible subset as for
+ * #PSA_KEY_TYPE_PASSWORD.
+ */
+#define PSA_KEY_TYPE_PASSWORD_HASH                  ((psa_key_type_t)0x1205)
+
+/** A secret value that can be used in when computing a password hash.
+ *
+ * The key policy determines which key derivation algorithm the key
+ * can be used for, among the subset of algorithms that can use pepper.
+ */
+#define PSA_KEY_TYPE_PEPPER                         ((psa_key_type_t)0x1206)
+
 /** Key for a cipher, AEAD or MAC algorithm based on the AES block cipher.
  *
  * The size of the key can be 16 bytes (AES-128), 24 bytes (AES-192) or
@@ -415,8 +459,8 @@
 
 /** Key for a cipher or MAC algorithm based on DES or 3DES (Triple-DES).
  *
- * The size of the key can be 8 bytes (single DES), 16 bytes (2-key 3DES) or
- * 24 bytes (3-key 3DES).
+ * The size of the key can be 64 bits (single DES), 128 bits (2-key 3DES) or
+ * 192 bits (3-key 3DES).
  *
  * Note that single DES and 2-key 3DES are weak and strongly
  * deprecated and should only be used to decrypt legacy data. 3-key 3DES
@@ -428,12 +472,6 @@
  * Camellia block cipher. */
 #define PSA_KEY_TYPE_CAMELLIA                       ((psa_key_type_t)0x2403)
 
-/** Key for the RC4 stream cipher.
- *
- * Note that RC4 is weak and deprecated and should only be used in
- * legacy protocols. */
-#define PSA_KEY_TYPE_ARC4                           ((psa_key_type_t)0x2002)
-
 /** Key for the ChaCha20 stream cipher or the Chacha20-Poly1305 AEAD algorithm.
  *
  * ChaCha20 and the ChaCha20_Poly1305 construction are defined in RFC 7539.
@@ -443,9 +481,15 @@
  */
 #define PSA_KEY_TYPE_CHACHA20                       ((psa_key_type_t)0x2004)
 
-/** RSA public key. */
+/** RSA public key.
+ *
+ * The size of an RSA key is the bit size of the modulus.
+ */
 #define PSA_KEY_TYPE_RSA_PUBLIC_KEY                 ((psa_key_type_t)0x4001)
-/** RSA key pair (private and public key). */
+/** RSA key pair (private and public key).
+ *
+ * The size of an RSA key is the bit size of the modulus.
+ */
 #define PSA_KEY_TYPE_RSA_KEY_PAIR                   ((psa_key_type_t)0x7001)
 /** Whether a key type is an RSA key (pair or public-only). */
 #define PSA_KEY_TYPE_IS_RSA(type)                                       \
@@ -455,6 +499,10 @@
 #define PSA_KEY_TYPE_ECC_KEY_PAIR_BASE              ((psa_key_type_t)0x7100)
 #define PSA_KEY_TYPE_ECC_CURVE_MASK                 ((psa_key_type_t)0x00ff)
 /** Elliptic curve key pair.
+ *
+ * The size of an elliptic curve key is the bit size associated with the curve,
+ * i.e. the bit size of *q* for a curve over a field *F<sub>q</sub>*.
+ * See the documentation of `PSA_ECC_FAMILY_xxx` curve families for details.
  *
  * \param curve     A value of type ::psa_ecc_family_t that
  *                  identifies the ECC curve to be used.
@@ -462,6 +510,10 @@
 #define PSA_KEY_TYPE_ECC_KEY_PAIR(curve)         \
     (PSA_KEY_TYPE_ECC_KEY_PAIR_BASE | (curve))
 /** Elliptic curve public key.
+ *
+ * The size of an elliptic curve public key is the same as the corresponding
+ * private key (see #PSA_KEY_TYPE_ECC_KEY_PAIR and the documentation of
+ * `PSA_ECC_FAMILY_xxx` curve families).
  *
  * \param curve     A value of type ::psa_ecc_family_t that
  *                  identifies the ECC curve to be used.
@@ -561,6 +613,22 @@
  */
 #define PSA_ECC_FAMILY_MONTGOMERY        ((psa_ecc_family_t) 0x41)
 
+/** The twisted Edwards curves Ed25519 and Ed448.
+ *
+ * These curves are suitable for EdDSA (#PSA_ALG_PURE_EDDSA for both curves,
+ * #PSA_ALG_ED25519PH for the 255-bit curve,
+ * #PSA_ALG_ED448PH for the 448-bit curve).
+ *
+ * This family comprises the following twisted Edwards curves:
+ * - 255-bit: Edwards25519, the twisted Edwards curve birationally equivalent
+ *   to Curve25519.
+ *   Bernstein et al., _Twisted Edwards curves_, Africacrypt 2008.
+ * - 448-bit: Edwards448, the twisted Edwards curve birationally equivalent
+ *   to Curve448.
+ *   Hamburg, _Ed448-Goldilocks, a new elliptic curve_, NIST ECC Workshop, 2015.
+ */
+#define PSA_ECC_FAMILY_TWISTED_EDWARDS   ((psa_ecc_family_t) 0x42)
+
 #define PSA_KEY_TYPE_DH_PUBLIC_KEY_BASE             ((psa_key_type_t)0x4200)
 #define PSA_KEY_TYPE_DH_KEY_PAIR_BASE               ((psa_key_type_t)0x7200)
 #define PSA_KEY_TYPE_DH_GROUP_MASK                  ((psa_key_type_t)0x00ff)
@@ -748,11 +816,25 @@
 #define PSA_ALG_IS_KEY_DERIVATION(alg)                                  \
     (((alg) & PSA_ALG_CATEGORY_MASK) == PSA_ALG_CATEGORY_KEY_DERIVATION)
 
+/** Whether the specified algorithm is a key stretching / password hashing
+ * algorithm.
+ *
+ * A key stretching / password hashing algorithm is a key derivation algorithm
+ * that is suitable for use with a low-entropy secret such as a password.
+ * Equivalently, it's a key derivation algorithm that uses a
+ * #PSA_KEY_DERIVATION_INPUT_PASSWORD input step.
+ *
+ * \param alg An algorithm identifier (value of type #psa_algorithm_t).
+ *
+ * \return 1 if \p alg is a key stretching / password hashing algorithm, 0
+ *         otherwise. This macro may return either 0 or 1 if \p alg is not a
+ *         supported algorithm identifier.
+ */
+#define PSA_ALG_IS_KEY_DERIVATION_STRETCHING(alg)                                  \
+    (PSA_ALG_IS_KEY_DERIVATION(alg) &&              \
+     (alg) & PSA_ALG_KEY_DERIVATION_STRETCHING_FLAG)
+
 #define PSA_ALG_HASH_MASK                       ((psa_algorithm_t)0x000000ff)
-/** MD2 */
-#define PSA_ALG_MD2                             ((psa_algorithm_t)0x02000001)
-/** MD4 */
-#define PSA_ALG_MD4                             ((psa_algorithm_t)0x02000002)
 /** MD5 */
 #define PSA_ALG_MD5                             ((psa_algorithm_t)0x02000003)
 /** PSA_ALG_RIPEMD160 */
@@ -779,6 +861,13 @@
 #define PSA_ALG_SHA3_384                        ((psa_algorithm_t)0x02000012)
 /** SHA3-512 */
 #define PSA_ALG_SHA3_512                        ((psa_algorithm_t)0x02000013)
+/** The first 512 bits (64 bytes) of the SHAKE256 output.
+ *
+ * This is the prehashing for Ed448ph (see #PSA_ALG_ED448PH). For other
+ * scenarios where a hash function based on SHA3/SHAKE is desired, SHA3-512
+ * has the same output size and a (theoretically) higher security strength.
+ */
+#define PSA_ALG_SHAKE256_512                    ((psa_algorithm_t)0x02000015)
 
 /** In a hash-and-sign algorithm policy, allow any hash algorithm.
  *
@@ -884,7 +973,7 @@
  *          for policy comparison purposes.
  *
  * \param mac_alg       A MAC algorithm identifier (value of type
- *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p alg)
+ *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p mac_alg)
  *                      is true). This may be a truncated or untruncated
  *                      MAC algorithm.
  * \param mac_length    Desired length of the truncated MAC in bytes.
@@ -895,7 +984,7 @@
  *
  * \return              The corresponding MAC algorithm with the specified
  *                      length.
- * \return              Unspecified if \p alg is not a supported
+ * \return              Unspecified if \p mac_alg is not a supported
  *                      MAC algorithm or if \p mac_length is too small or
  *                      too large for the specified MAC algorithm.
  */
@@ -908,12 +997,12 @@
  * MAC algorithm.
  *
  * \param mac_alg       A MAC algorithm identifier (value of type
- *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p alg)
+ *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p mac_alg)
  *                      is true). This may be a truncated or untruncated
  *                      MAC algorithm.
  *
  * \return              The corresponding base MAC algorithm.
- * \return              Unspecified if \p alg is not a supported
+ * \return              Unspecified if \p mac_alg is not a supported
  *                      MAC algorithm.
  */
 #define PSA_ALG_FULL_LENGTH_MAC(mac_alg)                        \
@@ -923,12 +1012,12 @@
 /** Length to which a MAC algorithm is truncated.
  *
  * \param mac_alg       A MAC algorithm identifier (value of type
- *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p alg)
+ *                      #psa_algorithm_t such that #PSA_ALG_IS_MAC(\p mac_alg)
  *                      is true).
  *
  * \return              Length of the truncated MAC in bytes.
- * \return              0 if \p alg is a non-truncated MAC algorithm.
- * \return              Unspecified if \p alg is not a supported
+ * \return              0 if \p mac_alg is a non-truncated MAC algorithm.
+ * \return              Unspecified if \p mac_alg is not a supported
  *                      MAC algorithm.
  */
 #define PSA_MAC_TRUNCATED_LENGTH(mac_alg)                               \
@@ -1007,7 +1096,6 @@
  *
  * The underlying stream cipher is determined by the key type.
  * - To use ChaCha20, use a key type of #PSA_KEY_TYPE_CHACHA20.
- * - To use ARC4, use a key type of #PSA_KEY_TYPE_ARC4.
  */
 #define PSA_ALG_STREAM_CIPHER                   ((psa_algorithm_t)0x04800100)
 
@@ -1138,13 +1226,13 @@
  * of the ciphertext.
  *
  * \param aead_alg      An AEAD algorithm identifier (value of type
- *                      #psa_algorithm_t such that #PSA_ALG_IS_AEAD(\p alg)
+ *                      #psa_algorithm_t such that #PSA_ALG_IS_AEAD(\p aead_alg)
  *                      is true).
  * \param tag_length    Desired length of the authentication tag in bytes.
  *
  * \return              The corresponding AEAD algorithm with the specified
  *                      length.
- * \return              Unspecified if \p alg is not a supported
+ * \return              Unspecified if \p aead_alg is not a supported
  *                      AEAD algorithm or if \p tag_length is not valid
  *                      for the specified AEAD algorithm.
  */
@@ -1157,13 +1245,12 @@
 /** Retrieve the tag length of a specified AEAD algorithm
  *
  * \param aead_alg      An AEAD algorithm identifier (value of type
- *                      #psa_algorithm_t such that #PSA_ALG_IS_AEAD(\p alg)
+ *                      #psa_algorithm_t such that #PSA_ALG_IS_AEAD(\p aead_alg)
  *                      is true).
  *
  * \return              The tag length specified by the input algorithm.
- * \return              Unspecified if \p alg is not a supported
- *                      AEAD algorithm or if \p tag_length is not valid
- *                      for the specified AEAD algorithm.
+ * \return              Unspecified if \p aead_alg is not a supported
+ *                      AEAD algorithm.
  */
 #define PSA_ALG_AEAD_GET_TAG_LENGTH(aead_alg)                           \
     (((aead_alg) & PSA_ALG_AEAD_TAG_LENGTH_MASK) >>                     \
@@ -1172,7 +1259,7 @@
 /** Calculate the corresponding AEAD algorithm with the default tag length.
  *
  * \param aead_alg      An AEAD algorithm (\c PSA_ALG_XXX value such that
- *                      #PSA_ALG_IS_AEAD(\p alg) is true).
+ *                      #PSA_ALG_IS_AEAD(\p aead_alg) is true).
  *
  * \return              The corresponding AEAD algorithm with the default
  *                      tag length for that algorithm.
@@ -1337,6 +1424,94 @@
 #define PSA_ALG_IS_RANDOMIZED_ECDSA(alg)                                \
     (PSA_ALG_IS_ECDSA(alg) && !PSA_ALG_ECDSA_IS_DETERMINISTIC(alg))
 
+/** Edwards-curve digital signature algorithm without prehashing (PureEdDSA),
+ * using standard parameters.
+ *
+ * Contexts are not supported in the current version of this specification
+ * because there is no suitable signature interface that can take the
+ * context as a parameter. A future version of this specification may add
+ * suitable functions and extend this algorithm to support contexts.
+ *
+ * PureEdDSA requires an elliptic curve key on a twisted Edwards curve.
+ * In this specification, the following curves are supported:
+ * - #PSA_ECC_FAMILY_TWISTED_EDWARDS, 255-bit: Ed25519 as specified
+ *   in RFC 8032.
+ *   The curve is Edwards25519.
+ *   The hash function used internally is SHA-512.
+ * - #PSA_ECC_FAMILY_TWISTED_EDWARDS, 448-bit: Ed448 as specified
+ *   in RFC 8032.
+ *   The curve is Edwards448.
+ *   The hash function used internally is the first 114 bytes of the
+ *   SHAKE256 output.
+ *
+ * This algorithm can be used with psa_sign_message() and
+ * psa_verify_message(). Since there is no prehashing, it cannot be used
+ * with psa_sign_hash() or psa_verify_hash().
+ *
+ * The signature format is the concatenation of R and S as defined by
+ * RFC 8032 5.1.6 and 5.2.6 (a 64-byte string for Ed25519, a 114-byte
+ * string for Ed448).
+ */
+#define PSA_ALG_PURE_EDDSA                      ((psa_algorithm_t)0x06000800)
+
+#define PSA_ALG_HASH_EDDSA_BASE                 ((psa_algorithm_t)0x06000900)
+#define PSA_ALG_IS_HASH_EDDSA(alg)              \
+    (((alg) & ~PSA_ALG_HASH_MASK) == PSA_ALG_HASH_EDDSA_BASE)
+
+/** Edwards-curve digital signature algorithm with prehashing (HashEdDSA),
+ * using SHA-512 and the Edwards25519 curve.
+ *
+ * See #PSA_ALG_PURE_EDDSA regarding context support and the signature format.
+ *
+ * This algorithm is Ed25519 as specified in RFC 8032.
+ * The curve is Edwards25519.
+ * The prehash is SHA-512.
+ * The hash function used internally is SHA-512.
+ *
+ * This is a hash-and-sign algorithm: to calculate a signature,
+ * you can either:
+ * - call psa_sign_message() on the message;
+ * - or calculate the SHA-512 hash of the message
+ *   with psa_hash_compute()
+ *   or with a multi-part hash operation started with psa_hash_setup(),
+ *   using the hash algorithm #PSA_ALG_SHA_512,
+ *   then sign the calculated hash with psa_sign_hash().
+ * Verifying a signature is similar, using psa_verify_message() or
+ * psa_verify_hash() instead of the signature function.
+ */
+#define PSA_ALG_ED25519PH                               \
+    (PSA_ALG_HASH_EDDSA_BASE | (PSA_ALG_SHA_512 & PSA_ALG_HASH_MASK))
+
+/** Edwards-curve digital signature algorithm with prehashing (HashEdDSA),
+ * using SHAKE256 and the Edwards448 curve.
+ *
+ * See #PSA_ALG_PURE_EDDSA regarding context support and the signature format.
+ *
+ * This algorithm is Ed448 as specified in RFC 8032.
+ * The curve is Edwards448.
+ * The prehash is the first 64 bytes of the SHAKE256 output.
+ * The hash function used internally is the first 114 bytes of the
+ * SHAKE256 output.
+ *
+ * This is a hash-and-sign algorithm: to calculate a signature,
+ * you can either:
+ * - call psa_sign_message() on the message;
+ * - or calculate the first 64 bytes of the SHAKE256 output of the message
+ *   with psa_hash_compute()
+ *   or with a multi-part hash operation started with psa_hash_setup(),
+ *   using the hash algorithm #PSA_ALG_SHAKE256_512,
+ *   then sign the calculated hash with psa_sign_hash().
+ * Verifying a signature is similar, using psa_verify_message() or
+ * psa_verify_hash() instead of the signature function.
+ */
+#define PSA_ALG_ED448PH                                 \
+    (PSA_ALG_HASH_EDDSA_BASE | (PSA_ALG_SHAKE256_512 & PSA_ALG_HASH_MASK))
+
+/* Default definition, to be overridden if the library is extended with
+ * more hash-and-sign algorithms that we want to keep out of this header
+ * file. */
+#define PSA_ALG_IS_VENDOR_HASH_AND_SIGN(alg) 0
+
 /** Whether the specified algorithm is a hash-and-sign algorithm.
  *
  * Hash-and-sign algorithms are asymmetric (public-key) signature algorithms
@@ -1352,7 +1527,22 @@
  */
 #define PSA_ALG_IS_HASH_AND_SIGN(alg)                                   \
     (PSA_ALG_IS_RSA_PSS(alg) || PSA_ALG_IS_RSA_PKCS1V15_SIGN(alg) ||    \
-     PSA_ALG_IS_ECDSA(alg))
+     PSA_ALG_IS_ECDSA(alg) || PSA_ALG_IS_HASH_EDDSA(alg) ||             \
+     PSA_ALG_IS_VENDOR_HASH_AND_SIGN(alg))
+
+/** Whether the specified algorithm is a signature algorithm that can be used
+ * with psa_sign_message() and psa_verify_message().
+ *
+ * \param alg An algorithm identifier (value of type #psa_algorithm_t).
+ *
+ * \return 1 if alg is a signature algorithm that can be used to sign a
+ *         message. 0 if \p alg is a signature algorithm that can only be used
+ *         to sign an already-calculated hash. 0 if \p alg is not a signature
+ *         algorithm. This macro can return either 0 or 1 if \p alg is not a
+ *         supported algorithm identifier.
+ */
+#define PSA_ALG_IS_SIGN_MESSAGE(alg)                                    \
+    (PSA_ALG_IS_HASH_AND_SIGN(alg) || (alg) == PSA_ALG_PURE_EDDSA )
 
 /** Get the hash used by a hash-and-sign signature algorithm.
  *
@@ -1534,6 +1724,67 @@
 #define PSA_ALG_TLS12_PSK_TO_MS_GET_HASH(hkdf_alg)                         \
     (PSA_ALG_CATEGORY_HASH | ((hkdf_alg) & PSA_ALG_HASH_MASK))
 
+/* This flag indicates whether the key derivation algorithm is suitable for
+ * use on low-entropy secrets such as password - these algorithms are also
+ * known as key stretching or password hashing schemes. These are also the
+ * algorithms that accepts inputs of type #PSA_KEY_DERIVATION_INPUT_PASSWORD.
+ *
+ * Those algorithms cannot be combined with a key agreement algorithm.
+ */
+#define PSA_ALG_KEY_DERIVATION_STRETCHING_FLAG  ((psa_algorithm_t)0x00800000)
+
+#define PSA_ALG_PBKDF2_HMAC_BASE                ((psa_algorithm_t)0x08800100)
+/** Macro to build a PBKDF2-HMAC password hashing / key stretching algorithm.
+ *
+ * PBKDF2 is defined by PKCS#5, republished as RFC 8018 (section 5.2).
+ * This macro specifies the PBKDF2 algorithm constructed using a PRF based on
+ * HMAC with the specified hash.
+ * For example, `PSA_ALG_PBKDF2_HMAC(PSA_ALG_SHA256)` specifies PBKDF2
+ * using the PRF HMAC-SHA-256.
+ *
+ * This key derivation algorithm uses the following inputs, which must be
+ * provided in the following order:
+ * - #PSA_KEY_DERIVATION_INPUT_COST is the iteration count.
+ *   This input step must be used exactly once.
+ * - #PSA_KEY_DERIVATION_INPUT_SALT is the salt.
+ *   This input step must be used one or more times; if used several times, the
+ *   inputs will be concatenated. This can be used to build the final salt
+ *   from multiple sources, both public and secret (also known as pepper).
+ * - #PSA_KEY_DERIVATION_INPUT_PASSWORD is the password to be hashed.
+ *   This input step must be used exactly once.
+ *
+ * \param hash_alg      A hash algorithm (\c PSA_ALG_XXX value such that
+ *                      #PSA_ALG_IS_HASH(\p hash_alg) is true).
+ *
+ * \return              The corresponding PBKDF2-HMAC-XXX algorithm.
+ * \return              Unspecified if \p hash_alg is not a supported
+ *                      hash algorithm.
+ */
+#define PSA_ALG_PBKDF2_HMAC(hash_alg)                                  \
+    (PSA_ALG_PBKDF2_HMAC_BASE | ((hash_alg) & PSA_ALG_HASH_MASK))
+
+/** Whether the specified algorithm is a PBKDF2-HMAC algorithm.
+ *
+ * \param alg An algorithm identifier (value of type #psa_algorithm_t).
+ *
+ * \return 1 if \c alg is a PBKDF2-HMAC algorithm, 0 otherwise.
+ *         This macro may return either 0 or 1 if \c alg is not a supported
+ *         key derivation algorithm identifier.
+ */
+#define PSA_ALG_IS_PBKDF2_HMAC(alg)                                    \
+    (((alg) & ~PSA_ALG_HASH_MASK) == PSA_ALG_PBKDF2_HMAC_BASE)
+
+/** The PBKDF2-AES-CMAC-PRF-128 password hashing / key stretching algorithm.
+ *
+ * PBKDF2 is defined by PKCS#5, republished as RFC 8018 (section 5.2).
+ * This macro specifies the PBKDF2 algorithm constructed using the
+ * AES-CMAC-PRF-128 PRF specified by RFC 4615.
+ *
+ * This key derivation algorithm uses the same inputs as
+ * #PSA_ALG_PBKDF2_HMAC() with the same constraints.
+ */
+#define PSA_ALG_PBKDF2_AES_CMAC_PRF_128         ((psa_algorithm_t)0x08800200)
+
 #define PSA_ALG_KEY_DERIVATION_MASK             ((psa_algorithm_t)0xfe00ffff)
 #define PSA_ALG_KEY_AGREEMENT_MASK              ((psa_algorithm_t)0xffff0000)
 
@@ -1671,6 +1922,18 @@
      (alg & PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG) != 0 :  \
      (alg) == PSA_ALG_ANY_HASH)
 
+/** Get the hash used by a composite algorithm.
+ *
+ * \param alg An algorithm identifier (value of type #psa_algorithm_t).
+ *
+ * \return The underlying hash algorithm if alg is a composite algorithm that
+ * uses a hash algorithm.
+ *
+ * \return \c 0 if alg is not a composite algorithm that uses a hash.
+ */
+#define PSA_ALG_GET_HASH(alg) \
+        (((alg) & 0x000000ff) == 0 ? ((psa_algorithm_t)0) : 0x02000000 | ((alg) & 0x000000ff))
+
 /**@}*/
 
 /** \defgroup key_lifetimes Key lifetimes
@@ -1748,6 +2011,27 @@
     (PSA_KEY_LIFETIME_GET_PERSISTENCE(lifetime) == \
      PSA_KEY_PERSISTENCE_VOLATILE)
 
+/** Whether a key lifetime indicates that the key is read-only.
+ *
+ * Read-only keys cannot be created or destroyed through the PSA Crypto API.
+ * They must be created through platform-specific means that bypass the API.
+ *
+ * Some platforms may offer ways to destroy read-only keys. For example,
+ * consider a platform with multiple levels of privilege, where a
+ * low-privilege application can use a key but is not allowed to destroy
+ * it, and the platform exposes the key to the application with a read-only
+ * lifetime. High-privilege code can destroy the key even though the
+ * application sees the key as read-only.
+ *
+ * \param lifetime      The lifetime value to query (value of type
+ *                      ::psa_key_lifetime_t).
+ *
+ * \return \c 1 if the key is read-only, otherwise \c 0.
+ */
+#define PSA_KEY_LIFETIME_IS_READ_ONLY(lifetime)  \
+    (PSA_KEY_LIFETIME_GET_PERSISTENCE(lifetime) == \
+     PSA_KEY_PERSISTENCE_READ_ONLY)
+
 /** Construct a lifetime from a persistence level and a location.
  *
  * \param persistence   The persistence level
@@ -1841,6 +2125,26 @@
  */
 #define PSA_KEY_USAGE_DECRYPT                   ((psa_key_usage_t)0x00000200)
 
+/** Whether the key may be used to sign a message.
+ *
+ * This flag allows the key to be used for a MAC calculation operation or for
+ * an asymmetric message signature operation, if otherwise permitted by the
+ * keys type and policy.
+ *
+ * For a key pair, this concerns the private key.
+ */
+#define PSA_KEY_USAGE_SIGN_MESSAGE              ((psa_key_usage_t)0x00000400)
+
+/** Whether the key may be used to verify a message.
+ *
+ * This flag allows the key to be used for a MAC verification operation or for
+ * an asymmetric message signature verification operation, if otherwise
+ * permitted by the keys type and policy.
+ *
+ * For a key pair, this concerns the public key.
+ */
+#define PSA_KEY_USAGE_VERIFY_MESSAGE            ((psa_key_usage_t)0x00000800)
+
 /** Whether the key may be used to sign a message.
  *
  * This flag allows the key to be used for a MAC calculation operation
@@ -1861,10 +2165,35 @@
  */
 #define PSA_KEY_USAGE_VERIFY_HASH               ((psa_key_usage_t)0x00002000)
 
-/** Whether the key may be used to derive other keys.
+/** Whether the key may be used to derive other keys or produce a password
+ * hash.
+ *
+ * This flag allows the key to be used for a key derivation operation or for
+ * a key agreement operation, if otherwise permitted by by the key's type and
+ * policy.
+ *
+ * If this flag is present on all keys used in calls to
+ * psa_key_derivation_input_key() for a key derivation operation, then it
+ * permits calling psa_key_derivation_output_bytes() or
+ * psa_key_derivation_output_key() at the end of the operation.
  */
 #define PSA_KEY_USAGE_DERIVE                    ((psa_key_usage_t)0x00004000)
 
+/** Whether the key may be used to verify the result of a key derivation,
+ * including password hashing.
+ *
+ * This flag allows the key to be used:
+ *
+ * This flag allows the key to be used in a key derivation operation, if
+ * otherwise permitted by by the key's type and policy.
+ *
+ * If this flag is present on all keys used in calls to
+ * psa_key_derivation_input_key() for a key derivation operation, then it
+ * permits calling psa_key_derivation_verify_bytes() or
+ * psa_key_derivation_verify_key() at the end of the operation.
+ */
+#define PSA_KEY_USAGE_VERIFY_DERIVATION         ((psa_key_usage_t)0x00008000)
+
 /**@}*/
 
 /** \defgroup derivation Key derivation
@@ -1881,10 +2210,31 @@
  * The secret can also be a direct input (passed to
  * key_derivation_input_bytes()). In this case, the derivation operation
  * may not be used to derive keys: the operation will only allow
- * psa_key_derivation_output_bytes(), not psa_key_derivation_output_key().
+ * psa_key_derivation_output_bytes(),
+ * psa_key_derivation_verify_bytes(), or
+ * psa_key_derivation_verify_key(), but not
+ * psa_key_derivation_output_key().
  */
 #define PSA_KEY_DERIVATION_INPUT_SECRET     ((psa_key_derivation_step_t)0x0101)
 
+/** A low-entropy secret input for password hashing / key stretching.
+ *
+ * This is usually a key of type #PSA_KEY_TYPE_PASSWORD (passed to
+ * psa_key_derivation_input_key()) or a direct input (passed to
+ * psa_key_derivation_input_bytes()) that is a password or passphrase. It can
+ * also be high-entropy secret such as a key of type #PSA_KEY_TYPE_DERIVE or
+ * the shared secret resulting from a key agreement.
+ *
+ * The secret can also be a direct input (passed to
+ * key_derivation_input_bytes()). In this case, the derivation operation
+ * may not be used to derive keys: the operation will only allow
+ * psa_key_derivation_output_bytes(),
+ * psa_key_derivation_verify_bytes(), or
+ * psa_key_derivation_verify_key(), but not
+ * psa_key_derivation_output_key().
+ */
+#define PSA_KEY_DERIVATION_INPUT_PASSWORD   ((psa_key_derivation_step_t)0x0102)
+
 /** A label for key derivation.
  *
  * This should be a direct input.
@@ -1895,7 +2245,8 @@
 /** A salt for key derivation.
  *
  * This should be a direct input.
- * It can also be a key of type #PSA_KEY_TYPE_RAW_DATA.
+ * It can also be a key of type #PSA_KEY_TYPE_RAW_DATA or
+ * #PSA_KEY_TYPE_PEPPER.
  */
 #define PSA_KEY_DERIVATION_INPUT_SALT       ((psa_key_derivation_step_t)0x0202)
 
@@ -1913,6 +2264,35 @@
  */
 #define PSA_KEY_DERIVATION_INPUT_SEED       ((psa_key_derivation_step_t)0x0204)
 
+/** A cost parameter for password hashing / key stretching.
+ *
+ * This must be a direct input, passed to psa_key_derivation_input_integer().
+ */
+#define PSA_KEY_DERIVATION_INPUT_COST       ((psa_key_derivation_step_t)0x0205)
+
+/**@}*/
+
+/** \defgroup helper_macros Helper macros
+ * @{
+ */
+
+/* Helper macros */
+
+/** Check if two AEAD algorithm identifiers refer to the same AEAD algorithm
+ *  regardless of the tag length they encode.
+ *
+ * \param aead_alg_1 An AEAD algorithm identifier.
+ * \param aead_alg_2 An AEAD algorithm identifier.
+ *
+ * \return           1 if both identifiers refer to the same AEAD algorithm,
+ *                   0 otherwise.
+ *                   Unspecified if neither \p aead_alg_1 nor \p aead_alg_2 are
+ *                   a supported AEAD algorithm.
+ */
+#define MBEDTLS_PSA_ALG_AEAD_EQUAL(aead_alg_1, aead_alg_2) \
+    (!(((aead_alg_1) ^ (aead_alg_2)) & \
+       ~(PSA_ALG_AEAD_TAG_LENGTH_MASK | PSA_ALG_AEAD_AT_LEAST_THIS_LENGTH_FLAG)))
+
 /**@}*/
 
 #endif /* PSA_CRYPTO_VALUES_H */
diff --git a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
index 55701f526485f630476b9506c0b9711e3fc4cdbe..d2f094404befd71565e9b4436af2fa4a1a6d2fcb 100755
--- a/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
+++ b/lib/tf-m/platform/ext/target/nxp/lpcxpresso55s69/partition/flash_layout.h
@@ -62,16 +62,20 @@
 
 /* Size of a Secure and of a Non-secure image */
 #ifdef BL2
-#define FLASH_S_PARTITION_SIZE          (0x28000) /* S partition: 160 KB */
-#define FLASH_NS_PARTITION_SIZE         (0x18000) /* NS partition: 96 KB */
-#else
+
+#define FLASH_S_PARTITION_SIZE              (0x28000) /* S partition: 160 KB */
+#define FLASH_NS_PARTITION_SIZE             (0x18000) /* NS partition: 96 KB */
+#define FLASH_MAX_PARTITION_SIZE            ((FLASH_S_PARTITION_SIZE >   \
+                                             FLASH_NS_PARTITION_SIZE) ? \
+                                             FLASH_S_PARTITION_SIZE :    \
+                                             FLASH_NS_PARTITION_SIZE)
+
+#else /* NO BL2 */
+
 #define FLASH_S_PARTITION_SIZE              (0x50000)       /* S partition: 320 kB*/
-#define FLASH_NS_PARTITION_SIZE         (0x40000) /* NS partition: 256 KB*/
+#define FLASH_NS_PARTITION_SIZE             (0x40000)       /* NS partition: 256 kB*/
+
 #endif /* BL2 */
-#define FLASH_MAX_PARTITION_SIZE        ((FLASH_S_PARTITION_SIZE >   \
-                                          FLASH_NS_PARTITION_SIZE) ? \
-                                         FLASH_S_PARTITION_SIZE :    \
-                                         FLASH_NS_PARTITION_SIZE)
 
 /* Sector size of the embedded flash hardware (erase/program) */
 #define FLASH_AREA_IMAGE_SECTOR_SIZE        (512)           /* 512 B. Flash memory program/erase operations have a page granularity. */
@@ -149,12 +153,20 @@
 
 #else /* NO BL2 */
 
-/* Secure + Non-secure image slot */
+
+#ifdef SB_FILE /* Use signed Secure Binary (SB) image */
+#define FLASH_SB_TAIL   0x1000 /* 4 KB */
+#else
+#define FLASH_SB_TAIL   0x0 /* 0 KB */
+#endif
+
+/* Secure + Non-secure image primary slot */
 #define FLASH_AREA_0_ID            (1)
 #define FLASH_AREA_0_OFFSET        (0x0)
 #define FLASH_AREA_0_SIZE          (FLASH_S_PARTITION_SIZE + \
-                                    FLASH_NS_PARTITION_SIZE)
-
+                                    FLASH_NS_PARTITION_SIZE + \
+                                    FLASH_SB_TAIL)
+                                    
 /* Not used*/
 #define FLASH_AREA_SCRATCH_ID      (FLASH_AREA_0_ID + 1)
 #define FLASH_AREA_SCRATCH_OFFSET  (FLASH_AREA_0_OFFSET + FLASH_AREA_0_SIZE)
@@ -257,4 +269,4 @@
 #define TOTAL_ROM_SIZE      FLASH_TOTAL_SIZE
 #define TOTAL_RAM_SIZE      (0x00044000)     /* RAM 0-4. 272 KB RAM for data (without SRAM X for code)*/
 
-#endif /* __FLASH_LAYOUT_H__ */
+#endif /* __FLASH_LAYOUT_H__ */
\ No newline at end of file
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
index 6cbdd94150c1abd51ccae22be106ad1c43fb2619..08c866e42acc4069d89a9d3e9dffbe9c9005a8cc 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/target_cfg.c
@@ -23,11 +23,7 @@
 #include "region_defs.h"
 #include "tfm_plat_defs.h"
 #include "region.h"
-
-// FIXME: needed for syscounter init hack
-#include "syscounter_armv8-m_cntrl_drv.h"
-#include "device_cfg.h"
-#include "device_definition.h"
+#include "platform_base_address.h"
 
 /* Throw out bus error when an access causes security violation */
 #define CMSDK_SECRESPCFG_BUS_ERR_MASK   (1UL << 0)
@@ -75,6 +71,7 @@ extern ARM_DRIVER_MPC Driver_ISRAM0_MPC;
 extern ARM_DRIVER_MPC Driver_ISRAM1_MPC;
 extern ARM_DRIVER_MPC Driver_SRAM_MPC;
 extern ARM_DRIVER_MPC Driver_QSPI_MPC;
+extern ARM_DRIVER_MPC Driver_DDR4_MPC;
 
 /* Import PPC drivers */
 extern DRIVER_PPC_SSE300 Driver_PPC_SSE300_MAIN0;
@@ -222,6 +219,17 @@ enum tfm_plat_err_t nvic_interrupt_enable(void)
         ERROR_MSG("Failed to Enable MPC interrupt for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
+    ret = Driver_ISRAM1_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ret = Driver_DDR4_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
 
     ret = Driver_SRAM_MPC.EnableInterrupt();
     if (ret != ARM_DRIVER_OK) {
@@ -229,6 +237,12 @@ enum tfm_plat_err_t nvic_interrupt_enable(void)
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_QSPI_MPC.EnableInterrupt();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Enable MPC interrupt for QSPI!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
     NVIC_ClearPendingIRQ(MPC_IRQn);
     NVIC_EnableIRQ(MPC_IRQn);
 
@@ -299,17 +313,17 @@ void sau_and_idau_cfg(void)
     /* Enables SAU */
     TZ_SAU_Enable();
 
-    /* Configures SAU regions to be non-secure */
     SAU->RNR  = 0;
+    SAU->RBAR = (ISRAM0_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((ISRAM0_BASE_NS + ISRAM0_SIZE + ISRAM1_SIZE - 1) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    /* Configures SAU regions to be non-secure */
+    SAU->RNR  = 1;
     SAU->RBAR = (memory_regions.non_secure_partition_base
                  & SAU_RBAR_BADDR_Msk);
     SAU->RLAR = (memory_regions.non_secure_partition_limit
                   & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 
-    SAU->RNR  = 1;
-    SAU->RBAR = (NS_DATA_START & SAU_RBAR_BADDR_Msk);
-    SAU->RLAR = (NS_DATA_LIMIT & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
-
     /* Configures veneers region to be non-secure callable */
     SAU->RNR  = 2;
     SAU->RBAR = (memory_regions.veneer_base & SAU_RBAR_BADDR_Msk);
@@ -329,8 +343,26 @@ void sau_and_idau_cfg(void)
     SAU->RLAR = (memory_regions.secondary_partition_limit
                  & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 
+    /* steal data memory from QSPI end */
+    SAU->RNR = 5;
+    SAU->RBAR = (0x28700000 & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((0x28800000 - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    SAU->RNR = 6;
+    SAU->RBAR = (DDR4_BLK0_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+    SAU->RNR = 7;
+    SAU->RBAR = (DDR4_BLK2_BASE_NS & SAU_RBAR_BADDR_Msk);
+    SAU->RLAR = ((DDR4_BLK2_BASE_NS + DDR4_BLK_SIZE - 1)
+        & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
+
+
+
     /* Allows SAU to define the CODE region as a NSC */
-    sacfg->nsccfg |= CODENSC;
+    sacfg->nsccfg |= RAMNSC;
 }
 
 /*------------------- Memory configuration functions -------------------------*/
@@ -345,43 +377,94 @@ enum tfm_plat_err_t mpc_init_cfg(void)
         ERROR_MSG("Failed to Initialize MPC for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_ISRAM0_MPC.ConfigRegion(MPC_ISRAM0_RANGE_BASE_NS,
-                                      MPC_ISRAM0_RANGE_LIMIT_NS,
-                                      ARM_MPC_ATTR_NONSECURE);
+    ret = Driver_ISRAM0_MPC.ConfigRegion(ISRAM0_BASE_NS,
+                                         ISRAM0_BASE_NS + ISRAM0_SIZE - 1,
+                                         ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
         ERROR_MSG("Failed to Configure MPC for ISRAM0!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_ISRAM1_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_ISRAM1_MPC.ConfigRegion(ISRAM1_BASE_NS,
+                                         ISRAM1_BASE_NS + ISRAM1_SIZE - 1,
+                                         ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for ISRAM1!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
+    ret = Driver_SRAM_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for SRAM!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_SRAM_MPC.ConfigRegion(MPC_SRAM_RANGE_BASE_NS,
+                                         MPC_SRAM_RANGE_LIMIT_NS,
+                                         ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+
     /* Configuring primary and secondary non-secure partition.
      * It is ensured in flash_layout.h that these memory regions are located in
      * SRAM SRAM device. */
-    ret = Driver_SRAM_MPC.Initialize();
+    ret = Driver_QSPI_MPC.Initialize();
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Initialize MPC for SRAM!");
+        ERROR_MSG("Failed to Initialize MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_SRAM_MPC.ConfigRegion(
+    ret = Driver_QSPI_MPC.ConfigRegion(
                                       memory_regions.non_secure_partition_base,
                                       memory_regions.non_secure_partition_limit,
                                       ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        ERROR_MSG("Failed to Configure MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
-    ret = Driver_SRAM_MPC.ConfigRegion(
-                                      memory_regions.secondary_partition_base,
-                                      memory_regions.secondary_partition_limit,
-                                      ARM_MPC_ATTR_NONSECURE);
+    ret = Driver_QSPI_MPC.ConfigRegion(
+        0x28700000, /* steal data memory from QSPI end */
+        0x28800000-1,
+        ARM_MPC_ATTR_NONSECURE);
     if (ret != ARM_DRIVER_OK) {
-        ERROR_MSG("Failed to Configure MPC for SRAM!");
+        ERROR_MSG("Failed to Configure MPC for QSPI!");
         return TFM_PLAT_ERR_SYSTEM_ERR;
     }
 
+    ret = Driver_DDR4_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_DDR4_MPC.ConfigRegion(DDR4_BLK0_BASE_NS,
+                                       DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1,
+                                       ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    /* second init just like memtest */
+    ret = Driver_DDR4_MPC.Initialize();
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Initialize MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
+    ret = Driver_DDR4_MPC.ConfigRegion(DDR4_BLK2_BASE_NS,
+                                       DDR4_BLK2_BASE_NS + DDR4_BLK_SIZE - 1,
+                                       ARM_MPC_ATTR_NONSECURE);
+    if (ret != ARM_DRIVER_OK) {
+        ERROR_MSG("Failed to Configure MPC for DDR4!");
+        return TFM_PLAT_ERR_SYSTEM_ERR;
+    }
 
     /* Lock down not used MPC's */
-    Driver_QSPI_MPC.LockDown();
-    Driver_ISRAM1_MPC.LockDown();
+    //Driver_QSPI_MPC.LockDown();
+    //Driver_ISRAM1_MPC.LockDown();
 
     /* SRAM and ISRAM0 MPCs left unlocked as they are not reset if NVIC system
      * reset asserted.
@@ -398,12 +481,20 @@ enum tfm_plat_err_t mpc_init_cfg(void)
 
 void mpc_revert_non_secure_to_secure_cfg(void)
 {
-    Driver_ISRAM0_MPC.ConfigRegion(MPC_ISRAM0_RANGE_BASE_S,
-                                   MPC_ISRAM0_RANGE_LIMIT_S,
+    Driver_ISRAM0_MPC.ConfigRegion(ISRAM0_BASE_NS,
+                                   ISRAM1_SIZE,
+                                   ARM_MPC_ATTR_SECURE);
+
+    Driver_ISRAM1_MPC.ConfigRegion(ISRAM1_BASE_NS,
+                                   ISRAM1_SIZE,
                                    ARM_MPC_ATTR_SECURE);
 
-    Driver_SRAM_MPC.ConfigRegion(MPC_SRAM_RANGE_BASE_S,
-                                 MPC_SRAM_RANGE_LIMIT_S,
+    Driver_DDR4_MPC.ConfigRegion(DDR4_BLK0_BASE_NS,
+                                 DDR4_BLK0_BASE_NS + DDR4_BLK_SIZE - 1,
+                                 ARM_MPC_ATTR_SECURE);
+
+    Driver_QSPI_MPC.ConfigRegion(MPC_QSPI_RANGE_BASE_S,
+                                 MPC_QSPI_RANGE_LIMIT_S,
                                  ARM_MPC_ATTR_SECURE);
 
     /* Add barriers to assure the MPC configuration is done before continue
@@ -416,7 +507,10 @@ void mpc_revert_non_secure_to_secure_cfg(void)
 void mpc_clear_irq(void)
 {
     Driver_ISRAM0_MPC.ClearInterrupt();
+    Driver_ISRAM1_MPC.ClearInterrupt();
     Driver_SRAM_MPC.ClearInterrupt();
+    Driver_QSPI_MPC.ClearInterrupt();
+    Driver_DDR4_MPC.ClearInterrupt();
 }
 
 /*------------------- PPC configuration functions -------------------------*/
@@ -513,6 +607,9 @@ enum tfm_plat_err_t ppc_init_cfg(void)
     err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigSecurity(
                                         CLCD_PERIPH_PPCEXP2_POS_MASK,
                                         PPC_SSE300_NONSECURE_CONFIG);
+    err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigSecurity(
+                                        VSI_PERIPH_PPCEXP2_POS_MASK,
+                                        PPC_SSE300_NONSECURE_CONFIG);
 
     /* Grant un-privileged access for UART0 in NS domain */
     err |= Driver_PPC_SSE300_PERIPH_EXP2.ConfigPrivilege(
@@ -520,17 +617,6 @@ enum tfm_plat_err_t ppc_init_cfg(void)
                                         PPC_SSE300_NONSECURE_CONFIG,
                                         PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
 
-    err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
-                                        USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
-                                        PPC_SSE300_NONSECURE_CONFIG,
-                                        PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
-    // err |= Driver_PPC_SSE300_MAIN_EXP0.ConfigPrivilege(
-    //                                     USB_AND_ETHERNET_MAIN_PPCEXP0_POS_MASK,
-    //                                     PPC_SSE300_NONSECURE_CONFIG,
-    //                                     PPC_SSE300_PRIV_AND_NONPRIV_CONFIG);
-
-    syscounter_armv8_m_cntrl_init(&SYSCOUNTER_CNTRL_ARMV8_M_DEV);
-
     /* Initialize not used PPC drivers */
     err |= Driver_PPC_SSE300_MAIN0.Initialize();
     err |= Driver_PPC_SSE300_MAIN_EXP2.Initialize();
diff --git a/lib/tf-m/lib/ext/t_cose/inc/t_cose_common.h b/lib/tf-m/lib/ext/t_cose/inc/t_cose_common.h
index 9b1a3dc5e2b29f76b68d0c8f84ce22651b1f4f9b..9375e35e975463d9cdd8895cf44f48579bd79b28 100644
--- a/lib/tf-m/lib/ext/t_cose/inc/t_cose_common.h
+++ b/lib/tf-m/lib/ext/t_cose/inc/t_cose_common.h
@@ -2,7 +2,7 @@
  * t_cose_common.h
  *
  * Copyright 2019, Laurence Lundblade
- * Copyright (c) 2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2020-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -282,7 +282,7 @@ enum t_cose_err_t {
     /** General unspecific failure. */
     T_COSE_ERR_FAIL = 17,
 
-    /** Equivalent to \c PSA_ERROR_TAMPERING_DETECTED. */
+    /** Equivalent to \c PSA_ERROR_CORRUPTION_DETECTED. */
     T_COSE_ERR_TAMPERING_DETECTED = 18,
 
     /** The key identified by a \ref t_cose_key or a key ID was not
diff --git a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_cc_sha512_t.c b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_cc_sha512_t.c
index 66585ce6c1ca42ed8446d3f1061009bb25611a21..09d8d78a51cb0b24879f7e90352fdde3347088b3 100644
--- a/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_cc_sha512_t.c
+++ b/lib/tf-m/lib/ext/cryptocell-312-runtime/codesafe/src/crypto_api/cc3x_sym/api/mbedtls_cc_sha512_t.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2020, Arm Limited and Contributors. All rights reserved.
+ * Copyright (c) 2001-2021, Arm Limited and Contributors. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -55,33 +55,33 @@ void mbedtls_sha512_t_starts( mbedtls_sha512_context *ctx, int is224 )
         CC_PalAbort("mbedtls_sha512_starts: is224 must be 0 or 1");
     }
 
-    ctx->total[0] = 0;
-    ctx->total[1] = 0;
+    ctx->MBEDTLS_PRIVATE(total)[0] = 0;
+    ctx->MBEDTLS_PRIVATE(total)[1] = 0;
 
     if( is224 == 1 ) {
         /* SHA-512/224 */
-        ctx->state[0] = UL64(0x8C3D37C819544DA2);
-        ctx->state[1] = UL64(0x73E1996689DCD4D6);
-        ctx->state[2] = UL64(0x1DFAB7AE32FF9C82);
-        ctx->state[3] = UL64(0x679DD514582F9FCF);
-        ctx->state[4] = UL64(0x0F6D2B697BD44DA8);
-        ctx->state[5] = UL64(0x77E36F7304C48942);
-        ctx->state[6] = UL64(0x3F9D85A86A1D36C8);
-        ctx->state[7] = UL64(0x1112E6AD91D692A1);
+        ctx->MBEDTLS_PRIVATE(state)[0] = UL64(0x8C3D37C819544DA2);
+        ctx->MBEDTLS_PRIVATE(state)[1] = UL64(0x73E1996689DCD4D6);
+        ctx->MBEDTLS_PRIVATE(state)[2] = UL64(0x1DFAB7AE32FF9C82);
+        ctx->MBEDTLS_PRIVATE(state)[3] = UL64(0x679DD514582F9FCF);
+        ctx->MBEDTLS_PRIVATE(state)[4] = UL64(0x0F6D2B697BD44DA8);
+        ctx->MBEDTLS_PRIVATE(state)[5] = UL64(0x77E36F7304C48942);
+        ctx->MBEDTLS_PRIVATE(state)[6] = UL64(0x3F9D85A86A1D36C8);
+        ctx->MBEDTLS_PRIVATE(state)[7] = UL64(0x1112E6AD91D692A1);
     }
     else {
         /* SHA-512/256 */
-        ctx->state[0] = UL64(0x22312194FC2BF72C);
-        ctx->state[1] = UL64(0x9F555FA3C84C64C2);
-        ctx->state[2] = UL64(0x2393B86B6F53B151);
-        ctx->state[3] = UL64(0x963877195940EABD);
-        ctx->state[4] = UL64(0x96283EE2A88EFFE3);
-        ctx->state[5] = UL64(0xBE5E1E2553863992);
-        ctx->state[6] = UL64(0x2B0199FC2C85B8AA);
-        ctx->state[7] = UL64(0x0EB72DDC81C52CA2);
+        ctx->MBEDTLS_PRIVATE(state)[0] = UL64(0x22312194FC2BF72C);
+        ctx->MBEDTLS_PRIVATE(state)[1] = UL64(0x9F555FA3C84C64C2);
+        ctx->MBEDTLS_PRIVATE(state)[2] = UL64(0x2393B86B6F53B151);
+        ctx->MBEDTLS_PRIVATE(state)[3] = UL64(0x963877195940EABD);
+        ctx->MBEDTLS_PRIVATE(state)[4] = UL64(0x96283EE2A88EFFE3);
+        ctx->MBEDTLS_PRIVATE(state)[5] = UL64(0xBE5E1E2553863992);
+        ctx->MBEDTLS_PRIVATE(state)[6] = UL64(0x2B0199FC2C85B8AA);
+        ctx->MBEDTLS_PRIVATE(state)[7] = UL64(0x0EB72DDC81C52CA2);
     }
 
-    ctx->is384 = 0;
+    ctx->MBEDTLS_PRIVATE(is384) = 0;
 }
 
 
@@ -90,7 +90,7 @@ void mbedtls_sha512_t_process( mbedtls_sha512_context *ctx, const unsigned char
     if (ctx == NULL || data == NULL) {
         CC_PalAbort("mbedtls_sha512_context and data buffer cannot be NULL");
     }
-    mbedtls_sha512_process(ctx, data);
+    mbedtls_internal_sha512_process(ctx, data);
 }
 
 /*
diff --git a/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c b/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c
index cb21fc79bb7ab3eadab20075b06a9929d664d84b..fd6c2c768b28cd79d71271a1f5697dda9674c423 100644
--- a/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c
+++ b/lib/tf-m/platform/ext/common/template/crypto_dummy_nv_seed.c
@@ -11,6 +11,7 @@
 /* NOTE: The seed value here is only an example, please do not use it in
  * production. Platform vendor should implement their own seed value.
  */
+#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
 const unsigned char seed_value[MBEDTLS_ENTROPY_BLOCK_SIZE] = {
             0x12, 0x13, 0x23, 0x34, 0x0a, 0x05, 0x89, 0x78,
             0xa3, 0x66, 0x8c, 0x0d, 0x97, 0x55, 0x53, 0xca,
@@ -21,6 +22,14 @@ const unsigned char seed_value[MBEDTLS_ENTROPY_BLOCK_SIZE] = {
             0x58, 0xb4, 0x16, 0xc8, 0x0f, 0x38, 0x91, 0xbb,
             0x28, 0x17, 0xcd, 0x8a, 0xc9, 0x53, 0x72, 0x66,
 };
+#else
+const unsigned char seed_value[MBEDTLS_ENTROPY_BLOCK_SIZE] = {
+            0x12, 0x13, 0x23, 0x34, 0x0a, 0x05, 0x89, 0x78,
+            0xa3, 0x66, 0x8c, 0x0d, 0x97, 0x55, 0x53, 0xca,
+            0xb5, 0x76, 0x18, 0x62, 0x29, 0xc6, 0xb6, 0x79,
+            0x75, 0xc8, 0x5a, 0x8d, 0x9e, 0x11, 0x8f, 0x85,
+};
+#endif
 
 int tfm_plat_crypto_create_entropy_seed(void)
 {
diff --git a/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c b/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
index d7db3038cda30f70bbba503aca6e9d9a262865e8..39cd00ad4c9e39773586eb498ce6c50fccd89275 100644
--- a/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
+++ b/lib/tf-m/secure_fw/spm/ffm/tfm_boot_data.c
@@ -69,8 +69,12 @@ struct boot_data_access_policy {
  *        (identified by major_type).
  */
 static const struct boot_data_access_policy access_policy_table[] = {
+#ifdef TFM_PARTITION_INITIAL_ATTESTATION
     {TFM_SP_INITIAL_ATTESTATION, TLV_MAJOR_IAS},
+#endif
+#ifdef TFM_PARTITION_FIRMWARE_UPDATE
     {TFM_SP_FWU, TLV_MAJOR_FWU},
+#endif
 };
 
 /*!
diff --git a/lib/tf-m/interface/include/psa/crypto_sizes.h b/lib/tf-m/interface/include/psa/crypto_sizes.h
index 0608d71d10e1892be21f88dc13986902ea6818e9..1e282e26c1aed8502ed8aee877a2bf421a8c770b 100644
--- a/lib/tf-m/interface/include/psa/crypto_sizes.h
+++ b/lib/tf-m/interface/include/psa/crypto_sizes.h
@@ -50,8 +50,6 @@
  */
 #define PSA_HASH_LENGTH(alg)                                        \
     (                                                               \
-        PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_MD2 ? 16 :            \
-        PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_MD4 ? 16 :            \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_MD5 ? 16 :            \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_RIPEMD160 ? 20 :      \
         PSA_ALG_HMAC_GET_HASH(alg) == PSA_ALG_SHA_1 ? 20 :          \
@@ -77,8 +75,13 @@
 /* Note: for HMAC-SHA-3, the block size is 144 bytes for HMAC-SHA3-226,
  * 136 bytes for HMAC-SHA3-256, 104 bytes for SHA3-384, 72 bytes for
  * HMAC-SHA3-512. */
+#if defined(MBEDTLS_SHA512_C)
 #define PSA_HASH_MAX_SIZE 64
 #define PSA_HMAC_MAX_HASH_BLOCK_SIZE 128
+#else
+#define PSA_HASH_MAX_SIZE 32
+#define PSA_HMAC_MAX_HASH_BLOCK_SIZE 64
+#endif
 
 /** \def PSA_MAC_MAX_SIZE
  *
@@ -94,26 +97,35 @@
  */
 #define PSA_MAC_MAX_SIZE PSA_HASH_MAX_SIZE
 
-/** The tag size for an AEAD algorithm, in bytes.
+/** The length of a tag for an AEAD algorithm, in bytes.
  *
+ * This macro can be used to allocate a buffer of sufficient size to store the
+ * tag output from psa_aead_finish().
+ *
+ * See also #PSA_AEAD_TAG_MAX_SIZE.
+ *
+ * \param key_type            The type of the AEAD key.
+ * \param key_bits            The size of the AEAD key in bits.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
  *
- * \return                    The tag size for the specified algorithm.
+ * \return                    The tag length for the specified algorithm and key.
  *                            If the AEAD algorithm does not have an identified
  *                            tag that can be distinguished from the rest of
  *                            the ciphertext, return 0.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
-#define PSA_AEAD_TAG_LENGTH(alg)                                        \
-    (PSA_ALG_IS_AEAD(alg) ?                                             \
-     (((alg) & PSA_ALG_AEAD_TAG_LENGTH_MASK) >> PSA_AEAD_TAG_LENGTH_OFFSET) : \
-     0)
+#define PSA_AEAD_TAG_LENGTH(key_type, key_bits, alg)                        \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 ?                            \
+     PSA_ALG_AEAD_GET_TAG_LENGTH(alg) :                                     \
+     ((void) (key_bits), 0))
 
 /** The maximum tag size for all supported AEAD algorithms, in bytes.
  *
- * See also #PSA_AEAD_TAG_LENGTH(\p alg).
+ * See also #PSA_AEAD_TAG_LENGTH(\p key_type, \p key_bits, \p alg).
  */
 #define PSA_AEAD_TAG_MAX_SIZE       16
 
@@ -137,7 +149,7 @@
 
 /** This macro returns the maximum supported length of the PSK for the
  * TLS-1.2 PSK-to-MS key derivation
- * (#PSA_ALG_TLS12_PSK_TO_MS(\p hash_alg)).
+ * (#PSA_ALG_TLS12_PSK_TO_MS(\c hash_alg)).
  *
  * The maximum supported length does not depend on the chosen hash algorithm.
  *
@@ -155,7 +167,6 @@
 /** The maximum size of a block cipher. */
 #define PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE 16
 
-
 /** The size of the output of psa_mac_sign_finish(), in bytes.
  *
  * This is also the MAC size that psa_mac_verify_finish() expects.
@@ -190,10 +201,14 @@
  * insufficient buffer size. Depending on the algorithm, the actual size of
  * the ciphertext may be smaller.
  *
+ * See also #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\p plaintext_length).
+ *
  * \warning This macro may evaluate its arguments multiple times or
  *          zero times, so you should not pass arguments that contain
  *          side effects.
  *
+ * \param key_type            A symmetric key type that is
+ *                            compatible with algorithm \p alg.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
@@ -201,11 +216,13 @@
  *
  * \return                    The AEAD ciphertext size for the specified
  *                            algorithm.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
-#define PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, plaintext_length)       \
-    (PSA_AEAD_TAG_LENGTH(alg) != 0 ?                              \
-     (plaintext_length) + PSA_AEAD_TAG_LENGTH(alg) :              \
+#define PSA_AEAD_ENCRYPT_OUTPUT_SIZE(key_type, alg, plaintext_length) \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 ?                      \
+     (plaintext_length) + PSA_ALG_AEAD_GET_TAG_LENGTH(alg) :          \
      0)
 
 /** A sufficient output buffer size for psa_aead_encrypt(), for any of the
@@ -217,7 +234,8 @@
  * \note This macro returns a compile-time constant if its arguments are
  *       compile-time constants.
  *
- * See also #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\p alg, \p plaintext_length).
+ * See also #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\p key_type, \p alg,
+ * \p plaintext_length).
  *
  * \param plaintext_length    Size of the plaintext in bytes.
  *
@@ -236,10 +254,14 @@
  * insufficient buffer size. Depending on the algorithm, the actual size of
  * the plaintext may be smaller.
  *
+ * See also #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\p ciphertext_length).
+ *
  * \warning This macro may evaluate its arguments multiple times or
  *          zero times, so you should not pass arguments that contain
  *          side effects.
  *
+ * \param key_type            A symmetric key type that is
+ *                            compatible with algorithm \p alg.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
@@ -247,11 +269,14 @@
  *
  * \return                    The AEAD ciphertext size for the specified
  *                            algorithm.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
-#define PSA_AEAD_DECRYPT_OUTPUT_SIZE(alg, ciphertext_length)      \
-    (PSA_AEAD_TAG_LENGTH(alg) != 0 ?                              \
-     (ciphertext_length) - PSA_AEAD_TAG_LENGTH(alg) :             \
+#define PSA_AEAD_DECRYPT_OUTPUT_SIZE(key_type, alg, ciphertext_length) \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 &&                      \
+         (ciphertext_length) > PSA_ALG_AEAD_GET_TAG_LENGTH(alg) ?      \
+         (ciphertext_length) - PSA_ALG_AEAD_GET_TAG_LENGTH(alg) :      \
      0)
 
 /** A sufficient output buffer size for psa_aead_decrypt(), for any of the
@@ -263,7 +288,8 @@
  * \note This macro returns a compile-time constant if its arguments are
  *       compile-time constants.
  *
- * See also #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\p alg, \p ciphertext_length).
+ * See also #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\p key_type, \p alg,
+ * \p ciphertext_length).
  *
  * \param ciphertext_length   Size of the ciphertext in bytes.
  *
@@ -300,11 +326,12 @@
  *         or the parameters are incompatible, return 0.
  */
 #define PSA_AEAD_NONCE_LENGTH(key_type, alg) \
-    (PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) == 16 && \
-         (PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(alg) == PSA_ALG_CCM || \
-          PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(alg) == PSA_ALG_GCM) ? 12 : \
+    (PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) == 16 ? \
+          MBEDTLS_PSA_ALG_AEAD_EQUAL(alg, PSA_ALG_CCM) ? 13 : \
+          MBEDTLS_PSA_ALG_AEAD_EQUAL(alg, PSA_ALG_GCM) ? 12 : \
+          0 : \
      (key_type) == PSA_KEY_TYPE_CHACHA20 && \
-          PSA_ALG_AEAD_WITH_DEFAULT_LENGTH_TAG(alg) == PSA_ALG_CHACHA20_POLY1305 ? 12 : \
+          MBEDTLS_PSA_ALG_AEAD_EQUAL(alg, PSA_ALG_CHACHA20_POLY1305) ? 12 : \
      0)
 
 /** The maximum default nonce size among all supported pairs of key types and
@@ -318,7 +345,7 @@
  *       just the largest size that may be generated by
  *       #psa_aead_generate_nonce().
  */
-#define PSA_AEAD_NONCE_MAX_SIZE 12
+#define PSA_AEAD_NONCE_MAX_SIZE 13
 
 /** A sufficient output buffer size for psa_aead_update().
  *
@@ -327,10 +354,14 @@
  * insufficient buffer size. The actual size of the output may be smaller
  * in any given call.
  *
+ * See also #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\p input_length).
+ *
  * \warning This macro may evaluate its arguments multiple times or
  *          zero times, so you should not pass arguments that contain
  *          side effects.
  *
+ * \param key_type            A symmetric key type that is
+ *                            compatible with algorithm \p alg.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
@@ -338,16 +369,20 @@
  *
  * \return                    A sufficient output buffer size for the specified
  *                            algorithm.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
 /* For all the AEAD modes defined in this specification, it is possible
  * to emit output without delay. However, hardware may not always be
  * capable of this. So for modes based on a block cipher, allow the
  * implementation to delay the output until it has a full block. */
-#define PSA_AEAD_UPDATE_OUTPUT_SIZE(alg, input_length)                              \
-    (PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?                                         \
-     PSA_ROUND_UP_TO_MULTIPLE(PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE, (input_length)) :    \
-     (input_length))
+#define PSA_AEAD_UPDATE_OUTPUT_SIZE(key_type, alg, input_length)                             \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 ?                                             \
+         PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?                                              \
+         PSA_ROUND_UP_TO_MULTIPLE(PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type), (input_length)) : \
+         (input_length) : \
+     0)
 
 /** A sufficient output buffer size for psa_aead_update(), for any of the
  *  supported key types and AEAD algorithms.
@@ -355,7 +390,7 @@
  * If the size of the output buffer is at least this large, it is guaranteed
  * that psa_aead_update() will not fail due to an insufficient buffer size.
  *
- * See also #PSA_AEAD_UPDATE_OUTPUT_SIZE(\p alg, \p input_length).
+ * See also #PSA_AEAD_UPDATE_OUTPUT_SIZE(\p key_type, \p alg, \p input_length).
  *
  * \param input_length      Size of the input in bytes.
  */
@@ -369,23 +404,30 @@
  * insufficient ciphertext buffer size. The actual size of the output may
  * be smaller in any given call.
  *
+ * See also #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE.
+ *
+ * \param key_type            A symmetric key type that is
+                              compatible with algorithm \p alg.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
  *
  * \return                    A sufficient ciphertext buffer size for the
  *                            specified algorithm.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
-#define PSA_AEAD_FINISH_OUTPUT_SIZE(alg)                                \
-    (PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?                             \
-     PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE :                                  \
+#define PSA_AEAD_FINISH_OUTPUT_SIZE(key_type, alg) \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 &&  \
+         PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?    \
+         PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) : \
      0)
 
 /** A sufficient ciphertext buffer size for psa_aead_finish(), for any of the
  *  supported key types and AEAD algorithms.
  *
- * See also #PSA_AEAD_FINISH_OUTPUT_SIZE(\p alg).
+ * See also #PSA_AEAD_FINISH_OUTPUT_SIZE(\p key_type, \p alg).
  */
 #define PSA_AEAD_FINISH_OUTPUT_MAX_SIZE     (PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE)
 
@@ -396,23 +438,30 @@
  * insufficient plaintext buffer size. The actual size of the output may
  * be smaller in any given call.
  *
+ * See also #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE.
+ *
+ * \param key_type            A symmetric key type that is
+ *                            compatible with algorithm \p alg.
  * \param alg                 An AEAD algorithm
  *                            (\c PSA_ALG_XXX value such that
  *                            #PSA_ALG_IS_AEAD(\p alg) is true).
  *
  * \return                    A sufficient plaintext buffer size for the
  *                            specified algorithm.
- *                            If the AEAD algorithm is not recognized, return 0.
+ *                            If the key type or AEAD algorithm is not
+ *                            recognized, or the parameters are incompatible,
+ *                            return 0.
  */
-#define PSA_AEAD_VERIFY_OUTPUT_SIZE(alg)                                \
-    (PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?                             \
-     PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE :                                  \
+#define PSA_AEAD_VERIFY_OUTPUT_SIZE(key_type, alg) \
+    (PSA_AEAD_NONCE_LENGTH(key_type, alg) != 0 &&  \
+         PSA_ALG_IS_AEAD_ON_BLOCK_CIPHER(alg) ?    \
+         PSA_BLOCK_CIPHER_BLOCK_LENGTH(key_type) : \
      0)
 
 /** A sufficient plaintext buffer size for psa_aead_verify(), for any of the
  *  supported key types and AEAD algorithms.
  *
- * See also #PSA_AEAD_VERIFY_OUTPUT_SIZE(\p alg).
+ * See also #PSA_AEAD_VERIFY_OUTPUT_SIZE(\p key_type, \p alg).
  */
 #define PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE     (PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
index bf747de8554c7b29a8c1f817b600b848dd19f300..568d227c350d645c436329511ce34cd7796f2bd2 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/partition/region_defs.h
@@ -28,9 +28,9 @@
 #define S_MSP_STACK_SIZE        (0x0000800)
 #define S_PSP_STACK_SIZE        (0x0000800)
 
-#define NS_HEAP_SIZE            (0x0001000)
-#define NS_MSP_STACK_SIZE       (0x0000400)
-#define NS_PSP_STACK_SIZE       (0x0000C00)
+#define NS_HEAP_SIZE            (0x0008000)
+#define NS_MSP_STACK_SIZE       (0x0000800)
+#define NS_PSP_STACK_SIZE       (0x0002000)
 
 /* This size of buffer is big enough to store an attestation
  * token produced by initial attestation service
@@ -87,7 +87,7 @@
 #define S_IMAGE_PRIMARY_AREA_OFFSET \
              (S_IMAGE_PRIMARY_PARTITION_OFFSET + BL2_HEADER_SIZE)
 /* Secure Code stored in Code SRAM */
-#define S_CODE_START    ((SRAM_BASE_S) +  (S_IMAGE_PRIMARY_AREA_OFFSET))
+#define S_CODE_START    ((QSPI_SRAM_BASE_S) +  (S_IMAGE_PRIMARY_AREA_OFFSET))
 #define S_CODE_SIZE     (IMAGE_S_CODE_SIZE - CMSE_VENEER_REGION_SIZE)
 #define S_CODE_LIMIT    (S_CODE_START + S_CODE_SIZE - 1)
 
@@ -103,23 +103,23 @@
 #define NS_IMAGE_PRIMARY_AREA_OFFSET \
                         (NS_IMAGE_PRIMARY_PARTITION_OFFSET + BL2_HEADER_SIZE)
 /* Non-Secure Code stored in Code SRAM memory */
-#define NS_CODE_START   (SRAM_BASE_NS + (NS_IMAGE_PRIMARY_AREA_OFFSET))
+#define NS_CODE_START   (QSPI_SRAM_BASE_NS + (NS_IMAGE_PRIMARY_AREA_OFFSET))
 #define NS_CODE_SIZE    (IMAGE_NS_CODE_SIZE)
 #define NS_CODE_LIMIT   (NS_CODE_START + NS_CODE_SIZE - 1)
 
 /* Non-Secure Data stored in ISRAM0 */
 #define NS_DATA_START   (ISRAM0_BASE_NS)
-#define NS_DATA_SIZE    (ISRAM0_SIZE)
+#define NS_DATA_SIZE    (ISRAM0_SIZE + ISRAM1_SIZE)
 #define NS_DATA_LIMIT   (NS_DATA_START + NS_DATA_SIZE - 1)
 
 /* NS partition information is used for MPC and SAU configuration */
 #define NS_PARTITION_START \
-            ((SRAM_BASE_NS) + (NS_IMAGE_PRIMARY_PARTITION_OFFSET))
+            ((QSPI_SRAM_BASE_NS) + (NS_IMAGE_PRIMARY_PARTITION_OFFSET))
 #define NS_PARTITION_SIZE (FLASH_NS_PARTITION_SIZE)
 
 /* Secondary partition for new images in case of firmware upgrade */
 #define SECONDARY_PARTITION_START \
-            ((SRAM_BASE_NS) + (S_IMAGE_SECONDARY_PARTITION_OFFSET))
+            ((QSPI_SRAM_BASE_NS) + (S_IMAGE_SECONDARY_PARTITION_OFFSET))
 #define SECONDARY_PARTITION_SIZE (FLASH_S_PARTITION_SIZE + \
                                   FLASH_NS_PARTITION_SIZE)
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
index ef808ce6708f804f1c7b1088e7ed19bc86354350..1437941b7b81075ca1683acdb2ee2f46d255e14b 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/cmsis_drivers/config/RTE_Device.h
@@ -47,6 +47,11 @@
 #define   RTE_QSPI_MPC                   1
 // </e> MPC (Memory Protection Controller) [Driver_QSPI_MPC]
 
+// <e> MPC (Memory Protection Controller) [Driver_DDR4_MPC]
+// <i> Configuration settings for Driver_DDR4_MPC in component ::Drivers:MPC
+#define   RTE_DDR4_MPC                   1
+// </e> MPC (Memory Protection Controller) [Driver_DDR4_MPC]
+
 // <e> PPC (Peripheral Protection Controller) [PPC_SSE300_MAIN0]
 // <i> Configuration settings for Driver_PPC_SSE300_MAIN0 in component ::Drivers:PPC
 #define   RTE_PPC_SSE300_MAIN0             1
diff --git a/lib/tf-m/secure_fw/spm/include/load/irq_defs.h b/lib/tf-m/secure_fw/spm/include/load/irq_defs.h
index db0abec88cb7e14192852765ef8e52066334cbf1..1540d23f6d8b7da186e37b956b28c0d52035960d 100644
--- a/lib/tf-m/secure_fw/spm/include/load/irq_defs.h
+++ b/lib/tf-m/secure_fw/spm/include/load/irq_defs.h
@@ -10,8 +10,6 @@
 
 #include "psa/service.h"
 
-#define TFM_DEFAULT_SECURE_IRQ_PRIOTITY 128
-
 struct irq_load_info_t {
     uint32_t source;                       /* IRQ source (number/index)       */
     uint32_t flih_func;                    /* FLIH function - 0 if SLIH       */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
index c192152c7673f2d300d9674c6fe234518e3872dc..9e2e044f4bc2a1d6917af5e85403e9c0f1f1f3eb 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/spm_hal.c
@@ -21,14 +21,52 @@ extern ARM_DRIVER_MPC Driver_SRAM1_MPC;
 /* Get address of memory regions to configure MPU */
 extern const struct memory_region_limits memory_regions;
 
+#ifdef CONFIG_TFM_ENABLE_MEMORY_PROTECT
+struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
+
+#define PARTITION_REGION_PERIPH_START   5
+#define PARTITION_REGION_PERIPH_MAX_NUM 2
+
+uint32_t periph_num_count = 0;
+#endif /* CONFIG_TFM_ENABLE_MEMORY_PROTECT */
+
 enum tfm_plat_err_t tfm_spm_hal_configure_default_isolation(
                   bool privileged,
                   const struct platform_data_t *platform_data)
 {
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    struct mpu_armv8m_region_cfg_t region_cfg;
+#endif
+
     if (!platform_data) {
         return TFM_PLAT_ERR_INVALID_INPUT;
     }
 
+#if defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1)
+    if (!privileged) {
+        region_cfg.region_nr = PARTITION_REGION_PERIPH_START + periph_num_count;
+        periph_num_count++;
+        if (periph_num_count >= PARTITION_REGION_PERIPH_MAX_NUM) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        region_cfg.region_base = platform_data->periph_start;
+        region_cfg.region_limit = platform_data->periph_limit;
+        region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
+        region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_UNPRIV;
+        region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
+        region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
+
+        mpu_armv8m_disable(&dev_mpu_s);
+
+        if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg)
+            != MPU_ARMV8M_OK) {
+            return TFM_PLAT_ERR_SYSTEM_ERR;
+        }
+        mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
+                          HARDFAULT_NMI_ENABLE);
+    }
+#endif /* defined(CONFIG_TFM_ENABLE_MEMORY_PROTECT) && (TFM_LVL != 1) */
+
     if (platform_data->periph_ppc_bank != PPC_SP_DO_NOT_CONFIGURE) {
         ppc_configure_to_secure(platform_data->periph_ppc_bank,
                                 platform_data->periph_ppc_loc);
@@ -90,11 +128,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/platform/ext/target/nxp/common/mbedcrypto_user_config.h b/lib/tf-m/platform/ext/target/nxp/common/mbedcrypto_user_config.h
new file mode 100644
index 0000000000000000000000000000000000000000..dc7bc245729e79766de05a082e4b0121df8051e7
--- /dev/null
+++ b/lib/tf-m/platform/ext/target/nxp/common/mbedcrypto_user_config.h
@@ -0,0 +1,58 @@
+/**
+ * \file mbedcrypto_user_config.h
+ *
+ * \brief Target and application specific configurations
+ *
+ *  Target and application specific configurations allow user to override any previous default.
+ *
+ */
+/*
+ *  Copyright The Mbed TLS Contributors
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#ifndef MBEDCRYPTO_USER_CONFIG_H
+#define MBEDCRYPTO_USER_CONFIG_H
+
+/**
+ * \def MBEDTLS_HKDF_C
+ *
+ * Enable the HKDF algorithm (RFC 5869).
+ *
+ * Module:  library/hkdf.c
+ * Caller:
+ *
+ * Requires: MBEDTLS_MD_C
+ *
+ * This module adds support for the Hashed Message Authentication Code
+ * (HMAC)-based key derivation function (HKDF).
+ */
+#define MBEDTLS_HKDF_C /* Used for HUK deriviation */
+
+/**
+ * \def MBEDTLS_GCM_C
+ *
+ * Enable the Galois/Counter Mode (GCM).
+ *
+ * Module:  library/gcm.c
+ *
+ * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C or MBEDTLS_ARIA_C
+ *
+ * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
+ * requisites are enabled as well.
+ */
+#define MBEDTLS_GCM_C   /* Used by PS by default. Mandatory for TLSv1.2 */
+
+#endif /* MBEDCRYPTO_USER_CONFIG_H */
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c b/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
index 9390b46fef90eead04543342878186f412865142..33e20b5a8ae1bd33d4cd47b6cdc1ddad4f25d0e5 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an521/spm_hal.c
@@ -168,11 +168,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
index 6fe49b3259937da5dd50ae9ab2fff7b6038f1d24..4e576ed2632fb4feba26ee45fde9017c63a8ecb7 100644
--- a/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
+++ b/lib/tf-m/platform/ext/target/arm/mps3/an547/device/source/system_core_init.c
@@ -64,8 +64,19 @@ void SystemInit (void)
 
 #if (defined (__FPU_USED) && (__FPU_USED == 1U)) || \
     (defined (__ARM_FEATURE_MVE) && (__ARM_FEATURE_MVE == 1U))
+#if (TFM_SYSTEM_FP >= 1) || (TFM_SYSTEM_FP_NS >= 1)   
     SCB->CPACR |= ((3U << 10U*2U) |           /* enable CP10 Full Access */
                    (3U << 11U*2U)  );         /* enable CP11 Full Access */
+
+#if defined(TFM_LAZY_FP_NS) || defined(TFM_LAZY_FP)
+  /* Enable Lazy FP */
+  FPU->FPCCR |= FPU_FPCCR_LSPEN_Msk;
+#else
+  /* Disable Lazy FP */
+  FPU->FPCCR &= ~FPU_FPCCR_LSPEN_Msk;
+#endif /* TFM_LAZY_FP_NS */
+
+#endif /* TFM_SYSTEM_FP >= 1 || (TFM_SYSTEM_FP_NS >= 1) */                   
 #endif
 
 #ifdef UNALIGNED_SUPPORT_DISABLE
diff --git a/lib/tf-m/platform/ext/target/nuvoton/common/spm_hal.c b/lib/tf-m/platform/ext/target/nuvoton/common/spm_hal.c
index 9772399d3dbfc35baf3bb0ee69366e6f407cb929..4f3df5cd4a8deb9ab735a939ad1663168cca422b 100644
--- a/lib/tf-m/platform/ext/target/nuvoton/common/spm_hal.c
+++ b/lib/tf-m/platform/ext/target/nuvoton/common/spm_hal.c
@@ -84,11 +84,9 @@ uint32_t tfm_spm_hal_get_ns_entry_point(void)
     return *((uint32_t *)(memory_regions.non_secure_code_start+ 4));
 }
 
-enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line,
-                                                        uint32_t priority)
+enum tfm_plat_err_t tfm_spm_hal_set_secure_irq_priority(IRQn_Type irq_line)
 {
-    uint32_t quantized_priority = priority >> (8U - __NVIC_PRIO_BITS);
-    NVIC_SetPriority(irq_line, quantized_priority);
+    NVIC_SetPriority(irq_line, DEFAULT_IRQ_PRIORITY);
     return TFM_PLAT_ERR_SUCCESS;
 }
 
diff --git a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
index ee68f7a9ddd0398d020b581f2ff225908ee4893b..c3615f8fd0efc4d7cc69162ab5a8e21ac5609c99 100644
--- a/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
+++ b/lib/tf-m/platform/ext/target/stm/common/stm32l5xx/secure/tfm_platform_system.c
@@ -38,9 +38,3 @@ enum tfm_platform_err_t tfm_platform_hal_ioctl(tfm_platform_ioctl_req_t request,
     return TFM_PLATFORM_ERR_NOT_SUPPORTED;
 
 }
-
-void Error_Handler(void)
-{
-    /* Reset the system */
-    NVIC_SystemReset();
-}
diff --git a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_svcalls.h b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_svcalls.h
index d3b374ff50cbd2b634fbf65f7f225832beeda0a7..5d7f964be43bea93ab6f94d1e0aa54d3806539ae 100644
--- a/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_svcalls.h
+++ b/lib/tf-m/secure_fw/spm/cmsis_psa/tfm_svcalls.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2020, Arm Limited. All rights reserved.
+ * Copyright (c) 2018-2021, Arm Limited. All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
  *
@@ -13,11 +13,12 @@
  * \brief The C source of SVCall handlers
  *
  * \param[in] msp               MSP at SVCall entry.
- * \param[in] psp               PSP at SVCall entry.
  * \param[in] exc_return        EXC_RETURN value of the SVC.
- *
+ * \param[in] psp               PSP at SVCall entry.
+
  * \returns                     EXC_RETURN value indicates where to return.
  */
-uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t *psp, uint32_t exc_return);
+uint32_t tfm_core_svc_handler(uint32_t *msp, uint32_t exc_return,
+                              uint32_t *psp);
 
 #endif
diff --git a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/accelerator/mbedtls_accelerator_config.h b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/accelerator/mbedtls_accelerator_config.h
index bb2125f3aced579d80613ef81aa809f6e36929a1..97c8e2b3165fd59e2d1521f5662a80c6ba20a4fc 100644
--- a/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/accelerator/mbedtls_accelerator_config.h
+++ b/lib/tf-m/platform/ext/target/stm/nucleo_l552ze_q/accelerator/mbedtls_accelerator_config.h
@@ -15,7 +15,7 @@ extern "C" {
 
 
 /* RNG Config */
-#undef MBEDTLS_TEST_NULL_ENTROPY
+#undef MBEDTLS_ENTROPY_NV_SEED
 #undef MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
 #define MBEDTLS_PLATFORM_ENTROPY
 #define MBEDTLS_ENTROPY_C
@@ -29,6 +29,8 @@ extern "C" {
 #define MBEDTLS_SHA256_ALT
 #endif /* MBEDTLS_SHA256_C */
 
+#undef MBEDTLS_AES_SETKEY_DEC_ALT
+#undef MBEDTLS_AES_DECRYPT_ALT
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
index e4b66ff632497963addfb9504e69a5a82831a2ea..1015fae2da85e6f86047277c10530d2614b98243 100644
--- a/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
+++ b/lib/tf-m/secure_fw/partitions/protected_storage/crypto/ps_crypto_interface.c
@@ -24,7 +24,7 @@
 
 /* The PSA algorithm used by this implementation */
 #define PS_CRYPTO_ALG \
-    PSA_ALG_AEAD_WITH_TAG_LENGTH(PS_CRYPTO_AEAD_ALG, PS_TAG_LEN_BYTES)
+    PSA_ALG_AEAD_WITH_SHORTENED_TAG(PS_CRYPTO_AEAD_ALG, PS_TAG_LEN_BYTES)
 
 /*
  * \brief Check whether the PS AEAD algorithm is a valid one
@@ -35,7 +35,6 @@
  */
 typedef char PS_ERROR_NOT_AEAD_ALG[(PSA_ALG_IS_AEAD(PS_CRYPTO_ALG)) ? 1 : -1];
 
-static const uint8_t ps_key_label[] = "storage_key";
 static psa_key_id_t ps_key;
 static uint8_t ps_crypto_iv_buf[PS_IV_LEN_BYTES];
 
@@ -47,12 +46,16 @@ psa_status_t ps_crypto_init(void)
     return PSA_SUCCESS;
 }
 
-psa_status_t ps_crypto_setkey(void)
+psa_status_t ps_crypto_setkey(const uint8_t *key_label, size_t key_label_len)
 {
     psa_status_t status;
     psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
     psa_key_derivation_operation_t op = PSA_KEY_DERIVATION_OPERATION_INIT;
 
+    if (key_label_len == 0 || key_label == NULL) {
+        return PSA_ERROR_INVALID_ARGUMENT;
+    }
+
     /* Set the key attributes for the storage key */
     psa_set_key_usage_flags(&attributes, PS_KEY_USAGE);
     psa_set_key_algorithm(&attributes, PS_CRYPTO_ALG);
@@ -67,8 +70,8 @@ psa_status_t ps_crypto_setkey(void)
 
     /* Supply the PS key label as an input to the key derivation */
     status = psa_key_derivation_input_bytes(&op, PSA_KEY_DERIVATION_INPUT_LABEL,
-                                            ps_key_label,
-                                            sizeof(ps_key_label));
+                                            key_label,
+                                            key_label_len);
     if (status != PSA_SUCCESS) {
         goto err_release_op;
     }
diff --git a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_asymmetric_key.c b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_asymmetric_key.c
index 66052b40051c339012a0833671781f4d0e1e1df2..99317d76830d0c494aee4dcd0629ed0c27479aad 100644
--- a/lib/tf-m/secure_fw/partitions/initial_attestation/attest_asymmetric_key.c
+++ b/lib/tf-m/secure_fw/partitions/initial_attestation/attest_asymmetric_key.c
@@ -49,7 +49,8 @@ static size_t   attestation_public_key_len = 0;
 static psa_ecc_family_t attestation_key_curve;
 
 #ifdef INCLUDE_COSE_KEY_ID
-static uint8_t attestation_key_id[PSA_HASH_SIZE(PSA_ALG_SHA_256)]; /* 32bytes */
+/* 32bytes */
+static uint8_t attestation_key_id[PSA_HASH_LENGTH(PSA_ALG_SHA_256)];
 #endif
 
 /* Instance ID for asymmetric IAK */
@@ -81,7 +82,7 @@ attest_register_initial_attestation_key()
     }
 
     /* Setup the key policy for private key */
-    psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN);
+    psa_set_key_usage_flags(&key_attributes, PSA_KEY_USAGE_SIGN_HASH);
     psa_set_key_algorithm(&key_attributes, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
     psa_set_key_type(&key_attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(psa_curve));
 
@@ -228,7 +229,7 @@ attest_map_psa_ecc_curve_to_cose_ecc_curve(psa_ecc_family_t psa_curve)
 
     /* Note:  Mapping is not complete. */
     switch (psa_curve) {
-    case PSA_ECC_CURVE_SECP256R1:
+    case PSA_ECC_FAMILY_SECP_R1:
         cose_curve = COSE_ELLIPTIC_CURVE_P_256;
         break;
     default:
@@ -402,7 +403,7 @@ attest_get_initial_attestation_key_id(struct q_useful_buf_c *attest_key_id)
     struct q_useful_buf    buffer_for_attest_key_id;
 
     buffer_for_attest_key_id.ptr = attestation_key_id;
-    buffer_for_attest_key_id.len = PSA_HASH_SIZE(PSA_ALG_SHA_256);
+    buffer_for_attest_key_id.len = PSA_HASH_LENGTH(PSA_ALG_SHA_256);
 
     /* Needs to calculate only once */
     if (attest_key_id_calculated == 0) {
diff --git a/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c b/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
index d9f03719c6e4fadab3645afd0b7e2fe9ed26cd9f..44cd13542bf7f3e2b5137ed333eb4bcce79f277f 100644
--- a/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
+++ b/lib/tf-m/platform/ext/target/arm/mps2/an519/retarget/platform_retarget_dev.c
@@ -304,17 +304,23 @@ struct ppc_sse200_dev_t APB_PPCEXP3_DEV_S = {
 static const struct cmsdk_timer_dev_cfg_t CMSDK_TIMER0_DEV_CFG_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RO_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.base = CMSDK_TIMER0_BASE_S};
 static struct cmsdk_timer_dev_data_t CMSDK_TIMER0_DEV_DATA_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
     = {.is_initialized = 0};
 
 struct cmsdk_timer_dev_t CMSDK_TIMER0_DEV_S
 #ifdef TFM_ENABLE_SLIH_TEST
     TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_SLIH_TEST", "APP-ROT")
+#elif defined(TFM_ENABLE_FLIH_TEST)
+    TFM_LINK_SET_RW_IN_PARTITION_SECTION("TFM_SP_FLIH_TEST", "APP-ROT")
 #endif
        = {&(CMSDK_TIMER0_DEV_CFG_S), &(CMSDK_TIMER0_DEV_DATA_S)};
 #endif
diff --git a/lib/tf-m/interface/src/tfm_crypto_ipc_api.c b/lib/tf-m/interface/src/tfm_crypto_ipc_api.c
index e925c36ea9f1841ef94f9986e215a077a05e2ec5..9dfa4737ecfde4969f83ba700ed6462e9bad3f49 100644
--- a/lib/tf-m/interface/src/tfm_crypto_ipc_api.c
+++ b/lib/tf-m/interface/src/tfm_crypto_ipc_api.c
@@ -879,15 +879,63 @@ psa_status_t psa_aead_decrypt(psa_key_id_t key,
     return status;
 }
 
-psa_status_t psa_asymmetric_sign(psa_key_id_t key,
-                                 psa_algorithm_t alg,
-                                 const uint8_t *hash,
-                                 size_t hash_length,
-                                 uint8_t *signature,
-                                 size_t signature_size,
-                                 size_t *signature_length)
+psa_status_t psa_sign_message(psa_key_id_t key,
+                              psa_algorithm_t alg,
+                              const uint8_t *input,
+                              size_t input_length,
+                              uint8_t *signature,
+                              size_t signature_size,
+                              size_t *signature_length)
+{
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_SIGN_MESSAGE_SID,
+        .key_id = key,
+        .alg = alg,
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = signature, .len = signature_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_sign_message,
+                          TFM_CRYPTO_SIGN_MESSAGE);
+
+    if (status == PSA_SUCCESS) {
+        *signature_length = out_vec[0].len;
+    }
+
+    return status;
+}
+
+psa_status_t psa_verify_message(psa_key_id_t key,
+                                psa_algorithm_t alg,
+                                const uint8_t *input,
+                                size_t input_length,
+                                const uint8_t *signature,
+                                size_t signature_length)
 {
-    return psa_sign_hash(key, alg, hash, hash_length, signature, signature_size, signature_length);
+    psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_VERIFY_MESSAGE_SID,
+        .key_id = key,
+        .alg = alg
+    };
+
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = signature, .len = signature_length}
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_verify_message,
+                                    TFM_CRYPTO_VERIFY_MESSAGE);
+
+    return status;
 }
 
 psa_status_t psa_sign_hash(psa_key_id_t key,
@@ -921,16 +969,6 @@ psa_status_t psa_sign_hash(psa_key_id_t key,
     return status;
 }
 
-psa_status_t psa_asymmetric_verify(psa_key_id_t key,
-                                   psa_algorithm_t alg,
-                                   const uint8_t *hash,
-                                   size_t hash_length,
-                                   const uint8_t *signature,
-                                   size_t signature_length)
-{
-    return psa_verify_hash(key, alg, hash, hash_length, signature, signature_length);
-}
-
 psa_status_t psa_verify_hash(psa_key_id_t key,
                              psa_algorithm_t alg,
                              const uint8_t *hash,
@@ -1273,8 +1311,26 @@ psa_status_t psa_mac_compute(psa_key_id_t key,
                              size_t *mac_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_COMPUTE_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = mac, .len = mac_size},
+    };
+
+    status = API_DISPATCH(tfm_crypto_mac_compute,
+                          TFM_CRYPTO_MAC_COMPUTE);
+
+    if (status == PSA_SUCCESS) {
+        *mac_length = out_vec[0].len;
+    }
 
     return status;
 }
@@ -1287,8 +1343,20 @@ psa_status_t psa_mac_verify(psa_key_id_t key,
                             const size_t mac_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_MAC_VERIFY_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+        {.base = mac, .len = mac_length},
+    };
+
+    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_mac_verify,
+                                    TFM_CRYPTO_MAC_VERIFY);
 
     return status;
 }
@@ -1302,8 +1370,26 @@ psa_status_t psa_cipher_encrypt(psa_key_id_t key,
                                 size_t *output_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_ENCRYPT_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size}
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_encrypt,
+                          TFM_CRYPTO_CIPHER_ENCRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
 }
@@ -1317,8 +1403,26 @@ psa_status_t psa_cipher_decrypt(psa_key_id_t key,
                                 size_t *output_length)
 {
     psa_status_t status;
+    struct tfm_crypto_pack_iovec iov = {
+        .sfn_id = TFM_CRYPTO_CIPHER_DECRYPT_SID,
+        .key_id = key,
+        .alg = alg,
+    };
 
-    status = PSA_ERROR_NOT_SUPPORTED;
+    psa_invec in_vec[] = {
+        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
+        {.base = input, .len = input_length},
+    };
+    psa_outvec out_vec[] = {
+        {.base = output, .len = output_size}
+    };
+
+    status = API_DISPATCH(tfm_crypto_cipher_decrypt,
+                          TFM_CRYPTO_CIPHER_DECRYPT);
+
+    if (status == PSA_SUCCESS) {
+        *output_length = out_vec[0].len;
+    }
 
     return status;
 }
diff --git a/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c b/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
index c868d953b3968c1ef2a4b0dbfaafd2a242b1bd83..90e3d0a84ff39051c93a75e0544b4ea30ad6e2cd 100644
--- a/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
+++ b/lib/tf-m/platform/ext/common/template/crypto_nv_seed.c
@@ -9,8 +9,33 @@
 #include "tfm_plat_crypto_nv_seed.h"
 #include "psa/internal_trusted_storage.h"
 
+#ifndef TFM_PSA_API
+#include "mbedtls/entropy.h"
+
+static unsigned char seed_buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
+
+/*
+ \brief Copy the seed to the destination buffer
+
+ \param[out]  p_dst  Pointer to buffer where to store the seed
+ \param[in]   p_src  Pointer to the seed
+ \param[in]   size   Length of the seed
+*/
+static inline void copy_seed(uint8_t *p_dst, const uint8_t *p_src, size_t size)
+{
+    uint32_t i;
+
+    for (i = size; i > 0; i--) {
+        *p_dst = *p_src;
+        p_src++;
+        p_dst++;
+    }
+}
+#endif
+
 int tfm_plat_crypto_nv_seed_read(unsigned char *buf, size_t buf_len)
 {
+#ifdef TFM_PSA_API
     psa_storage_uid_t uid = NV_SEED_FILE_ID;
     psa_status_t status;
     size_t data_length = 0;
@@ -22,10 +47,19 @@ int tfm_plat_crypto_nv_seed_read(unsigned char *buf, size_t buf_len)
     } else {
         return TFM_CRYPTO_NV_SEED_FAILED;
     }
+#else
+    if (buf_len != MBEDTLS_ENTROPY_BLOCK_SIZE) {
+        return TFM_CRYPTO_NV_SEED_FAILED;
+    } else {
+        copy_seed(buf, seed_buf, buf_len);
+        return TFM_CRYPTO_NV_SEED_SUCCESS;
+    }
+#endif
 }
 
 int tfm_plat_crypto_nv_seed_write(const unsigned char *buf, size_t buf_len)
 {
+#ifdef TFM_PSA_API
     psa_storage_uid_t uid = NV_SEED_FILE_ID;
     psa_status_t status;
 
@@ -36,4 +70,12 @@ int tfm_plat_crypto_nv_seed_write(const unsigned char *buf, size_t buf_len)
     } else {
         return TFM_CRYPTO_NV_SEED_FAILED;
     }
+#else
+    if (buf_len != MBEDTLS_ENTROPY_BLOCK_SIZE) {
+        return TFM_CRYPTO_NV_SEED_FAILED;
+    } else {
+        copy_seed(seed_buf, buf, buf_len);
+        return TFM_CRYPTO_NV_SEED_SUCCESS;
+    }
+#endif
 }
diff --git a/lib/tf-m/secure_fw/spm/include/spm_partition_defs.h b/lib/tf-m/secure_fw/spm/include/spm_partition_defs.h
index 07f224e84c806ad6e8fc99f2b48e8c47f8a4d34e..252f99c05ba56ab92e6510d4e2dd52d7af1a3911 100644
--- a/lib/tf-m/secure_fw/spm/include/spm_partition_defs.h
+++ b/lib/tf-m/secure_fw/spm/include/spm_partition_defs.h
@@ -24,12 +24,14 @@
  * operations.
  */
 #define TFM_SP_NON_SECURE_ID (0)
+#define TFM_SP_IDLE_ID       (1)
 /* A dummy partition for TFM_SP_CORE is created to handle secure partition
  * calls done directly from the core, before NS execution started.
  */
 #define TFM_SP_CORE_ID (1)
 
 #include "psa_manifest/pid.h"
+#include "psa/service.h"
 
 /* This limit is only used to define the size of the database reserved for
  * partitions. There's no requirement that it match the number of partitions
@@ -38,5 +40,6 @@
 #define SPM_MAX_PARTITIONS (TFM_MAX_USER_PARTITIONS + TFM_INTERNAL_PARTITIONS)
 
 typedef void(*sp_entry_point)(void);
+typedef psa_flih_result_t (*psa_flih_func)(void);
 
 #endif /* __SPM_PARTITION_DEFS_H__ */
